assert
Bounds
assert
Bounds
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equals
assert
Equivalent
assert
False
assert
False
assert
Faster
Than
assert
In
Range
assert
Less
Than
assert
More
Than
assert
Not
Equals
assert
Not
Less
Than
assert
Not
More
Than
assert
Not
Null
Or
Empty
assert
Result
assert
Result
assert
Result
assert
Result
assert
Solution
Feasible
assert
Solution
Feasible
assert
Solution
Valid
assert
Solution
Valid
assert
State
And
Solution
assert
State
And
Solution
assert
State
And
Solution
assert
State
And
Solution
assert
State
Less
Than
Feasible
assert
State
Not
Less
Than
Feasible
assert
State
Not
Less
Than
Optimal
assert
Tensor
Equals
assert
True
assert
True
assert
True
fail
fail
fail
fail
get
Resource
get
Resource
make
Random
Complex
Store
minimise
All
Branch
Limits
build
Absolute
Resource
Path
assert
Optimisation
Result
test
Fast
test
Quoted
test
RFC4180
do
Test
Password
test
Encryption
test
Generation
test
Columns
main
expiry
Date2Delta
Seconds
get
Body
get
RHS
get
Solution
get
Factor
R
get
Transformed
RHS
do
Before
Each
test
Data
test
Problem
main
setup
tune
setup
tune
main
setup
tune
test
Case
From
Matrix
Computations
test
Complex
Square
Case
test
Fat
Eye
test
Fat
Random
test
Square
Bidiagonal
test
Square
Eye
test
Square
Random
test
Tall
Eye
test
Tall
Random
do
Print
do
Test
Correct
make
Eye
get
Any
All
get
Any
Bidiagonal
get
Any
Cholesky
get
Any
Eigenvalue
get
Any
Eigenvalue
Dynamic
get
Any
Eigenvalue
General
get
Any
Eigenvalue
Hermitian
get
Any
Hessenberg
get
Any
LDL
get
Any
LU
get
Any
Matrix
Decomposition
Rank
Revealing
get
Any
Matrix
Decomposition
Solver
get
Any
QR
get
Any
Singular
Value
get
Any
Tridiagonal
get
Primitive
All
get
Primitive
Bidiagonal
get
Primitive
Cholesky
get
Primitive
Eigenvalue
get
Primitive
Eigenvalue
Dynamic
get
Primitive
Eigenvalue
General
get
Primitive
Eigenvalue
Symmetric
get
Primitive
Hessenberg
get
Primitive
LDL
get
Primitive
LU
get
Primitive
Matrix
Decomposition
Rank
Revealing
get
Primitive
Matrix
Decomposition
Solver
get
Primitive
QR
get
Primitive
Singular
Value
get
Primitive
Tridiagonal
minimise
All
Branch
Limits
make
Hermitian
Matrix
minimise
All
Branch
Limits
test
Diagonal
Case
test
Compilation
test
Hermitian
test
Least
Squares
Invert
test
P20030422Case
test
Solve
Both
Ways
test
Solve
Both
Ways
Symmetric
minimise
All
Branch
Limits
test
Fullerton
Example1and2
test
Fullerton
Exercise3
test
Fullerton
Exercise4and5
test
Types
With
Random
test
Wikipedia
Example
do
The
Test
main
primitive
raw
setup
make
Primitive
make
Raw
main
setup
test
Copied
Version
test
Modified
Version
computed
copy
get
Col
Dim
get
Row
Dim
reset
set
Raw
In
Place
main
primitive
raw
setup
make
Primitive
make
Raw
main
scale
setup
transpose
tune
new
Instance
new
Primitive
new
Raw
execute
main
primitive
raw
setup
make
Primitive
make
Raw
main
setup
tune
main
primitive
raw
setup
make
Primitive
make
Raw
minimise
All
Branch
Limits
test
Complex
test
Dense
Primitive32
test
Dense
Primitive64
test
Rational
test
Raw
Primitive
main
setup
tune
primitive
raw
make
Primitive
make
Raw
setup
minimise
All
Branch
Limits
test
Simple
Cholesky
Case
test
Simple
Eigenvalue
Case
test
Simple
LU
Case
test
Simple
QR
Case
test
Simple
Singular
Value
Case
compute
And
Test
minimise
All
Branch
Limits
test
Inverse
Of
Random
SPD
test
Simple
Equation
Case
test
Solve
Both
Ways
Simple
Cholesky
Case
test
Solve
Both
Ways
Simple
Equation
Case
full
QR
full
SVD
minimise
All
Branch
Limits
test
Extracting
Components
Of
Wide
QR
test
Git
Hub
Issue214
test
P20090923
test
P20091012
test
P20091012fixed
test
P20100512
test
P20110126
test
P20110223
test
P20111213square
test
P20111213tall
test
P20160419
test
P20160510Invert
Large
Matrix
test
P20180614
test
P20180617
minimise
All
Branch
Limits
test
Basic
Matrix
P20030422Case
test
Basic
Matrix
P20030512Case
test
Basic
Matrix
P20030528Case
test
Basic
Matrix
P20050125Case
test
Basic
Matrix
P20050827Case
test
Basic
Matrix
P20061119Case
test
Basic
Matrix
P20071019Fat
Case
test
Basic
Matrix
P20071019Tall
Case
test
Complex
Number
Version
Of
Wikipedia
Case
test
Get
Covariance
test
Pseudoinverse
Solve
test
Random
Actually
Complex
Case
test
Random
Fat
Case
test
Random
Square
Case
test
Random
Tall
Case
test
Recreation
Fat
test
Recreation
Square
test
Recreation
Tall
do
Test
Types
test
Recreation
main
primitive
raw
setup
simultaneous
make
Primitive
make
Raw
make
Simultaneous
Primitive
new
Random
do
Test
Eigenvalues
do
Test
Eigenvalues
Of
Generated
do
Verify
General
minimise
All
Branch
Limits
test
Complex
Eigenpair
test
Generalised
Complex
Eigenvalue
test
Generate
Random
All
Negative
test
Generate
Random
All
Positive
test
Generate
Random
Some
Negative
test
Generate
Random
Some
Zero
test
Git
H
Ub
Issue366
test
Jama
Problem
test
P20050125Case
test
P20061119Case
test
Pauls
Math
Note
test
Primitive
As
Complex
test
Problem
Found
In
The
Wild
test
Random
Generalised
A
B
test
Random
Generalised
AB
test
Random
Generalised
BA
test
Random
Generalised
Unprepared
test
Random
Symmetric
Values
Only
test
Special4by4
main
primitive
raw
setup
make
Primitive
make
Raw
minimise
All
Branch
Limits
test
Square
Eye
test
Square
Random
do
Print
do
Test
Correct
make
Eye
perform
Invert
Test
perform
Solve
Test
do
Test
Invert
do
Test
SVD
do
Test
Rank
do
Test
Solve
get
Very
Small
minimise
All
Branch
Limits
test
Ev
D
test
Invert
Ev
D
10
307
1
test
Invert
Ev
D
3
155
1
test
Invert
SVD
6
307
2
test
Invert
SVD
7
307
1
test
Invert
Task
2
155
1
test
LU
test
Overflow
Invert
test
Overflow
Rank
test
Overflow
Solve
test
QR
test
Solve
LU
1
16
1
test
Underflow
Invert
test
Underflow
Rank
test
Underflow
Solve
test
Underflow
SVD
test
Overflow
SVD
minimise
All
Branch
Limits
test
Cholesky
Solve
Inverse
test
Full
Size
test
Random
Underdetermined
test
Solvable
test
Solve
Identity
test
Solve
Inverse
test
Tridiagonal
test
Wikipedia
Nullspace
test
Wikipedia
SVD
do
Test
Solve
Inverse
minimise
All
Branch
Limits
test
Simple
Cholesky
Case
test
Simple
Eigenvalue
Case
test
Simple
LU
Case
test
Simple
QR
Case
test
Simple
Singular
Value
Case
minimise
All
Branch
Limits
test
P20061119Case
test
Reconstruct
When
Pivoted
test
Solve
Both
Ways
main
setup
tune
minimise
All
Branch
Limits
test
Heath
test
Small2x2
test
Wikipedia
do
Test
do
Test
do
Test
Bound
Of
Modified
LDL
new
Problematic1
new
Special
Schnabel
Eskow
minimise
All
Branch
Limits
test
Bound
On
Generated
All
Possitive
test
Bound
On
Generated
Some
Negative
test
Bounds
On
Problematic1
test
Bounds
On
Special
Schnabel
Eskow
test
No
Negative
Eigenvalues
test
Quad
Opt
KTH
test
Reconstruct
When
Pivoted
test
Wikipedia
Case
test
Wikipedia
Case
Pre
Pivoted
test
LDL
Modified
throw
If
Not
Symmetric
has
Negative
Eigenvalue
main
get
Identity
get
Safe
factories
do
After
Each
do
Before
Each
test
Add
Element
test
Add
Matrix
test
Add
Scalar
test
Conjugate
test
Count
test
Count
Columns
test
Count
Rows
test
Divide
Elements
Basic
Matrix
test
Divide
Scalar
test
Dot
Access1D
test
Double
Value
Int
Int
test
Get
Columns
Int
Array
test
Get
Condition
test
Get
Determinant
test
Get
Eigenvalues
test
Get
Infinity
Norm
test
Get
One
Norm
test
Get
Rank
test
Get
Rows
Int
Array
test
Get
Trace
test
Invert
test
Is
Empty
test
Is
Fat
test
Is
Hermitian
test
Is
Square
test
Is
Symmetric
test
Is
Tall
test
Is
Vector
test
Logical
Builder
test
Merge
Columns
Basic
Matrix
test
Merge
Rows
Basic
Matrix
test
Multiply
Elements
Basic
Matrix
test
Multiply
Matrix
test
Multiply
Scalar
test
Negate
test
Norm
test
Reduce
Rows
And
Columns
test
Set
Element
test
Solve
Matrix
test
Subtract
Matrix
test
Subtract
Scalar
test
To
List
Of
Columns
test
To
List
Of
Rows
test
To
Raw
Copy1D
test
To
Scalar
Int
Int
test
Transpose
get
Original
get
Factor
L
get
Factor
R
do
Before
Each
test
Data
test
Problem
configure
test
Multiply
Both
test
Multiply
Both
Shaded
test
Multiply
Left
test
Multiply
Left
Shaded
test
Multiply
Neither
test
Multiply
Right
test
Multiply
Right
Shaded
main
setup
tune
main
setup
tune
main
setup
main
setup
tune
main
fill
Rx
N
fill
Mx
N
setup
main
multiply
Right
Dynamic
Int
multiply
Right
Dynamic
Pre
multiply
Right
Fixed
Int
multiply
Right
Fixed
Pre
multiply
Right
Standard
Int
multiply
Right
Standard
Pre
setup
main
setup
options
setup
tune
main
multiply
Both
multiply
Left
multiply
Neither
multiply
Right
setup
configure
test
Multiply
Both
P32
test
Multiply
Both
P64
test
Multiply
Both
Shaded
P32
test
Multiply
Both
Shaded
P64
test
Multiply
Left
P32
test
Multiply
Left
P64
test
Multiply
Left
Shaded
P32
test
Multiply
Left
Shaded
P64
test
Multiply
Neither
P32
test
Multiply
Neither
P64
test
Multiply
Right
P32
test
Multiply
Right
P64
test
Multiply
Right
Shaded
P32
test
Multiply
Right
Shaded
P64
main
setup
configure
test
Multiply
Both
test
Multiply
Both
Shaded
test
Multiply
Left
test
Multiply
Left
Shaded
test
Multiply
Neither
test
Multiply
Right
test
Multiply
Right
Shaded
main
setup
tune
execute
tune
main
multiply
Both
multiply
Dynamic
multiply
Right
multiply
Static
setup
main
setup
tune
main
setup
tune
main
setup
main
setup
tune
tune
Primitive
tune
Raw
main
invoke
CIJ
invoke
CJI
invoke
ICJ
invoke
IJC
invoke
JCI
invoke
JIC
invoke
CIJ
invoke
CJI
invoke
ICJ
invoke
IJC
invoke
JCI
invoke
JIC
setup
options
setup
tune
tune
main
setup
tune
get
Problematic
do
Before
Each
test
Data
test
Problem
get
Problematic
do
Before
Each
test
Data
test
Problem
test
Solve
Matrix
test
Full2X2
test
Full3X3
test
Full4X4
test
Full5X5
test
Symmetric1X1
test
Symmetric2X2
test
Symmetric3X3
test
Symmetric4X4
test
Symmetric5X5
do
General
do
Symmetric
make
General
make
Symmetric
test
Example
Wikipedi
A
test
Full2X2
test
Full3X3
test
Full4X4
test
Full5X5
test
Lin
Alg34PDF
test
Symmetric1X1
test
Symmetric2X2
test
Symmetric3X3
test
Symmetric4X4
test
Symmetric5X5
test
Underdetermined
Iterative
do
Compare
get
Primitive
Full
get
Primitive
Symmetric
set
Up
test
Full2X2
test
Full3X3
test
Full4X4
test
Full5X5
test
Symmetric1X1
test
Symmetric2X2
test
Symmetric3X3
test
Symmetric4X4
test
Symmetric5X5
do
Compare
get
Original
do
Before
Each
test
Data
test
Problem
get
Fat
Problematic
get
Tall
Problematic
do
Before
Each
test
Data
test
Problem
test
Compare
Complex
Number
test
Compare
Quaternion
get
Body
get
RHS
get
Solution
do
Before
Each
get
Orginal
get
Mtrx
L
get
Mtrx
U
do
Before
Each
test
Data
test
Problem
get
Problematic
do
Before
Each
test
Get
Rank
test
Problem
get
Problematic
do
Before
Each
test
Data
test
Problem
test
Reduction
get
Original
get
Matrix
D
get
Matrix
V
do
Before
Each
test
Data
test
Problem
get
Problematic
do
Before
Each
test
Data
test
Get
Rank
test
Problem
main
hypot
multiply
setup
test
Dense
Receiver
test
Sparse
Receiver
get
Original
get
Factor
Q
get
Factor
R
do
Before
Each
test
Data
test
Problem
get
Problematic
do
Before
Each
test
Invert
test
Problem
get
Original
get
Matrix
D
get
Matrix
Q1
get
Matrix
Q2
do
Before
Each
test
Data
test
Problem
set
Up
initialise
test
On
All
test
On
Any
test
On
Columns
test
On
Matching
Left
test
On
Matching
Right
test
On
Rows
test
Transpose
count
Columns
count
Rows
double
Value
first
In
Column
first
In
Row
get
limit
Of
Column
limit
Of
Row
physical
supply
To
test
Git
Hub
Issue252
test
P20071210
test
P20110223
test
Git
Hub
Issue330
test
P20180121
test
Transpose
Elements
Supplier
first
In
Column
first
In
Row
limit
Of
Column
limit
Of
Row
set
Up
block
Matrix
filled
Matrix
filled
Matrix
double
Value
invoke
sparse
Matrix
sparse
Matrix
set
Up
fill
touch
Nonzeros
test
Elementwise
Multiplication
test
Matrix
Multiplication
test
Multiply
By
One
Vector
test
Reduce
Columns
test
Reduce
Rows
test
Reset
do
Test
Multiplication
set
Up
test
Index
Of
Largest
test
Multiply
Sparse
Dense
Complex
test
Multiply
Sparse
Dense
Primitive
test
Multiply
Sparse
Dense
Quaternion
test
Multiply
Sparse
Dense
Rational
test
One
Full
Column
test
One
Full
Row
test
Aggregation
test
Copy
test
Dimensions
test
Multiplication
make
Random
Matrix
set
Up
tear
Down
test
Aggregator
test
Copy
test
Dimensions
test
Multiplication
minimise
All
Branch
Limits
set
Up
set
Up
set
Up
set
Up
set
Up
test
Multiplying
And
Transposing
set
Up
set
Up
set
Up
set
Up
set
Up
test
Power
test
Repeated
Multiplications
main
invoke1
invoke2
changed
defined
setup
do
Test
Lower
Tail
do
Test
Upper
Tail
test
Approximation
test
Degree2
test
Table
Comparison
test
Confidence
Intervals
test
Distribution
Consistency
test
Log
Normal
test
Wikipedia
Cases
log
Debug
test
Tutorial
calibrate
invoke
invoke
test
Exponential
test
Log
Normal
test
Normal
test
Uniform
do
Test
do
Table
Test
test
Against
Specific
Variants
test
Table
Comparison
test
Constant
test
Decrease
test
Increase
test
Standard
test
Compare
ARC
Hto
GARCH
test
Constant
test
Decrease
test
Increase
test
Standard
test
Empty
Set
test
Mean
Value
test
Quartile
Ex1
test
Quartile
Ex2
test
Quartile
Size0
test
Quartile
Size1
test
Quartile
Size2
test
Quartile
Size3
test
Quartile
Size4
test
Quartile
Size6
test
Quartile
Size8
get
Dist
get
Dist
get
Dist
get
Dist
get
Dist
compare
Density
compare
Density
compare
Distribution
compare
Distribution
compare
Quantile
compare
Quantile
test
ERF
test
ER
Fand
ERFI
test
ERFI
test
Erlang
test
Gamma
test
Geometric
Mean
And
Standard
Deviation
test
Log
Normal
test
Norm2
test
Normal
test
Sampled
Mean
test
Setting
Seed
test
T
Distribution
Freedom
Cases
test
Variance
test
Weibull
test
Weibull
With
Shape1
test
Dist2
test
Compare
Product
Between
Factories
test
Compare
Sum
Between
Factories
test
Conjugate2D
test
Conjugate3D
test
Conjugate4D
test
Determinant
And
Trace
test
Kronecker
Product
test
Product
Of
Vectors
test
Sum
Of
Vectors
test
Tensor
Product
Of3Vectors
do
Test
test
AARCH64

08
test
Compare
test
PPC

01
test
X86

01
test
X86

02
test
X86
64

02
test
X86
64

04
1
L2
test
X86
64

04
1
L3
test
X86
64

04
2
test
X86
64

08
test
X86
64

12
test
X86
64

16
test
Equals
equal
test
Equals
memory
Unequal
test
Equals
object
Null
test
Equals
threads
Unequal
test
Hash
Code
test
To
String
test
Byte
Array
options
run
run
do
Test
Cleaning
test
Cleaning
Case010A
test
Cleaning
Case020A
test
Cleaning
Case030B
test
Cleaning
Case040B
test
Cleaning
Case050B
test
Cleaning
Next
Gen50
test
Conversions
test
Double
Keys
test
Resample
test
Derive
Distributions
test
Fetch
Daily
test
Fetch
Monthly
test
Fetch
Weekly
test
Yahoo
Daily
AAPL
test
Yahoo
Monthly
AAPL
test
Yahoo
Weekly
AAPL
assert
At
Least
Expected
Items
do
Test
Derive
Distribution
test
Alpha
Vantage
Daily
MSFT
test
Alpha
Vantage
Monthly
MSFT
test
Alpha
Vantage
Weekly
MSFT
test
Derive
Distributions
test
Fetch
Daily
test
Fetch
Monthly
test
Fetch
Weekly
accept
first
Date
first
Price
last
Date
last
Price
size
compare
With
Detecting
Parser
test
Alpha
Vantage
Daily
AAPL
test
Alpha
Vantage
Daily
MSFT
test
Alpha
Vantage
Monthly
AAPL
test
Alpha
Vantage
Monthly
MSFT
test
Alpha
Vantage
Weekly
AAPL
test
Alpha
Vantage
Weekly
MSFT
test
IEX
Trading
Daily
AAPL
test
Yahoo
Daily
AAPL
test
Yahoo
Monthly
AAPL
test
Yahoo
Weekly
AAPL
get
Asset
Names
get
CAPM
Returns
get
CAPM
Weights
get
Covariances
get
Historical
Returns
get
Historical
Weights
get
Investor
Confidences
Matrix
get
Investor
Portfolios
Matrix
get
Investor
Returns
Matrix
get
Market
Returns
get
Market
Weights
get
Modified
Returns
get
Modified
Weights
get
Risk
Aversion
Factor
get
Variance
Of
Investor
View
Portfolios
get
Weight
On
Views
make
test
CAPM
Data
test
Covariance
Data
test
Historical
Data
test
Market
Data
test
Modified
Data
test
Variance
Of
Investor
View
Portfolios
test
Views
With
Deferred
Confidence
test
Views
With
Standard
Deviation
test
BLM
make
Market
Equilibrium
get
Covarance
get
Covariances
get
Expected
Excess
Returns
build
Problematic
Markowitz
Model
build
Markowitz
Model
test
Hanging
test
Originally
Hanging
But
Now
Cleaned
test
P20160705
test
Success
main
get
Covariances
test
Random
Problems
Compared
To
Equilibrium
test
Stepping
test
P20090115
test
P20110614
test
P20130329
test
P20141202
test
P20160608
test
P20170508
test
P20181204
test
P20200821
test
Strat
Comb
Portfolio
Mixer
test
Strat
Comb
Portfolio
Mixer
Random
test
Strat
Comb
Quadratic
Expression
Model
test
Channel
Separation
set
Up
test
Add
test
Conjugate
test
Divide
test
Invert
test
Multiply
test
Negate
test
Subtract
assert
Equal
make
Random
test
Modulus
test
Power
do
Test
Value
Of
To
Big
Decimal
test
Add
test
Create
And
Extract
test
Divide
test
Invert
test
Multiply
test
Subtract
main
rational
setup
value
Of
test
Log
Exp
And
Back
Again
test
Polar
Form
test
Random
Multiplication
test
Random
Rotation
test
Rotation
Matrix
Math
Works
Example
rational2
test
Add
test
Divide
test
Infinity
test
Invert
test
Multiplication
test
Multiply
test
Na
N
test
Negate
test
Power
test
Rational
test
Rational
Number
test
Rationals
test
Subtract
test
Value
Of
test
Value
Of
test
Concatenations
test
Compare
Precision
And
Scale
Big
Decimal
test
Compare
Precision
And
Scale
Primitive
test
Is
Small
test
Percent
Context
test
Precision
test
Precision
And
Scale
Mutations
do
Test
From
do
Test
From
With
Resolution
do
Test
Plain
test
From
test
Plain
increment
test
Compute
test
Process
test
Run
test
Divide
By
test
Adjust
Up
Down
test
Min
Max
test
Increment
Decrement
get
Matrices
build
P20080117
get
Data
P20140522
buil
And
Test
Model
buil
And
Test
Model
build
Model
test
Infeasible
Case
test
Not
Convex
Problem
test
Optimus
Pull33
test
P20080117
test
P20080118
test
P20080124
test
P20080204
test
P20080208
test
P20080819
test
P20081014
test
P20081015
test
P20081119
test
P20090115
test
P20090202
test
P20090924
test
P20091102a
test
P20091102b
test
P20111129
test
P20111205
test
P20140109
test
P20140522
test
P20150720
test
P20150809
test
P20150908
test
P20150922
test
P20200924
test
P20200924NG
assert
State
Validation
Consistency
test1
test2
test3
test4
test5
test6
build
test
Gavin
And
Scruggs
Example
test
Nocedal
And
Wright
Example
parse
Line
read
Matrix
build
Model
test
P20170508
assert
Direct
And
Iterative
Equals
assert
Direct
And
Iterative
Equals
get
Optimisation
Data
get
Matrices
do
Reimplement
Example4
get
Residual
Quadruple
Precision
test
Iterative
Refinement
Solver
test
Iterative
Refinement
Solver
V2
test
Reimplement
Example4
test
QP1
test
QP2
test
QP3
test
QP4
get
Matrices
get
Matrices
get
Solution
E
get
Solution
I
set
Up
test
Case
Data
test
Solver
Results
get
Matrices
get
Matrices
alpha
Values
prepare
Model
result
Should
Honor
Inequalities
solution
Should
Be
Better
Than
Some
Profile
set
Up
do
Test
do
Test
test
TCQP
Optimal
Fail
test
TCQP
Work
And
Fail
get
Ratio
QP
is
Pure
QP
is
Separable
is
Small
to
String
get
Model
Info
get
Model
Info
make
Model
do
Test
do
Test
test
CVXQP1
M
test
CVXQP2
M
test
CVXQP3
M
test
DUALC1
test
DUALC2
test
DUALC5
test
DUALC8
test
GENHS28
test
GOULDQP2
test
HS21
test
HS268
test
HS35
test
HS35MOD
test
HS51
test
HS52
test
HS53
test
HS76
test
KSIP
test
MOSARQP2
test
PRIMAL1
test
PRIMALC2
test
PRIMALC8
test
QADLITTL
test
QBANDM
test
QBORE3D
test
QE226
test
QFORPLAN
test
QGROW22
test
QGROW7
test
QPCBLEND
test
QPCBOEI1
test
QPCSTAIR
test
QPTEST
test
QRECIPE
test
QSCAGR7
test
QSCORPIO
test
QSCTAP1
test
QSHARE1B
test
QSTAIR
test
S268
test
TAME
test
ZECEVIC2
build
Model1
build
Model2
build
Model3
main
main
attempt5
build
Model
main
get
Matrices
assert
Values
make
Model
main
test
Bug1
do
Test
test
Big
Binary
test
Energy
App
do
Test
test
Initial
Cuts
Of
Gr4x6
do
Test
test
B
ball
test
Ej
test
Flugpl
test
Gen
ip002
test
Gen
ip021
test
Gen
ip036
test
Gen
ip054
test
Gr4x6
test
Mad
test
Markshare
4
0
test
Markshare
5
0
test
Markshare1
test
Markshare2
test
Mas76
test
Modglob
test
Neos5
test
Neos911880
test
Noswot
test
P2m2p1m1p0n100
test
Pk1
test
Pp08a
test
Pp08a
CUTS
test
Timtab1
test
Vpm2
add
Item
build
test
Varying
Max
Weight0
test
Varying
Max
Weight1
test
Varying
Max
Weight2
test
Varying
Max
Weight3
test
Varying
Max
Weight4
assert
One
assert
Zero
get
Model
main
get
Coefficients
do
Test
test
Case52
test
Case63
test
Case83
do
Test
Infeasible
Node
do
Test
Relaxed
At
Specific
Node
do
Test
To
Match
Expected
make
Model
test
Branching
On2
test
Cuts
test
Infeasible
Node1
test
Infeasible
Node2
test
Infeasible
Node3
test
Infeasible
Node4
test
Infeasible
Node5
test
Infeasible
Node6
test
Infeasible
Node7
test
Infeasible
Node8
test
Infeasible
Node9
test
Original
Full
Model
test
P20140819fix1
test
P20140819fix2
test
P20140819fix3
test
Problematic
Node
B
test
Relaxed
At
Specific
Node1
test
Relaxed
But
Constrained
To
Optimal
test
Variables
Level
Set
test
Variables
Lower
Set
test
Variables
Nonzero
Level
Set
test
Variables
Upper
Set
validate
Solution
From
CPLEX
do
Test
test
B
ball
test
Flugpl
test
Gr4x6
test
Markshare
4
0
test
Neos5
test
Pk1
main
make
Model
test
Mip
But
Some
Constained
To
Optimatl
test
Redundant
C1
test
Redundant
C2
test
Redundant
C3
test
Redundant
C4
test
Redundant
C5
test
Relaxed
But
All
Constrained
To
Optimal
test
Relaxed
But
Integer
Constrained
To
Optimal
test
Specific
Branch
37
8
test
Redundant
get
Beta
get
Beta
Vctr
get
Covariance
get
Covariance
Mtrx
get
Data
Set
Mtrx
get
Estimated
Value
get
Margin
get
Margin
Vctr
get
Optimal
Value
get
Optimisation
Solution
get
Optimisation
Solution
get
Return
get
Return
Vctr
number
Of
Assets
to
Cleaned
Covariances
to
Correlations
to
Volatilities
assert
Solution
build
Model
solve
Sequentially
to
Correlations
to
Covariances
to
Volatilities
test
Sequential
Case010A
test
Sequential
Case020A
test
Sequential
Case030B
test
Sequential
Case040B
test
Sequential
Case050B
do
Test
All
In
One
do
Test
Sequential
do
Test
Node
make
Model
test
Flugpl
N7
test
Noswot
N1
test
Noswot
N2
test
Noswot
N3
test
Noswot
N4
test
Vpm2First
Branch
build
Model
For
P20100412
make
Original
Root
Model
test
Full
MIP
test
Relaxed
But
Constrained
To
Optimal
MIP
test
Relaxed
Node
P00
test
Relaxed
Node
P01
test
Relaxed
Node
P02
test
Relaxed
Node
P03
test
Relaxed
Node
P04
test
Relaxed
Node
P05
test
Relaxed
Node
P06
test
Relaxed
Node
P07
test
Relaxed
Node
P08
test
Relaxed
Node
P09
test
Relaxed
Node
P10
test
Relaxed
Node
P11
test
Relaxed
Node
P12
get
Model
main
get
Coefficients
do
Test
test
Ej
test
Gen
ip002
test
Gen
ip021
test
Gen
ip036
test
Gen
ip054
test
Mad
test
Markshare
5
0
test
Markshare1
test
Markshare2
test
Mas76
test
Modglob
test
Neos911880
test
Noswot
test
Pp08a
test
Pp08a
CUTS
test
Timtab1
test
Vpm2
test
Strat
Comb
Quadratic
Expression
Model
make
Branch
And
Cut
Simple
Example
Model
test
Bad
Mixed
Integer
Cut
Example
test
Branch
And
Cut
Simple
Example
test
Expressing
The
Cut
In
The
Original
Variables
test
Facility
Location
test
SOS
main
pre
Calculate
Costs
make
Model
make
Model
Git
Hub513
test
Git
Hub513
test
P20100412
test
P20111010
test
P20130225
test
P20130409a
test
P20130409b
test
P20150127full
test
P20150127infeasible
Node
test
Simple
TSP20160701
test
Simplification
Git
Hub
Issue309
test
Status
For
Aborted
Optimization
Git
Hub
Issue310
do
Test
do
Test
test
HFLP201501020845
test
HFLP201607121500
test
HFLP201706011645
test
HFLP20170601T164500
test
HFLP202001081415
test
HFLP202004011500
test
HFLP202004161430
test
HFLP202009161330
test
HFLP202009181715
test
HFLP202009211500
test
HFLP20200921T150000
run
make
Model
launch
Slow
Minimization
slow
Minimisation
Should
Be
Slow
slow
Minimization
Should
Be
Interrupted
test
Lecture6Example
test
Degeneracy
test
Multiple
Optimal
Solutions
test
Unboundedness
do
Test
test25FV47
test80BAU3B
test
ADLITTLE
test
AFIRO
test
AGG
test
AGG2
test
AGG3
test
BANDM
test
BEACONFD
test
BLEND
test
BNL1
test
BNL2
test
BOEING1
test
BOEING2
test
BORE3D
test
BRANDY
test
CAPRI
test
CRE
A
test
CRE
B
test
CRE
C
test
CRE
D
test
CYCLE
test
CZPROB
test
D2Q06C
test
D6CUBE
test
DEGEN2
test
DEGEN3
test
DFL001
test
E226
test
ETAMACRO
test
FFFFF800
test
FINNIS
test
FIT1D
test
FIT1P
test
FIT2D
test
FIT2P
test
FORPLAN
test
GANGES
test
GFRD
PNC
test
GREENBEA
test
GREENBEB
test
GROW15
test
GROW22
test
GROW7
test
ISRAEL
test
KB2
test
KEN
07
test
KEN
11
test
KEN
13
test
KEN
18
test
LOTFI
test
MAROS
test
MAROS
R7
test
MODSZK1
test
NESM
test
OSA
07
test
OSA
14
test
OSA
30
test
OSA
60
test
PDS
02
test
PDS
06
test
PDS
10
test
PDS
20
test
PEROLD
test
PILOT
test
PILOT
JA
test
PILOT
WE
test
PILOT4
test
PILOT87
test
PILOTNOV
test
QAP12
test
QAP15
test
QAP8
test
RECIPELP
test
SC105
test
SC205
test
SC50A
test
SC50B
test
SCAGR25
test
SCAGR7
test
SCFXM1
test
SCFXM2
test
SCFXM3
test
SCORPION
test
SCRS8
test
SCSD1
test
SCSD6
test
SCSD8
test
SCTAP1
test
SCTAP2
test
SCTAP3
test
SEBA
test
SHARE1B
test
SHARE2B
test
SHELL
test
SHIP04L
test
SHIP04S
test
SHIP08L
test
SHIP08S
test
SHIP12L
test
SHIP12S
test
SIERRA
test
STAIR
test
STANDATA
test
STANDGUB
test
STANDMPS
test
STOCFOR1
test
STOCFOR2
test
STOCFOR3
test
TRUSS
test
TUFF
test
VTP
BASE
test
WOOD1P
test
WOODW
build
Old
Knapsack
Test
Model
reset
test1Linear
Model
Case
test2Linear
Model
Case
test3Linear
Model
Case
test4Linear
Model
Case
test5Linear
Model
Case
test6Linear
Model
Case
test7Linear
Model
Case
test8Linear
Model
Case
test
Infeasible
Case
test
Max
Old
Knapsack
Test
Model
test
Min
Old
Knapsack
Test
Model
test
P20130409b
test
Unbounded
Case
test1
test2
setup
Model
solve
Linear
generate
Constraints
get
Factors
get
Rhs
get
Type
add
Expression
get
Constant
get
Objective
Function
options
get
Variables
maximise
minimise
get
State
get
Value
get
Point
compare
To
compare
To
equals
equals
equals
equals
equals
equals
equals
Including
Na
N
equals
Including
Na
N
equals
Including
Na
N
equals
Including
Na
N
equals
Including
Na
N
equals
Including
Na
N
representable
Delta
round
round
round
round
round
Unscaled
opposite
Relationship
to
String
optimize
test
Abort
After
Iteration
With
Large
Model
test
Degeneracy
test
Epsilon
test
Infeasible
Solution
test
Large
Model
test
Math272
test
Math286
test
Math288
test
Math290GEQ
test
Math290LEQ
test
Math293
test
Math434Negative
Variable
test
Math434Pivot
Row
Selection
test
Math434Pivot
Row
Selection2
test
Math434Unfeasible
Solution
test
Math713Negative
Variable
test
Minimization
test
Model
With
No
Artificial
Vars
test
Restrict
Variables
To
Non
Negative
test
Simplex
Solver
test
Single
Variable
And
Constraint
test
Solution
With
Negative
Decision
Variable
test
Trivial
Model
test
Unbounded
Solution
equation
From
String
assert
Equals
do
Test
Dual
Variants
do
Test
Dual
Variants
do
Test
One
Variant
do
Test
One
Variant
do
Test
Phased
Variants
do
Test
Phased
Variants
do
Test
Primal
Variants
do
Test
Primal
Variants
test
Dual
Carleton
Kcheung
Infeasible
test
Dual
Carleton
Kcheung
WE1
test
Dual
Carleton
Kcheung
WE2
test
Dual
Carleton
Kcheung
WE3
test
Dual
Illinois
Mlavrov
test
Dual
Israel
M340
test
Math434Negative
Variable
test
P20130409b
test
P20130409b
Mod1
test
P20130409b
Mod2
test
Primal
Brown
Csci2580
test
Primal
Carleton
Kcheung
test
Primal
Mitchell
Bounds
test
Primal
Wikipedia
test
Shiting
Range
test
Single
Variable
And
Constraint
test
Solution
With
Negative
Decision
Variable
assert
Primal
Dual
Pair
assert
Result
And
Full
Solution
compare
Primal
And
Dual
Solvers
do
After
Each
do
Before
Each
test
Case
CMU
test
Case
LIU
test
Case
MIT
test
Tiny
Duality
Example
From
Wikipedia
precision
Test
Double
Run
Infeasible
test
Git
Hub513
test
Math286
test
P20100412
test
P20111010
test
P20150127
test
P20180310
61
test
P20180310
62
test
P20180311
64
test
P20180311
66
test
P20180312
69
test
P20180314
70
do
Test
test
MP
Sadlittle
test
MP
Safiro
test
MP
Sempstest
test
MP
Smaros
test
MP
Smaros
Corrected
test
MP
Snazareth
test
MP
Stestprob
generate
Gomory
double
Value
set
size
generate
Gomory
Mixed
double
Value
set
size
test
Compare
Mixed
Integer
With
Standard
test
Explore
P20130409a
test
The
How
And
Why
Gomory
generate
Model
QP
main
build
Convex
build
Linear
setup
solve
Convex
solve
Linear
clear
Integrations
test
Very
Basic
Model
test
Test
test
Environment
test
Adding
Variable
To
Expression
test
Compensate
test
Expression
Set
Add
test
Fixed
Variables
test
Git
Hub
Issue2
test
Integer
Rounding
test
MP
Stestprob
test
Presolver
Case2
test
Simple
Infeasible
Simplification
test
Simply
Lower
And
Upper
Bounds
do
After
All
delete
do
Before
Each
test
Write
And
Read
Back32
test
Write
And
Read
Back64
do
Test
Write
And
Read
Back
do
Test
Feed
Forward
test
Derivatives
do
Test
Derivatives
get
Initial
Network
get
Test
Cases
precision
test
Softmax
Wikipedia
Case
do
Test
Feed
Forward
test
Training
get
Errors
get
Initial
Network
get
Test
Cases
precision
generate
test
Invoke
test
Train
Batch
Of
Equals
copy
make
Case00
make
Case01
make
Case10
make
Case11
get
Initial
Network
get
Test
Cases
precision
expected
input
target
test
Backpropagation
test
Feed
Forward
Primitive32
test
Feed
Forward
Primitive64
test
Feed
Forward
Raw
derive
The
Hard
Way
get
Initial
Network
get
Test
Cases
precision
do
Test
Feed
Forward
test
Training
get
Initial
Network
get
Test
Cases
precision
test
Step
By
Step
Backpropagation
Example
get
Initial
Network
get
Test
Cases
precision
get
Initial
Network
get
Test
Cases
precision
test
Sorting
Even
Sized
Array
Ascending
test
Sorting
Even
Sized
Array
Descending
test
Sorting
Odd
Sized
Array
Ascending
test
Sorting
Odd
Sized
Array
Descending
do
Sort
Test
main
do
Test
test
Random
Get
Set
test
Random
Get
Set
On
Mapped
File
main
arrays
Combined
arrays
Loop
arrays
Separated
elements
Combined
elements
Separated
setup
main
setup
naive
using
Hypot
double
Loop
invoke
BIS
invoke
BSI
invoke
ISB
invoke
SIB
main
bis
bsi
isb
raw1
raw2
setup
sib
test
Substitute
Backwards
test
Substitute
Forwards
minimise
All
Branch
Limits
main
plain
setup
unrolled02
unrolled04
unrolled08
unrolled16
capacity
set
Multiple
test
Huge
Sparse
test
Off
Heap
R032
test
Off
Heap
R064
test
Primitive
R032
test
Primitive
R064
test
Primitive
Z008
test
Primitive
Z016
test
Primitive
Z032
test
Primitive
Z064
test
Segmented
Primitive
test
Segmented
Sparse
test
Sparse
do
Test
test
Align
Capacity
test
Compare
With
Tree
Map
test
Submap
test
Compare
With
Array
List
test
Grow
Capacity
main
do
Test
setup
do
Test
test
Random
Set
And
Get
Back
Primitive64
test
Very
Large
Random
Set
And
Get
Back
Basic
test2To1D
test
Any
To1D
test
Any
To2D
test
Different
Paths
do
Test
test
Aggregate
Sum
Different
Ways
test
Index
Of
Largest
test
Random
Access
do
Test
do
Test
do
Test
do
Test
Random
Set
And
Get
Back
main
test
Matrices
test
Selecting
test
Slicing
test
Get
Indexint
Array
test
Get
Number
Of
Dimensions
test
Get
Number
Of
Elements
back
And
Forth
access2D
access
Any
D
test
Any
D53421
test
Is
Finitite
test
Aggregator
Maximum
Does
Not
Work
For
Negative
Numbers
test
Estimation
test
Evaluation
setup
L
test
Get
Gradient
test
Get
Hessian
test
Get
Linear
Factors
test
Invoke
test
First
Order
Approximation
test
Second
Order
Approximation
setup
test
Get
Gradient
test
Get
Hessian
test
Get
Linear
Factors
test
Invoke
test
Compare
Implementations
test
Compare
Logarithmic
Implementations
test
Gamma
Function
test
Int
Incomplete
Parts
test
Int
Incomplete
Steps
test
Logarithmic
test
Real
Incomplete
Specific
test
Special
Case
Limit
Zero
test
Special
Case
Value
One
test
Atan2
test
GCD
test
Magnitude
test
Max
test
Min
test
Min
Max
test
Power
compare
To
Gamma
Implementation
do
Test
Definition
do
Test
Implementation
perform
Test
test
Definition
test
Implementation
test
Compare
Implementations
test
Identities
test
Incomplete
Reduces
To
The
Usual
Beta
Function
test
Incomplete
Zero
Integral
test
Regularized
Reduces
To
The
Usual
Beta
Function
main
hypot
test
Math
test
My
Own
test
Strict
Math
test
Known
Values
test
Representation
Asin
X
test
Representation
Log
One
Plus
X
test
Special
Arguments111
test
Special
Arguments112
test
Special
Arguments121
test
Special
Arguments122
main
test
Math
test
Missing
Math
test
Adjust
Down
test
Adjust
Up
test
Is
Power
Of2
test
Power
Of
Int2
test
Power
Of
Long2
test
DIVIDE
test
MULTIPLY
test
POWER
test
ROOT
test
SQRT
test
SUBTRACT
assert
Binary
assert
Parameter
assert
Unary
test
ABS
test
ACOS
test
ACOSH
test
ADD
test
ASIN
test
ASINH
test
ATAN
test
ATAN2
test
ATANH
test
CARDINALITY
test
CBRT
test
CEIL
test
CONJUGATE
test
COS
test
COSH
test
DIVIDE
test
EXP
test
EXPM1
test
FLOOR
test
HYPOT
test
INVERT
test
LOG
test
LOG10
test
LOG1P
test
MAX
test
MIN
test
MULTIPLY
test
NEGATE
test
POW
test
POWER
test
RINT
test
ROOT
test
SCALE
test
SIGNUM
test
SIN
test
SINH
test
SQRT
test
SQRT1PX2
test
SUBTRACT
test
TAN
test
TANH
test
VALUE
compare
test
ACOSH
test
ASINH
test
ATANH
test
Compare
To
Zeros
test
HYPOT
test
POWER
test
Prefixes
test
Infinity
Sum
test
Negative
Infinity
test
Positive
Infinity
build
build
build
Mapped
mkdirs
new
Builder
new
Builder
output
serialize
Object
To
File
close
deserialize
serialize
new
IDX
deserialize
serialize
new
Scored
Dual
deserialize
serialize
new
Reader
new
Reader
new
Writer
new
Writer
encrypt
encrypt
make
Plain
Text
get
Instance
parse
parse
parse
parse
parse
parse
parse
parse
generate
Random
is
Alphabetic
is
Alphanumeric
is
Ascii
is
Control
is
Digit
is
Graph
is
Lowercase
is
Printable
is
Punctuation
is
Space
is
Uppercase
to
Lowercase
to
Printable
to
Uppercase
parse
parse
parse
parse
print
print
print
print
Pixel
clear
contains
Key
contains
Value
entry
Set
get
Key
get
Value
set
Value
equals
get
hash
Code
is
Empty
key
Set
parse
put
put
All
remove
size
to
String
values
get
Ordered
Keys
get
Values
equals
form
form
fragment
get
Form
Value
get
Query
Value
hash
Code
host
method
path
port
print
query
query
response
scheme
to
String
query
to
URL
configure
form
get
Session
new
Connection
get
Request
get
Status
Code
get
Stream
Reader
is
Response
OK
print
to
String
get
Input
Stream
equals
get
Parameter
Value
hash
Code
parameter
print
request
request
reset
get
Cookie
Manager
session
urldecode
urlencode
form
fragment
get
Stream
Reader
get
Input
Stream
host
method
path
port
query
scheme
to
String
request
response
body
equals
expect
Continue
form
form
fragment
get
Form
Value
get
Query
Value
hash
Code
header
host
method
method
path
port
print
query
query
secure
send
timeout
to
String
version
copy
body
get
Request
get
Session
get
URI
cancel
equals
get
Body
get
Headers
get
Previous
Response
get
Request
get
Status
Code
get
URI
hash
Code
is
Done
is
Response
OK
print
to
String
get
Response
get
Parameter
new
Request
new
Request
parameter
print
get
Client
get
Parameters
send
get
new
Request
new
Request
new
Session
post
post
authenticator
connect
Timeout
equals
executor
follow
Redirects
get
Session
hash
Code
priority
proxy
ssl
Context
ssl
Parameters
version
delimiter
get
strategy
double
Value
float
Value
get
get
get
int
Value
is
Line
OK
long
Value
to
Big
Decimal
index
make
make
make
make
get
index
get
index
get
index
make
make
parse
parse
parse
Line
append
append
append
append
append
append
append
append
append
delimit
write
format
of
of
of
of
close
new
CSV
Line
Builder
new
CSV
Line
Builder
with
Formatter
write
of
of
split
To
Shards
delete
directory
equals
files
files
With
Shard
Index
hash
Code
shard
shards
to
String
parse
is
Line
OK
of
of
of
of
close
read
with
Filtered
Parser
with
Filtered
Parser
with
Parser
build
copy
delete
deserialize
Object
From
File
input
input
new
Builder
new
Builder
new
Factory
new
Factory
close
parse
get
Char
Array
to
String
new
Reader
new
Reader
new
Writer
new
Writer
apply
deserialize
of
of
of
of
close
read
accept
serialize
of
of
of
of
close
write
executor
executor
manager
parallelism
parallelism
queue
statistics
get
Executor
get
Files
get
Parallelism
get
Queue
Capacity
get
Statistics
Collector
is
Statistics
Collector
as
Writer
clear
flush
flush
print
print
print
print
print
print
print
print
print
print
printf
println
new
Ring
Logger
append
append
append
char
At
clear
equals
flush
flush
hash
Code
index
Of
First
index
Of
Last
length
sub
Sequence
to
String
get
Cursor
as
Writer
close
flush
print
print
print
print
print
print
print
print
print
print
printf
println
println
write
clear
flush
flush
columns
printf
println
println
println
println
println
printmtrx
print
printmtrx
to
String
printmtrx
as
Writer
print
print
print
print
print
print
print
print
print
print
printf
println
debug
debug
debug
debug
debug
debug
debug
debug
debug
Columns
debug
Formatted
debug
Matrix
debug
Matrix
error
error
error
error
error
error
error
error
error
Columns
error
Formatted
error
Matrix
error
Matrix
as
Writer
columns
print
print
print
print
print
print
print
print
print
print
printf
println
println
println
println
println
printmtrx
printmtrx
get
Contents
As
Byte
Array
get
Contents
As
String
get
Name
name
type
get
Type
new
Input
Stream
new
Output
Stream
set
Name
set
Type
start
start
value
Of
value
Of
char
At
length
sub
Sequence
to
String
get
Array
start
parse
add
Potential
Parser
equals
hash
Code
to
String
get
Query
get
Query
Value
put
Query
Entry
remove
Query
Entry
set
Fragment
set
Host
set
Path
set
Port
set
Query
set
Scheme
to
URI
to
URL
throw
For
Illegal
Invocation
throw
For
Multiplication
Not
Possible
throw
For
Trying
To
Modify
An
Immutable
Object
throw
For
Unsupported
Optional
Operation
throw
If
Multiplication
Not
Possible
throw
If
Not
Equal
Column
Dimensions
throw
If
Not
Equal
Dimensions
throw
If
Not
Equal
Row
Dimensions
throw
If
Not
Square
throw
If
Null
throw
If
Null
throw
If
Null
throw
If
Null
throw
With
Message
to
String
calculate
Frobenius
Norm
calculate
Infinity
Norm
calculate
One
Norm
above
above
above
add
add
add
aggregate
Column
aggregate
Diagonal
aggregate
Range
aggregate
Row
below
below
below
bidiagonal
column
column
columns
columns
conjugate
copy
count
count
Columns
count
Rows
diagonal
diagonally
divide
divide
double
Value
double
Value
enforce
equals
flush
Cache
get
get
get
get
Condition
get
Determinant
get
Eigenpairs
get
Rank
get
Trace
hash
Code
hermitian
hessenberg
index
Of
Largest
invert
is
Hermitian
is
Small
is
Symmetric
left
left
left
limits
logical
multiply
multiply
multiply
negate
norm
offsets
on
All
on
Any
on
Columns
on
Matching
on
Matching
on
Rows
power
reduce
Columns
reduce
Rows
repeat
right
right
right
row
row
rows
rows
select
select
signum
solve
subtract
subtract
subtract
superimpose
supply
To
symmetric
to
Scalar
to
String
transpose
triangular
tridiagonal
get
Condition
Provider
get
Determinant
Provider
get
Eigenpairs
Provider
get
Inverse
Provider
get
Rank
Provider
get
Solution
Provider
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LDU
new
LU
new
QR
new
Singular
Value
new
Solver
Task
store
supplier
accept
add
add
add
add
count
count
Columns
count
Rows
double
Value
exchange
Columns
exchange
Rows
fill
All
fill
All
fill
Column
fill
Column
fill
Column
fill
Column
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Matching
fill
Matching
fill
Matching
fill
One
fill
One
fill
One
fill
One
fill
One
fill
One
fill
Range
fill
Range
fill
Row
fill
Row
fill
Row
fill
Row
fill
Row
fill
Row
get
get
modify
All
modify
Any
modify
Column
modify
Column
modify
Diagonal
modify
Diagonal
modify
Matching
modify
Matching
modify
Matching
In
Columns
modify
Matching
In
Columns
modify
Matching
In
Rows
modify
Matching
In
Rows
modify
One
modify
One
modify
Range
modify
Row
modify
Row
reset
set
set
set
set
supply
To
instantiate
count
double
Value
first
get
get
Worker
is
Zero
point
btran
count
Columns
count
Rows
ftran
identity
btran
btran
ftran
ftran
count
double
Value
first
get
get
Worker
is
Zero
point
double
Cosine
Value
double
Sine
Value
get
Cosine
get
Sine
invert
double
Cosine
Value
double
Sine
Value
get
Cosine
get
Sine
invert
make
Generic
make
Primitive
rotations
P
double
Cosine
Value
double
Sine
Value
get
Cosine
get
Sine
invert
to
String
transform
copy
copy
count
double
Value
first
get
to
String
copy
copy
count
double
Value
first
get
to
String
copy
copy
count
double
Value
first
get
to
String
first
transform
make
make
Column
make
Row
get
Worker
is
Zero
point
btran
calculate
Determinant
check
And
Decompose
count
Significant
decompose
get
Determinant
get
Inverse
get
L
get
Rank
Threshold
get
Solution
get
Solution
invert
invert
is
Full
Size
is
Solvable
is
SPD
preallocate
preallocate
reset
solve
solve
check
Solvability
compute
sort
calculate
Determinant
compute
Values
Only
decompose
get
Col
Dim
get
D
get
Eigenvalues
get
Max
Dim
get
Min
Dim
get
Row
Dim
get
V
reset
decompose
do
Decompose
make
D
make
Eigenvalues
make
V
set
D
set
Eigenvalues
set
V
hqr2
orthes
btran
calculate
Determinant
check
And
Decompose
count
Significant
decompose
get
Determinant
get
Inverse
get
Inverse
get
L
get
Rank
Threshold
get
Solution
get
Solution
invert
is
Solvable
is
SPD
preallocate
preallocate
solve
do
Decompose
do
Get
Inverse
do
Solve
check
Solvability
make
make
make
equals
get
Q
get
R
is
Ordered
reconstruct
btran
compute
Values
Only
count
Significant
decompose
get
Condition
get
Covariance
get
D
get
Frobenius
Norm
get
Inverse
get
Inverse
get
Ky
Fan
Norm
get
Operator
Norm
get
Rank
Threshold
get
Singular
Values
get
Singular
Values
get
Solution
get
Solution
get
Trace
Norm
get
U
get
V
invert
is
Full
Rank
is
Full
Size
is
Ordered
is
Solvable
preallocate
preallocate
reset
solve
check
Solvability
do
Decompose
do
Get
Inverse
hqr2
orthes
cdiv
make
make
Diagonal
get
Col
Dim
get
Row
Dim
allocate
check
Symmetry
collect
function
get
Internal
Data
get
Internal
Store
scalar
wrap
new
Raw
Store
reset
wrap
btran
calculate
Determinant
count
Significant
decompose
get
Determinant
get
Inverse
get
Q
get
R
get
Rank
Threshold
get
Solution
get
Solution
invert
invert
is
Full
Size
is
Solvable
preallocate
preallocate
reset
solve
solve
check
Solvability
get
L
btran
btran
calculate
Determinant
count
Significant
decompose
decompose
Without
Pivoting
ftran
get
Determinant
get
Inverse
get
Inverse
get
L
get
Pivot
Order
get
Rank
Threshold
get
Reverse
Pivot
Order
get
Solution
get
Solution
get
U
invert
is
Pivoted
is
Solvable
preallocate
preallocate
solve
do
Decompose
do
Get
Inverse
do
Solve
check
Solvability
make
Real
make
Real
make
Real
make
Real
make
Real
decompose
reset
supply
Diagonal
To
make
D
make
Q
make
Real
get
Determinant
get
Trace
is
Hermitian
is
Ordered
prepare
reconstruct
reset
do
Decompose
make
D
make
Eigenvalues
get
Eigenpair
make
V
recover
reduce
btran
calculate
Determinant
count
Significant
decompose
decompose
Without
Pivoting
ftran
get
Determinant
get
Inverse
get
L
get
Pivot
Order
get
Rank
Threshold
get
Reverse
Pivot
Order
get
Solution
get
Solution
get
U
invert
invert
is
Pivoted
is
Solvable
preallocate
preallocate
solve
solve
do
Decompose
check
Solvability
get
Reduced
Pivots
make
Real
make
Real
make
Real
make
Real
make
Real
decompose
get
D
get
LQ
get
RQ
is
Full
Size
is
Upper
reset
make
Diagonal
make
LQ
make
RQ
solve
solve2
do
Get
Diagonal
do
Get
LQ
do
Get
RQ
make
Real
equals
get
D
get
Q
reconstruct
do
Case1
do
Case2
do
Case3
do
Case4
to
Diagonal
count
Columns
count
Rows
btran
compute
Values
Only
count
Significant
decompose
get
Col
Dim
get
Condition
get
Covariance
get
D
get
Frobenius
Norm
get
Inverse
get
Inverse
get
Ky
Fan
Norm
get
Operator
Norm
get
Rank
Threshold
get
Row
Dim
get
Singular
Values
get
Solution
get
Solution
get
Trace
Norm
get
U
get
V
invert
invert
is
Full
Rank
is
Full
Size
is
Ordered
is
Solvable
preallocate
preallocate
reset
solve
solve
get
Inverse
Old
Version
check
Solvability
compute
compute
Bidiagonal
do
Compute
is
Transposed
make
D
make
Singular
Values
set
D
set
Singular
Values
is
Ordered
make
make
make
equals
get
D
get
LQ
get
RQ
is
Upper
reconstruct
get
Col
Dim
get
Inverse
get
Inverse
get
Row
Dim
get
In
Place
set
In
Place
equals
get
L
get
R
is
SPD
reconstruct
modified
make
equals
modified
get
D
get
L
get
R
reconstruct
get
D
get
Q
reset
get
Decomposition
Q
supply
Diagonal
To
make
D
make
Q
btran
calculate
Determinant
count
Significant
decompose
decompose
Without
Pivoting
get
D
get
Determinant
get
Inverse
get
L
get
Pivot
Order
get
Rank
Threshold
get
Reverse
Pivot
Order
get
Solution
get
Solution
invert
invert
is
Pivoted
is
Solvable
preallocate
preallocate
solve
solve
do
Decompose
check
Solvability
set
Threshold
change
reverse
Order
get
Order
is
Modified
reset
signum
check
And
Decompose
get
Determinant
get
Trace
is
Hermitian
is
Ordered
reset
do
Decompose
make
D
make
Eigenvalues
make
V
make
make
make
equals
get
Condition
get
Covariance
get
D
get
Frobenius
Norm
get
Ky
Fan
Norm
get
Operator
Norm
get
Singular
Values
get
Singular
Values
get
Trace
Norm
get
U
get
V
reconstruct
reconstruct
apply
Cholesky
apply
LDL
apply
LU
compute
In
Place
Schur
divide
And
Copy
Column
exchange
Columns
exchange
Hermitian
generate
Apply
And
Copy
Householder
Column
generate
Apply
And
Copy
Householder
Row
set
To
Identity
slice
Column
slice
Column
slice
Diagonal
slice
Range
slice
Row
slice
Row
transform
Symmetric
tred2
aggregator
allocate
collect
copy
function
make
Array
make
Diagonal
make
Eye
make
Householder
make
Identity
make
Rotation
make
Rotation
make
Zero
make
Zero
scalar
wrap
get
Eigenpair
tql2
btran
check
And
Decompose
get
Determinant
get
Eigenvalues
get
Inverse
get
Inverse
get
Solution
get
Solution
get
Trace
invert
invert
is
Hermitian
is
Ordered
is
Solvable
preallocate
preallocate
reset
solve
solve
check
Solvability
do
Decompose
make
D
make
Eigenvalues
make
V
compute
decompose
get
H
get
Q
is
Upper
reset
make
Q
do
Q
check
And
Decompose
get
Determinant
get
Inverse
get
Inverse
get
Trace
is
Hermitian
is
Ordered
check
Solvability
do
Decompose
make
D
make
Eigenvalues
make
Inverse
make
V
get
Determinant
to
Determinant
Provider
is
Full
Size
decompose
make
make
count
Columns
count
Rows
make
check
And
Decompose
is
Ordered
decompose
Without
Pivoting
get
Pivot
Order
get
Reverse
Pivot
Order
is
Pivoted
count
Significant
get
Rank
get
Rank
Threshold
is
Full
Rank
compute
ftran
ftran
get
Inverse
get
Inverse
get
Solution
get
Solution
invert
is
Solvable
solve
to
Inverse
Provider
to
Solution
Provider
compute
Values
Only
count
Columns
count
Rows
decompose
is
Computed
reconstruct
reset
compare
To
equals
hash
Code
make
make
count
Columns
count
Rows
make
make
make
Generalised
make
Generalised
compute
Values
Only
decompose
prepare
make
make
Generalised
make
make
make
Generalised
make
make
Generalised
make
make
Generalised
make
make
Generalised
equals
copy
Eigenvector
get
D
get
Eigenpair
get
Eigenpairs
get
Eigenvalues
get
Eigenvalues
get
Eigenvectors
get
Trace
get
V
is
Hermitian
is
Ordered
reconstruct
decompose
supply
Diagonal
To
make
D
make
Q
is
Hermitian
is
Ordered
do
Decompose
is
Hermitian
is
Ordered
do
Decompose
btran
get
Solution
is
Hermitian
is
Ordered
is
Solvable
preallocate
preallocate
do
Decompose
make
D
calculate
Determinant
compute
Values
Only
decompose
get
D
get
Determinant
get
Eigenvalues
get
Eigenvalues
get
Inverse
get
Inverse
get
Solution
get
Trace
get
V
invert
reset
solve
solve
check
Solvability
do
Decompose
make
D
do
General
do
Symmetric
get
Imaginary
Parts
get
Real
Parts
count
Columns
count
Rows
is
Computed
reset
allocate
check
Solvability
computed
function
get
Dimensional
Epsilon
is
Aspect
Ratio
Normal
scalar
is
Solvable
btran
calculate
Determinant
count
Significant
decompose
get
Determinant
get
Inverse
get
Inverse
get
Q
get
R
get
Rank
Threshold
get
Solution
get
Solution
invert
is
Full
Size
is
Solvable
preallocate
preallocate
reset
solve
solve
do
Decompose
do
Get
Inverse
do
Solve
check
Solvability
equals
compute
get
H
get
Q
is
Upper
reconstruct
rotate
Right
negate
Column
exchange
Columns
equals
get
L
get
U
reconstruct
invoke
invoke
invoke
new
Generic
new
Primitive32
new
Primitive64
base
add1x
N
add1x
N
add
Mx1
add
Mx1
add
Mx1
add
Mx
C
add
Mx
C
add
Mx
C
add
Mx
N
MT
add
Mx
N
MT
add
Mx
N
MT
divide
fill0x
N
fill1x1
fill1x
N
fill1x
N
fill1x
N
fill2x2
fill3x3
fill4x4
fill5x5
fill6x
N
fill7x
N
fill8x
N
fill9x
N
fill
Mx1
fill
Mx1
fill
Mx1
fill
Mx
N
fill
Mx
N
fill
Mx
N
fill
Mx
N
MT
fill
Mx
N
MT
fill
Mx
N
MT
fill
Rx
N
fill
Rx
N
fill
Rx
N
call
call
call
call
call
call
do
Column
do
Column
divide
invoke
invoke
invoke
invoke
new
Generic
new
Primitive32
new
Primitive64
base
divide
fill0x
N
P64
fill1x1
P64
fill1x
N
G
fill1x
N
P64
fill2x2
P64
fill3x3
P64
fill4x4
P64
fill5x5
P64
fill6x
N
P64
fill7x
N
P64
fill8x
N
P64
fill9x
N
P64
fill
Mx1
G
fill
Mx1
P64
fill
Mx
N
G
fill
Mx
N
MT
G
fill
Mx
N
MT
P64
fill
Mx
N
P64
fill
Rx
N
G
fill
Rx
N
P32
fill
Rx
N
P64
invoke
invoke
invoke
new
Generic
new
Primitive32
new
Primitive64
base
add1x
N
add1x
N
add
Mx1
add
Mx1
add
Mx1
add
Mx
C
add
Mx
C
add
Mx
C
add
Mx
N
MT
add
Mx
N
MT
add
Mx
N
MT
divide
fill0x
N
fill1x1
fill1x
N
fill1x
N
fill1x
N
fill2x2
fill3x3
fill4x4
fill5x5
fill6x
N
fill7x
N
fill8x
N
fill9x
N
fill
Mx1
fill
Mx1
fill
Mx1
fill
Mx
N
fill
Mx
N
fill
Mx
N
fill
Mx
N
MT
fill
Mx
N
MT
fill
Mx
N
MT
set
All
Operation
Thresholds
set
Thresholds
Max
Value
set
Thresholds
Min
Value
call
call
call
invoke
invoke
invoke
invoke2new
invoke2old
step1
step1
step2
step2
divide
invoke
invoke
invoke
new
Generic
new
Primitive32
new
Primitive64
base
add1x
N
add1x
N
add
Mx1
add
Mx1
add
Mx1
add
Mx
C
add
Mx
C
add
Mx
C
add
Mx
N
MT
add
Mx
N
MT
add
Mx
N
MT
divide
fill0x
N
fill1x1
fill1x
N
fill1x
N
fill1x
N
fill2x2
fill3x3
fill4x4
fill5x5
fill6x
N
fill7x
N
fill8x
N
fill9x
N
fill
Mx1
fill
Mx1
fill
Mx1
fill
Mx
N
fill
Mx
N
fill
Mx
N
fill
Mx
N
MT
fill
Mx
N
MT
fill
Mx
N
MT
instantiate
dense
sparse
instantiate
copy
get
Argument
get
Imaginary
get
Modulus
get
Real
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
make
count
Columns
count
Rows
count
Columns
count
Rows
make
make
solve
make
make
make
make
make
preallocate
count
Columns
count
Rows
count
Columns
count
Rows
preallocate
solve
solve
to
Solution
Provider
make
count
Columns
count
Rows
make
make
make
make
make
make
make
calculate
Determinant
to
Determinant
Provider
solve
solve
solve
solve
solve
solve
solve
solve
solve
solve
full1X1
full2X2
full3X3
full4X4
full5X5
least
Squares
symmetric2X2
symmetric3X3
symmetric4X4
symmetric5X5
preallocate
resolve
solve
direction
preconditioned
residual
vector
add
clear
get
RHS
remove
resolve
resolve
solve
double
Value
get
Delegate
set
Accuracy
Context
set
Debug
Printer
set
Iterations
Limit
get
Relaxation
Factor
set
Relaxation
Factor
resolve
solve
accuracy
debug
iterations
resolve
resolve
to
List
Of
Rows
configurator
preallocate
solve
debug
get
Accuracy
Context
get
Iterations
Limit
is
Debug
Printer
Set
set
Accuracy
Context
set
Debug
Printer
set
Iterations
Limit
divide
resolve
solve
resolve
solve
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
Determinant
calculate
calculate
calculate
calculate
invert
make
count
Columns
count
Rows
make
make
make
make
make
make
make
invert
invert
preallocate
count
Columns
count
Rows
preallocate
to
Inverse
Provider
invert
dim
invert
dim
invert
dim
invert
dim
invert
dim
invert
dim
invert
dim
invert
dim
invert
dim
full1X1
full2X2
full3X3
full4X4
full5X5
symmetric2X2
symmetric3X3
symmetric4X4
symmetric5X5
invert
preallocate
dim
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
equals
transpose
get
Condition
get
Determinant
get
Eigenpairs
is
Hermitian
invert
get
Rank
solve
is
Symmetric
get
Trace
get
Constructor
columns
columns
columns
columns
copy
function
make
make
Dense
make
Dense
make
Diagonal
make
Diagonal
make
Eye
make
Eye
make
Filled
make
Identity
make
Single
make
Sparse
make
Sparse
make
Wrapper
rows
rows
rows
rows
scalar
tensor1D
function
make
scalar
get
Math
Type
tensor2D
function
make
scalar
get
Math
Type
dense
get
Physical
Factory
instantiate
sparse
get
Math
Type
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
get
Argument
get
Imaginary
get
Modulus
get
Real
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
instantiate
dense
sparse
instantiate
copy
new
Cholesky
new
Determinant
Task
new
Eigenvalue
new
Instance
new
Inverter
Task
new
LDL
new
LU
new
QR
new
Singular
Value
new
Solver
Task
double
Value
get
supply
To
double
Value
get
multiply
multiply
multiply
multiply
multiply
Both
premultiply
aggregator
array
conjugate
function
make
Householder
make
Rotation
make
Rotation
scalar
get
subdiagonal
superdiagonal
dimension
builder
double
Value
first
In
Column
first
In
Row
get
get
Dimension
get
Main
Diagonal
get
Subdiagonal
get
Superdiagonal
limit
Of
Column
limit
Of
Row
supply
Main
Diagonal
To
supply
Subdiagonal
To
supply
Superdiagonal
To
supply
To
to
Scalar
double
Value
get
supply
To
count
Columns
count
Rows
elements
nonzeros
supply
To
get
Current
add
Column
add
Columns
columns
columns
count
Columns
count
Rows
double
Value
get
physical
supply
To
to
String
count
Columns
count
Rows
double
Value
get
get
get
Column
physical
remove
Column
select
Columns
set
set
supply
To
to
String
add
Column
count
Columns
count
Rows
elements
nonzeros
supply
To
get
Current
add
Row
add
Rows
count
Columns
count
Rows
double
Value
get
get
get
Row
physical
remove
Row
rows
rows
count
Columns
count
Rows
double
Value
get
physical
supply
To
to
String
select
Rows
set
set
supply
To
to
String
add
Row
supply
To
add
add
count
Columns
count
Rows
double
Value
equals
fill
Column
fill
Column
fill
Column
fill
One
fill
One
fill
One
get
hash
Code
modify
Column
modify
One
set
set
add
add
count
Columns
count
Rows
double
Value
equals
fill
One
fill
One
fill
One
get
hash
Code
modify
One
set
set
add
add
count
Columns
count
Rows
double
Value
equals
fill
All
fill
All
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
One
fill
One
fill
One
fill
Row
fill
Row
get
hash
Code
modify
All
modify
Column
modify
Diagonal
modify
One
modify
Row
set
set
add
add
count
Columns
count
Rows
double
Value
equals
fill
One
fill
One
fill
One
fill
Row
fill
Row
fill
Row
get
hash
Code
modify
One
modify
Row
set
set
add
add
count
Columns
count
Rows
double
Value
equals
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
One
fill
One
fill
One
fill
Row
fill
Row
get
hash
Code
modify
Column
modify
Diagonal
modify
One
modify
Row
region
By
Transposing
reset
set
set
fill
By
Multiplying
fill
Matching
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
to
String
supply
To
supply
To
supply
To
supply
To
supply
To
supply
To
supply
To
supply
To
supply
To
transpose
supply
To
count
Columns
count
Rows
to
String
get
Context
double
Value
first
In
Column
get
limit
Of
Row
to
Scalar
double
Value
first
In
Column
first
In
Row
get
limit
Of
Column
limit
Of
Row
multiply
multiply
multiply
multiply
multiply
Both
premultiply
supply
To
to
Scalar
double
Value
get
to
Scalar
double
Value
first
In
Row
get
limit
Of
Column
to
Scalar
add
conjugate
double
Value
double
Value
first
In
Column
first
In
Row
get
limit
Of
Column
limit
Of
Row
multiply
multiply
multiply
multiply
multiply
Both
premultiply
supply
To
to
Scalar
transpose
conjugate
double
Value
first
In
Column
first
In
Row
get
limit
Of
Column
limit
Of
Row
multiply
multiply
multiply
multiply
multiply
Both
premultiply
supply
To
to
Scalar
transpose
double
Value
first
In
Column
get
limit
Of
Row
to
Scalar
double
Value
get
double
Value
first
In
Row
get
limit
Of
Row
supply
To
to
Scalar
to
Base
Index
to
Base
Index
aggregate
Column
aggregate
Row
get
loop
Column
loop
Row
multiply
slice
Column
slice
Row
supply
To
to
Scalar
transpose
visit
Column
visit
Row
conjugate
double
Value
double
Value
get
multiply
multiply
multiply
multiply
multiply
Both
premultiply
supply
To
to
Scalar
transpose
equals
hash
Code
physical
one
zero
double
Value
get
first
In
Column
first
In
Row
limit
Of
Column
limit
Of
Row
conjugate
get
multiply
to
Scalar
double
Value
first
In
Column
first
In
Row
get
limit
Of
Column
limit
Of
Row
multiply
multiply
multiply
multiply
multiply
Both
premultiply
supply
To
to
Scalar
double
Value
get
limit
Of
Column
limit
Of
Row
aggregator
array
columns
columns
columns
columns
conjugate
conquer
copy
conquer
function
get
Math
Type
make
make
Householder
make
Rotation
make
Rotation
rows
rows
rows
rows
scalar
transpose
conquer
wrap
wrap
accept
add
add
apply
Cholesky
conquer
apply
LDL
conquer
apply
LU
conquer
as
List
compute
In
Place
Schur
conjugate
copy
count
Columns
count
Rows
divide
And
Copy
Column
double
Value
equals
exchange
Columns
exchange
Hermitian
exchange
Rows
fill
By
Multiplying
fill
Column
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Matching
conquer
conquer
fill
Matching
conquer
fill
Matching
conquer
fill
One
fill
One
fill
One
fill
Row
fill
Row
fill
Row
generate
Apply
And
Copy
Householder
Column
generate
Apply
And
Copy
Householder
Row
get
get
get
Col
Dim
get
Max
Dim
get
Min
Dim
get
Row
Dim
hash
Code
modify
All
conquer
modify
Column
modify
Diagonal
modify
One
modify
Row
multiply
multiply
Both
negate
Column
physical
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
rotate
Right
set
set
set
To
Identity
slice
Column
slice
Diagonal
slice
Range
slice
Row
substitute
Backwards
conquer
substitute
Forwards
conquer
to
Scalar
to
String
transform
Left
transform
Left
transform
Right
transform
Right
transform
Symmetric
transpose
tred2
visit
Column
visit
Diagonal
visit
Row
cast
cast
cast
get
Worker
Column
aggregator
array
builder
conjugate
function
make
Columns
Supplier
make
Dense
make
Diagonal
make
Eye
make
Eye
make
Filled
make
Householder
make
Identity
make
Rotation
make
Rotation
make
Rows
Supplier
make
Single
make
Single
make
Sparse
make
SPD
make
Wrapper
make
Zero
make
Zero
scalar
tensor1D
tensor2D
transpose
as
List
modify
Any
substitute
Backwards
substitute
Forwards
supply
To
transform
Left
transform
Left
transform
Right
transform
Right
index
Of
Largest
In
Column
index
Of
Largest
In
Row
index
Of
Largest
On
Diagonal
double
Value
get
to
Scalar
columns
columns
columns
columns
copy
conquer
get
Math
Type
make
rows
rows
rows
rows
transpose
conquer
get
Complex
Argument
get
Complex
Imaginary
get
Complex
Modulus
get
Complex
Real
wrap
wrap
cast
cast
cast
accept
add
add
apply
Cholesky
conquer
apply
LDL
conquer
apply
LU
conquer
as
List
caxpy
compute
In
Place
Schur
conjugate
copy
count
Columns
count
Rows
divide
And
Copy
Column
double
Value
equals
exchange
Columns
exchange
Hermitian
exchange
Rows
fill
By
Multiplying
fill
Column
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Matching
conquer
fill
Matching
conquer
fill
Matching
conquer
fill
One
fill
One
fill
One
fill
Row
fill
Row
fill
Row
generate
Apply
And
Copy
Householder
Column
generate
Apply
And
Copy
Householder
Row
get
get
get
Col
Dim
get
Max
Dim
get
Min
Dim
get
Row
Dim
hash
Code
modify
All
conquer
modify
Column
modify
Diagonal
modify
One
modify
Row
multiply
multiply
Both
negate
Column
physical
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
rotate
Right
set
set
set
To
Identity
slice
Column
slice
Diagonal
slice
Range
slice
Row
substitute
Backwards
conquer
substitute
Forwards
conquer
to
Scalar
to
String
transform
Left
transform
Left
transform
Right
transform
Right
transform
Symmetric
tred2
visit
Column
visit
Diagonal
visit
Row
get
Worker
Column
build
Column
build
Column
build
Column
build
Row
build
Row
build
Row
cast
count
Columns
count
Rows
equals
get
Col
Dim
get
Max
Dim
get
Min
Dim
get
Row
Dim
hash
Code
limit
Of
Column
limit
Of
Row
multiply
Both
to
String
is
Primitive
get
Component
Type
invoke
invoke
exchange
Columns
exchange
Rows
fill
By
Multiplying
modify
Any
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
array
columns
columns
columns
columns
copy
conquer
get
Math
Type
make
make
Householder
rows
rows
rows
rows
transpose
conquer
cast
cast
cast
accept
add
add
aggregate
Column
aggregate
Column
aggregate
Diagonal
aggregate
Diagonal
aggregate
Range
aggregate
Row
aggregate
Row
as
Collectable2D
as
List
byte
Value
columns
conjugate
count
Columns
count
Rows
dot
double
Value
elements
equals
exchange
Columns
exchange
Rows
fill
By
Multiplying
fill
Column
fill
Column
fill
Column
fill
Column
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Matching
fill
Matching
fill
One
fill
One
fill
One
fill
Row
fill
Row
fill
Row
fill
Row
fill
Row
fill
Row
float
Value
get
get
Col
Dim
get
Max
Dim
get
Min
Dim
get
Row
Dim
hash
Code
int
Value
is
Acceptable
is
Empty
is
Fat
is
Scalar
is
Square
is
Tall
is
Vector
long
Value
modify
All
modify
Any
modify
Column
modify
Column
modify
Diagonal
modify
Diagonal
modify
Matching
modify
Matching
modify
Matching
In
Columns
modify
Matching
In
Columns
modify
Matching
In
Rows
modify
Matching
In
Rows
modify
One
modify
Row
modify
Row
multiply
multiply
Both
physical
reduce
Columns
reduce
Rows
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
rows
set
set
short
Value
slice
Column
slice
Column
slice
Diagonal
slice
Diagonal
slice
Row
slice
Row
substitute
Backwards
conquer
substitute
Forwards
conquer
to
Raw
Copy1D
to
Raw
Copy2D
to
String
transform
Left
transform
Left
transform
Right
transform
Right
visit
Column
visit
Column
visit
Diagonal
visit
Diagonal
visit
One
visit
Row
visit
Row
get
Worker
Column
function
make
scalar
get
Math
Type
factory
make
Complex
make
Primitive
make
Primitive32
make
Quaternion
make
Rational
do
Generic
Column
AXPY
do
Primitive
Column
AXPY
make
Sparse
make
Sparse
multiply
add
add
double
Value
equals
fill
By
Multiplying
fill
One
fill
One
fill
One
first
In
Column
first
In
Row
get
hash
Code
index
Of
Largest
limit
Of
Column
limit
Of
Row
modify
All
modify
Matching
modify
Matching
modify
One
multiply
multiply
multiply
multiply
multiply
Both
nonzeros
premultiply
reduce
Columns
reduce
Rows
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
reset
set
set
supply
To
visit
Column
visit
Row
update
Non
Zeros
get
Elements
update
Non
Zeros
double
Value
first
In
Column
get
limit
Of
Column
supply
To
to
Scalar
to
Base
Index
to
Base
Index
above
above
above
add
add
add
aggregate
All
aggregate
Column
aggregate
Diagonal
aggregate
Range
aggregate
Row
below
below
below
bidiagonal
column
column
columns
columns
conjugate
copy
diagonal
diagonally
divide
divide
double
Value
equals
get
get
get
hermitian
hessenberg
index
Of
Largest
is
Hermitian
is
Normal
is
Small
is
Small
left
left
left
limits
logical
multiply
multiply
multiply
multiply
multiply
Both
negate
norm
offsets
on
All
operate
physical
power
premultiply
reduce
Columns
reduce
Rows
repeat
right
right
right
row
row
rows
rows
select
select
signum
slice
Column
count
double
Value
get
to
String
slice
Diagonal
count
double
Value
get
to
String
slice
Range
count
double
Value
get
to
String
slice
Row
count
double
Value
get
to
String
subtract
subtract
subtract
superimpose
superimpose
supply
To
symmetric
to
Scalar
transpose
triangular
tridiagonal
visit
One
double
Value
get
multiply
multiply
multiply
multiply
multiply
Both
premultiply
supply
To
to
Scalar
is
Covered
is
Covered
physical
execute
Multiply
execute
Multiply
execute
Multiply
execute
Multiply
execute
Multiply
Both
execute
Premultiply
base
one
zero
columns
columns
columns
columns
copy
get
Math
Type
make
rows
rows
rows
rows
transpose
wrap
wrap
convert
extract
multiply
cast
accept
add
add
aggregate
All
as
List
get
set
size
conjugate
copy
count
count
Columns
count
Rows
double
Value
equals
exchange
Columns
exchange
Rows
fill
All
fill
All
fill
By
Multiplying
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Matching
fill
Matching
fill
One
fill
One
fill
One
fill
Range
fill
Range
fill
Row
fill
Row
get
get
get
Col
Dim
get
Row
Dim
hash
Code
index
Of
Largest
is
Small
modify
All
modify
Column
modify
Diagonal
modify
Matching
modify
Matching
modify
One
modify
Range
modify
Row
multiply
multiply
Both
physical
region
By
Columns
region
By
Limits
region
By
Offsets
region
By
Rows
region
By
Transposing
reset
set
set
slice
Row
substitute
Backwards
substitute
Forwards
supply
To
to
Scalar
to
String
transform
Left
transform
Left
transform
Right
transform
Right
transpose
visit
All
visit
Column
visit
Diagonal
visit
Range
visit
Row
on
All
on
Any
on
Columns
on
Matching
on
Matching
on
Rows
transpose
double
Value
first
In
Column
first
In
Row
get
Original
limit
Of
Column
limit
Of
Row
double
Value
first
In
Row
get
limit
Of
Column
to
Scalar
correlations
double
Value
get
Expected
get
Standard
Deviation
get
Distribution
calculate
Density
get
Distribution
get
Expected
get
Quantile
get
Standard
Deviation
get
Variance
calculate
Density
of
get
Density
get
Distribution
get
Expected
get
Quantile
get
Variance
approximate
Quantile
calculate
Density
get
Probability
of
get
Density
get
Distribution
get
Expected
get
Quantile
get
Standard
Deviation
generate
test
add
add
All
add
All
elements
elements
get
Frequency
get
Maximum
Frequenecy
get
Mode
get
Relative
Frequency
increment
increment
All
merge
merge
number
Of
Known
Keys
population
Size
reset
retain
If
sample
get
get
Entry
With
Highest
Frequenecy
get
Map
calibrate
invoke
calibrate
invoke
mean
calibrate
invoke
add
Observation
calibrate
get
Distribution
get
Distribution
get
C11
get
C12
get
C21
get
C22
get
M1
get
M2
get
M2differenses
get
Observations
get
Regression
Coefficients
get
Expected
get
Lower
Confidence
Quantile
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
do
Step
get
Current
Value
get
Expected
get
Lower
Confidence
Quantile
get
Normalised
Random
Increment
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
set
Current
Value
step
estimate
ARCH
estimate
GARCH
of
get
Distribution
get
Value
set
Value
step
step
do
Step
get
Expected
get
Lower
Confidence
Quantile
get
Normalised
Random
Increment
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
estimate
make
make
make
convert
get
Distribution
get
Value
set
Value
step
get
Distribution
Location
get
Distribution
Variance
do
Step
get
Expected
get
Lower
Confidence
Quantile
get
Normalised
Random
Increment
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
get
Distribution
get
Value
set
Value
step
do
Step
get
Expected
get
Lower
Confidence
Quantile
get
Normalised
Random
Increment
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
calibrate
get
Distribution
get
Distribution
get
Value
set
Value
step
do
Step
get
Covariances
get
Expected
get
Lower
Confidence
Quantile
get
Normalised
Random
Increment
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
get
Distribution
get
Time
Between
Consecutive
Events
do
Step
get
Expected
get
Lower
Confidence
Quantile
get
Normalised
Random
Increment
get
Standard
Deviation
get
Upper
Confidence
Quantile
get
Variance
get
Value
set
Value
step
of
of
of
of
to
Array
get
Value
get
Values
set
Value
set
Values
size
step
add
Observation
simulate
get
Current
Value
get
Observations
set
Current
Value
set
Observations
count
Sample
Sets
count
Scenarios
get
Initial
Value
get
Sample
Set
get
Scenario
size
value
get
Distribution
simulate
simulate
get
Current
Value
set
Current
Value
of
get
Expected
get
Probability
get
Variance
generate
of
get
Expected
get
Probability
get
Variance
generate
estimate
make
get
Density
get
Distribution
get
Expected
get
Geometric
Mean
get
Geometric
Standard
Deviation
get
Quantile
get
Variance
set
Seed
generate
of
standard
get
Density
get
Distribution
get
Expected
get
Quantile
get
Standard
Deviation
get
Variance
get
Density
get
Distribution
get
Quantile
generate
get
Density
get
Distribution
get
Quantile
get
Density
get
Distribution
get
Density
get
Distribution
get
Quantile
get
Density
get
Distribution
get
Density
get
Distribution
get
Quantile
generate
of
of
Infinity
get
Density
get
Distribution
get
Expected
get
Quantile
get
Variance
approximate
Quantile
of
get
Expected
get
Probability
get
Variance
generate
get
Expected
get
Variance
generate
get
Density
get
Distribution
get
Lower
Confidence
Quantile
get
Quantile
get
Upper
Confidence
Quantile
compare
To
double
Value
float
Value
get
Standard
Deviation
get
Variance
int
Value
invoke
long
Value
new
Sample
Set
set
Random
set
Seed
to
String
check
Probabilty
generate
random
of
random
Integer
random
Integer
random
Integer
standard
get
Density
get
Distribution
get
Expected
get
Quantile
get
Variance
generate
get
Standard
Deviation
get
Variance
random
compare
To
get
Expected
get
Standard
Deviation
get
Variance
generate
get
Expected
get
Standard
Deviation
get
Variance
get
Expected
get
Standard
Deviation
get
Variance
of
standard
get
Density
get
Distribution
get
Expected
get
Quantile
get
Standard
Deviation
generate
get
Expected
get
Variance
generate
calculate
Variance
from
make
make
wrap
wrap
count
double
Value
get
get
Correlation
get
Covariance
get
First
get
Interquartile
Range
get
Largest
get
Last
get
Maximum
get
Mean
get
Median
get
Minimum
get
Quartile1
get
Quartile2
get
Quartile3
get
Smallest
get
Standard
Deviation
get
Standard
Score
get
Sum
Of
Squares
get
Values
get
Variance
reset
size
swap
swap
to
String
calculate
Quartiles
get
Samples
get
Sorted
Copy
get
Expected
get
Variance
generate
estimate
new
Instance
new
Instance
base
error
Weights
get
Mean
get
Variance
initialise
update
variance
Weights
average
decreasing
parameters
estimate
new
Instance
new
Instance
base
error
Weights
get
Mean
get
Variance
initialise
update
new
Instance
new
Instance
get
Mean
get
Variance
initialise
update
get
Mean
get
Standard
Deviation
get
Variance
initialise
update
variances
set
Seed
random
next
Double
next
Gaussian
size
generate
get
Date
get
Title
get
Vendor
get
Version
limit
Cores
To
limit
Environment
By
limit
Threads
To
limit
Units
To
main
push
Up
Concurrency
Thresholds
components
dimensions
is
Same
Shape
rank
of
copy
equals
function
hash
Code
make
scalar
sum
values
values
get
Math
Type
equals
function
hash
Code
scalar
get
Array
Factory
dimensions
equals
hash
Code
rank
signum
add
multiply
multiply
negate
new
Same
Shape
norm
equals
get
Math
Type
hash
Code
make
factory
add
byte
Value
byte
Value
conjugate
count
double
Value
double
Value
equals
float
Value
float
Value
get
hash
Code
int
Value
int
Value
long
Value
long
Value
multiply
multiply
negate
norm
set
set
set
set
set
set
set
set
set
set
set
set
set
short
Value
short
Value
to
String
get
Array
new
Same
Shape
equals
get
Math
Type
hash
Code
make
factory
add
byte
Value
conjugate
count
double
Value
equals
fill
Set
fill
Set
fill
Set
fill
Set
float
Value
get
hash
Code
int
Value
long
Value
multiply
multiply
negate
norm
set
set
set
set
set
set
set
shape
short
Value
to
String
get
Array
new
Same
Shape
of
copy
equals
function
hash
Code
identity
make
product
power2
kronecker
scalar
blocks
get
Math
Type
equals
get
Math
Type
hash
Code
make
factory
add
byte
Value
byte
Value
conjugate
count
count
Columns
count
Rows
double
Value
double
Value
equals
float
Value
float
Value
get
hash
Code
int
Value
int
Value
long
Value
long
Value
multiply
multiply
negate
norm
set
set
set
set
set
set
set
set
set
set
set
set
set
short
Value
short
Value
to
String
get
Array
new
Same
Shape
of
blocks
copy
copy
copy
equals
function
hash
Code
make
power
product
scalar
sum
get
Math
Type
dense
dense
dense
System
dense
System
of
sparse
sparse
sparse
sparse
sparse
System
sparse
System
sparse
System
sparse
System
wrap
add
add
adjust
compare
To
count
dot
double
Value
equals
get
get
Body
get
Pivot
get
RHS
hash
Code
initialise
modify
One
set
set
set
RHS
to
String
calculate
complete
get
get
Average
Step
Size
get
Primitive
Keys
get
Primitive
Time
Series
get
Resolution
head
Map
head
Map
next
Key
put
put
put
put
All
resample
resample
step
sub
Map
sub
Map
tail
Map
tail
Map
to
String
resample
complete
copy
get
get
get
All
Calendar
Dates
get
All
Series
Names
get
Earliest
First
Key
get
Earliest
Last
Key
get
Latest
First
Key
get
Latest
Last
Key
get
Resolution
get
Value
prune
prune
put
resample
to
String
do
Prune
And
Resample
complete
next
Key
step
build
build
reference
resolution
do
Build
coordinate
find
Earliest
First
Key
find
Earliest
Last
Key
find
Latest
First
Key
find
Latest
Last
Key
make
make
make
make
as
Primitive
colour
complete
double
Value
first
Value
get
get
get
Colour
get
Name
last
Value
name
put
put
put
All
resample
resample
set
Colour
set
Name
add
Series
get
Combination
access
Keys
access
Values
double
Value
get
resample
size
value
size
value
size
value
first
get
Average
Step
Size
get
Value
Series
keys
last
size
value
differences
get
Correlations
get
Covariances
get
Data
log
quotients
copy
wrap
add
add
copy
count
differences
differences
divide
divide
double
Value
exp
get
get
log
multiply
multiply
prune
quotients
quotients
running
Product
running
Sum
size
subtract
subtract
to
Data
Series
to
String
value
values
variances
size
value
size
value
size
value
add
add
copy
differences
differences
divide
divide
exp
first
get
Average
Step
Size
keys
last
log
multiply
multiply
quotients
quotients
resolution
running
Product
running
Sum
subtract
subtract
add
build
build
builder
from
from
get
First
Key
get
Last
Key
get
Samples
get
Samples
get
Series
size
to
String
copy
copy
wrap
modify
modify
modify
modify
size
value
visit
add
add
copy
differences
differences
divide
divide
exp
first
get
Average
Step
Size
key
keys
last
log
multiply
multiply
quotients
quotients
running
Product
running
Sum
subtract
subtract
ceiling
Entry
ceiling
Key
clear
colour
comparator
compute
compute
If
Absent
compute
If
Present
contains
Key
contains
Value
descending
Key
Set
descending
Map
entry
Set
equals
first
Entry
first
Key
floor
Entry
floor
Key
for
Each
get
get
get
Colour
get
Name
get
Or
Default
hash
Code
head
Map
head
Map
higher
Entry
higher
Key
is
Empty
key
Set
last
Entry
last
Key
lower
Entry
lower
Key
merge
name
navigable
Key
Set
poll
First
Entry
poll
Last
Entry
put
put
All
put
If
Absent
remove
remove
replace
replace
replace
All
set
Colour
set
Name
size
sub
Map
sub
Map
tail
Map
tail
Map
to
String
values
append
Last
Part
To
String
to
String
First
Part
to
Index
to
Key
to
Index
to
Key
as
Primitive
colour
comparator
complete
double
Value
entry
Set
iterator
has
Next
next
get
Key
get
Value
set
Value
size
first
Key
first
Value
get
get
get
Colour
get
Name
head
Map
last
Key
last
Value
mapper
name
next
Key
put
put
resample
set
Colour
set
Name
step
sub
Map
tail
Map
to
String
new
Delegate
Instance
get
Accumulator
invoke
get
All
Series
Names
get
Series
invoke
invoke
get
Last
Key
get
Resolution
copy
wrap
resample
equals
hash
Code
to
String
elements
count
Cores
count
Threads
count
Units
equals
get
Cache
Elements
get
Memory
Elements
hash
Code
is
Multi
Core
is
Multi
Thread
is
Multi
Unit
match
estimate
Size
Of
Wrapper
Class
memory
get
Information
Bits
get
Java
Class
make
Simple
make
Simple
compare
To
equals
hash
Code
is
L2Specified
is
L3Specified
to
String
virtualise
estimate
Array
estimate
Object
make
For
Class
Extending
Object
make
For
Subclass
make
add
add
estimate
add
align
get
Architecture
get
Memory
get
Threads
collect
Garbage
equals
get
Available
Dim1D
get
Available
Dim2D
get
Available
Memory
hash
Code
limit
By
to
String
conjugate
negate
invert
add
add
add
divide
divide
divide
multiply
multiply
multiply
subtract
subtract
subtract
is
Small
norm
signum
add
divide
multiply
power
subtract
get
Input
Stream
get
Resolution
get
Symbol
get
Input
Stream
get
Resolution
get
Symbol
new
Fetcher
get
Input
Stream
get
Reader
get
Resolution
get
Stream
Of
CSV
get
Symbol
add
add
add
Alpha
Vantage
add
IEX
Trading
add
Reader
add
Yahoo
get
resolution
coordinated
coordinated
new
Alpha
Vantage
new
Alpha
Vantage
new
File
Reader
new
File
Reader
new
IEX
Trading
new
Yahoo
equals
get
Calendar
Date
Series
get
Calendar
Date
Series
get
Calendar
Date
Series
get
Calendar
Date
Series
get
Historical
Data
get
Historical
Prices
get
Local
Date
Series
get
Local
Date
Series
get
Local
Date
Series
get
Local
Date
Series
get
Price
Series
get
Symbol
hash
Code
get
Local
Date
Series
parse
get
Historical
Data
get
Historical
Prices
get
Price
Series
get
Symbol
of
of
of
of
to
Symbol
get
Historical
Data
get
Historical
Prices
get
Input
Stream
get
Price
Series
get
Resolution
get
Symbol
get
Input
Stream
get
Resolution
get
Symbol
get
Price
of
of
of
of
of
of
compare
To
contains
Key
contains
Value
double
Value
equals
get
get
Key
get
Price
hash
Code
key
Set
to
String
equals
get
Price
hash
Code
test
Header
parse
run
get
register
clean
Up
update
equals
get
Price
hash
Code
test
Header
parse
equals
get
Price
hash
Code
test
Header
parse
get
Input
Stream
get
Resolution
get
Symbol
build
Challenge
Request
build
Consent
Request
build
Crumb
Request
build
Data
Request
scrape
Challenge
Response
scrape
Crumb
Response
new
Fetcher
get
Mean
Return
get
Volatility
get
Weights
get
Total
Weight
reset
calculate
Asset
Weights
reset
calculate
Portfolio
Return
calculate
Portfolio
Variance
get
Asset
Returns
get
Asset
Volatilities
get
Correlations
get
Covariances
size
calibrate
calibrate
calculate
Asset
Returns
calculate
Asset
Weights
get
Mean
Return
get
Return
Variance
get
Weights
reset
set
Mean
Return
set
Return
Variance
set
Scale
add
View
add
View
With
Balanced
Confidence
add
View
With
Scaled
Confidence
add
View
With
Standard
Deviation
get
Confidence
set
Confidence
calculate
Asset
Returns
calculate
Asset
Weights
get
Original
Returns
get
Original
Weights
get
View
Portfolios
get
View
Returns
get
Views
get
View
Variances
calculate
Variance
get
Mean
Return
get
Volatility
get
Weight
get
Weights
reset
calculate
Portfolio
Return
make
Symbols
calculate
Asset
Returns
calculate
Asset
Weights
calculate
Portfolio
Variance
calibrate
clean
copy
get
Asset
Key
get
Asset
Keys
get
Covariances
get
Risk
Aversion
set
Risk
Aversion
size
to
Correlations
calculate
Implied
Risk
Aversion
is
Default
Risk
Aversion
calculate
Portfolio
Return
calculate
Portfolio
Variance
get
Asset
Returns
get
Asset
Volatilities
get
Asset
Weights
get
Correlations
get
Covariances
get
Market
Equilibrium
get
Mean
Return
get
Return
Variance
get
Risk
Aversion
get
Symbols
get
Weights
set
Risk
Aversion
size
to
Simple
Assets
to
Simple
Portfolio
to
String
calculate
Asset
Returns
calculate
Asset
Returns
calculate
Asset
Weights
calculate
Asset
Weights
calculate
Portfolio
Return
calculate
Portfolio
Variance
calibrate
reset
is
Default
Risk
Aversion
calibrate
calibrate
calculate
Asset
Returns
calculate
Asset
Weights
calculate
Beta
calculate
Correlation
calculate
Covariance
add
Asset
Constraint
add
Component
Constraint
mix
debug
feasibility
get
State
time
validate
is
Shorting
Allowed
optimiser
set
Shorting
Allowed
calculate
Asset
Returns
handle
reset
get
Optimisation
Options
get
Variable
make
Model
calculate
Portfolio
Return
calculate
Portfolio
Variance
get
Asset
Returns
get
Asset
Volatilities
get
Correlations
get
Covariances
size
compare
To
forecast
get
Conformance
get
Loss
Probability
get
Loss
Probability
get
Mean
Return
get
Return
Variance
get
Sharpe
Ratio
get
Sharpe
Ratio
get
Value
At
Risk
get
Value
At
Risk95
get
Volatility
get
Weights
normalise
normalise
to
String
reset
simulate
simulate
simulate
to
Simple
Assets
to
Simple
Assets
calculate
Portfolio
Return
calculate
Portfolio
Variance
get
Asset
Returns
get
Asset
Volatilities
get
Correlation
get
Correlations
get
Covariance
get
Covariances
get
Mean
Return
get
Mean
Return
get
Return
Variance
get
Return
Variance
get
Simulator
get
Volatility
get
Weight
get
Weights
size
reset
get
Asset
Weights
add
Constraint
clear
All
Constraints
set
Lower
Limit
set
Target
Return
set
Target
Variance
set
Upper
Limit
to
String
generate
Optimisation
Model
calculate
Asset
Weights
reset
calculate
Portfolio
Return
calculate
Portfolio
Variance
calculate
Portfolio
Return
calculate
Portfolio
Variance
get
Asset
Returns
get
Asset
Volatilities
get
Correlations
get
Covariances
size
calculate
Value
At
Risk
estimate
Excess
Diffusion
Process
forecast
make
Calendar
Price
Series
make
Covariance
Matrix
make
Covariance
Matrix
make
Date
Price
Series
make
Excess
Growth
Rate
Sample
Set
make
Normalised
Excess
Price
to
Annual
Return
From
Growth
Factor
to
Annual
Return
From
Growth
Rate
to
Correlations
to
Correlations
to
Covariances
to
Growth
Factor
From
Annual
Return
to
Growth
Rate
From
Annual
Return
to
Volatilities
to
Volatilities
copy
Values
int
Value
set
copy
new
Colour
new
Colour
new
Grey
Scale
new
Grey
Scale
read
wrap
to
Ranged
byte
Value
convert
To
convert
To
Grey
Scale
count
Columns
count
Rows
double
Value
fill
Matching
float
Value
get
get
Col
Dim
get
Row
Dim
int
Value
physical
resample
set
set
set
set
set
slice
Alpha
Channel
slice
Blue
Channel
slice
Green
Channel
slice
Red
Channel
write
To
double
Value
get
ARGB
set
ARGB
correlations
covariances
covariances
covariances
covariances
covariances
covariances
new
Transformation2D
transform
from
add
Row
add
Rows
add
Row
With
Single
Unit
count
Columns
count
Rows
double
Value
get
is
Full
remaining
reset
supply
To
dispose
executor
fragmentation
new
Node
Builder
parallelism
parallelism
queue
build
distributor
executor
fragmentation
parallelism
parallelism
queue
get
Distributor
get
Fragmentation
get
Interpreter
get
Name
get
Parallelism
get
Processor
get
Queue
Capacity
get
Sharded
File
consume
get
Results
merge
reset
new
Builder
new
Instance
dispose
new
Writer
process
All
process
All
process
Mapped
reduce
Mapped
get
Reader
Factory
new
Reader
process
process
cast
cast
convert
convert
one
zero
is
Absolute
is
Infinite
is
Na
N
is
Small
of
parse
rational
value
Of
value
Of
value
Of
add
divide
from
Long
gcd
multiply
of
rational
subtract
to
String
add
add
compare
To
conjugate
divide
divide
double
Value
enforce
equals
float
Value
get
hash
Code
int
Value
invert
is
Absolute
is
Small
long
Value
multiply
multiply
negate
norm
power
signum
subtract
subtract
to
Big
Decimal
to
String
to
String
is
Infinite
is
Na
N
sign
size
to
Big
Decimal
get
Denominator
get
Numerator
cast
cast
convert
convert
descriptor
one
zero
value
Of
value
Of
divide
divide
multiply
descriptor
wrap
cast
cast
convert
convert
new
Array
Instance
one
zero
boolean
Value
byte
Value
double
Value
float
Value
int
Value
long
Value
short
Value
add
dimensions
divide
is
Absolute
multiply
rank
subtract
to
Big
Decimal
to
Plain
String
to
String
add
add
add
conjugate
divide
divide
divide
invert
multiply
multiply
multiply
negate
power
signum
subtract
subtract
subtract
cast
cast
convert
convert
one
zero
is
Absolute
is
Small
of
value
Of
value
Of
add
add
add
compare
To
conjugate
divide
divide
divide
double
Value
enforce
equals
float
Value
get
hash
Code
int
Value
invert
is
Absolute
is
Small
long
Value
multiply
multiply
multiply
negate
norm
power
signum
subtract
subtract
subtract
to
Big
Decimal
to
String
to
String
cast
cast
convert
convert
one
zero
is
Absolute
is
Infinite
is
Na
N
is
Small
parse
value
Of
value
Of
value
Of
add
divide
multiply
add
add
compare
To
conjugate
divide
divide
double
Value
enforce
equals
float
Value
get
hash
Code
int
Value
invert
is
Absolute
is
Small
long
Value
multiply
multiply
negate
norm
power
signum
subtract
subtract
to
Big
Decimal
to
String
to
String
sign
to
Big
Decimal
get
Base
get
Remainder
cast
cast
convert
convert
one
zero
is
Absolute
is
Infinite
is
Na
N
is
Small
of
value
Of
value
Of
add
add
add
compare
To
conjugate
divide
divide
divide
double
Value
enforce
equals
float
Value
get
hash
Code
int
Value
invert
is
Absolute
is
Small
long
Value
multiply
multiply
multiply
negate
norm
power
signum
subtract
subtract
subtract
to
Big
Decimal
to
String
to
String
cast
cast
convert
convert
descriptor
one
zero
is
Absolute
is
Infinite
is
Na
N
is
Small
value
Of
value
Of
descriptor
wrap
index
vector
cast
cast
convert
convert
one
zero
is
Absolute
is
Infinite
is
Na
N
is
Real
is
Small
make
Polar
make
Rotation
of
of
value
Of
value
Of
add
add
angle
compare
To
conjugate
count
count
Columns
count
Rows
divide
divide
double
Value
double
Value
double
Value
enforce
equals
float
Value
get
get
get
get
Determinant
get
Pure
Versor
get
Vector
Length
hash
Code
int
Value
invert
is
Absolute
is
Pure
is
Real
is
Small
long
Value
multiply
multiply
negate
norm
power
scalar
signum
subtract
subtract
supply
To
to
Big
Decimal
to
Complex
Matrix
to
Multiplication
Matrix
to
Multiplication
Vector
to
Rotation
Matrix
to
String
to
String
transform
unit
vector
versor
calculate
Sum
Of
Squares
All
calculate
Sum
Of
Squares
Vector
to
Rotation
Matrix
Versor
transform
Versor
add
context
denominator
divide
multiply
subtract
descriptor
extract
Unscaled
Value
add
add
compare
To
conjugate
divide
divide
double
Value
enforce
float
Value
get
int
Value
invert
is
Absolute
is
Small
long
Value
multiply
multiply
negate
norm
power
signum
subtract
subtract
to
Big
Decimal
to
String
to
String
to
Big
Decimal
descriptor
wrap
numerator
cast
cast
convert
convert
descriptor
one
zero
value
Of
value
Of
multiply
descriptor
wrap
cast
cast
convert
convert
one
zero
is
Absolute
is
Infinite
is
Na
N
is
Real
is
Small
make
Polar
make
Rotation
of
value
Of
value
Of
add
add
compare
To
conjugate
count
count
Columns
count
Rows
divide
divide
double
Value
double
Value
double
Value
enforce
equals
float
Value
get
get
get
get
Argument
get
Imaginary
get
Modulus
get
Real
hash
Code
int
Value
invert
is
Absolute
is
Real
is
Small
long
Value
multiply
multiply
negate
norm
phase
power
signum
subtract
subtract
supply
To
to
Big
Decimal
to
Multiplication
Matrix
to
Multiplication
Vector
to
Rotation
Matrix
to
String
to
String
transform
transform
When
Unit
cast
cast
convert
convert
descriptor
one
zero
value
Of
value
Of
multiply
descriptor
wrap
count
count
extract
extract
extract
fill
get
is
size
update
boolean
Value
byte
Value
double
Value
float
Value
int
Value
long
Value
short
Value
to
Boolean
to
Int
to
Int
to
Long
boolean
Value
byte
Value
double
Value
float
Value
int
Value
long
Value
short
Value
repetition
schedule
start
start
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
to
Index
to
Key
from
to
Index
to
Key
plain
to
Index
to
Key
plain
to
Index
to
Key
from
from
plain
plain
is
Primitive
common
get
Components
get
Java
Class
get
Java
Type
get
Number
Set
get
Total
Memory
is
Primitive
get
get
Key
get
Pair
get
Value
equals
first
get
Key
get
Value
hash
Code
left
right
second
of
of
of
of
of
of
of
of
of
of
of
of
of
of
first
get
Key
get
Value
left
right
second
wrap
wrap
wrap
wrap
wrap
wrap
wrap
byte
Value
count
double
Value
float
Value
get
int
Value
long
Value
set
set
set
short
Value
of
of
of
of
of
of
of
of
entry
Set
get
Key
get
Pair
get
Value
size
get
Key
get
Value
set
Value
count
get
add
add
add
byte
Value
double
Value
float
Value
get
get
Value
int
Value
long
Value
set
set
set
set
Value
short
Value
add
add
add
double
Value
get
get
Value
set
set
set
set
Value
add
add
add
double
Value
float
Value
get
get
Value
set
set
set
set
Value
add
add
add
double
Value
float
Value
get
get
Value
int
Value
long
Value
set
set
set
set
Value
add
add
add
double
Value
float
Value
get
get
Value
long
Value
set
set
set
set
Value
get
get
Value
set
Value
add
add
add
double
Value
float
Value
get
get
Value
int
Value
long
Value
set
set
set
set
Value
short
Value
set
has
Next
next
get
get
Key
get
Pair
get
Value
iterator
set
Value
size
spliterator
get
Value
right
second
values
byte
Value
compare
To
contains
Key
contains
Value
double
Value
equals
first
get
get
Key
hash
Code
int
Value
key
Set
left
long
Value
to
String
compare
To
contains
Key
contains
Value
double
Value
equals
first
get
get
Key
hash
Code
key
Set
left
to
String
compare
To
contains
Key
contains
Value
double
Value
equals
first
float
Value
get
get
Key
hash
Code
key
Set
left
to
String
compare
To
contains
Key
contains
Value
double
Value
equals
first
get
get
Key
hash
Code
int
Value
key
Set
left
long
Value
to
String
compare
To
contains
Key
contains
Value
double
Value
equals
first
get
get
Key
hash
Code
int
Value
key
Set
left
long
Value
to
String
contains
Key
contains
Value
equals
first
get
get
Key
get
Value
hash
Code
key
Set
left
right
second
to
String
values
compare
To
contains
Key
contains
Value
double
Value
equals
first
get
get
Key
hash
Code
int
Value
key
Set
left
long
Value
short
Value
to
String
of
of
of
of
of
of
of
of
of
of
of
of
of
of
as
Key
To
as
Key
To
as
Key
To
as
Key
To
as
Key
To
as
Key
To
as
Key
To
as
Value
To
clear
entry
Set
is
Empty
put
put
All
remove
set
Value
size
add
To
adjust
Into
adjust
Into
adjust
Into
between
convert
convert
convert
convert
count
get
get
Chrono
Unit
get
Duration
get
Label
get
Time
Unit
get
Units
is
Calendar
Unit
is
Date
Based
is
Duration
Estimated
is
Time
Based
new
Duration
to
Duration
In
Millis
to
Duration
In
Nanos
random
value
Of
get
Alpha
get
Blue
get
Green
get
Red
get
RGB
to
Hex
String
amount
date
decimal032
decimal064
integer
percent
string
whole
Percentage
get
Amount
get
Boolean
get
Date
get
Decimal032
get
Decimal064
get
Decimal128
get
Math032
get
Math064
get
Math128
get
Moment
get
Money
get
Parameter
get
Percent
get
Price
get
Quantity
get
String1
get
String3
get
String9
get
String
M
get
Text
get
Time
get
Timestamp
format
format
format
parse
format
parse
Object
get
Format
get
Format
get
Format
get
Format
format
parse
Object
number
Of
Digits
to
String
With
Fixed
Number
Of
Digits
to
String
new
Uniform
Formatter
to
Uniform
String
get
Format
get
Format
format
parse
Object
get
Format
get
Format
get
Format
get
Format
int
Value
enforce
configure
Format
handle
Format
Exception
handle
Parse
Exception
enforce
configure
Format
handle
Format
Exception
handle
Parse
Exception
of
of
enforce
format
parse
with
Adjuster
with
Formatter
enforce
configure
Format
handle
Format
Exception
handle
Parse
Exception
enforce
configure
Format
handle
Format
Exception
handle
Parse
Exception
enforce
to
Localized
Pattern
to
Pattern
compare
compare
get
Currency
get
Integer
get
Percent
get
Percent
of
of
of
Math
of
Precision
of
Scale
to
Format
is
Zero
enforce
enforce
enforce
epsilon
equals
format
format
get
Format
get
Function
get
Math
Context
get
Precision
get
Rounding
Mode
get
Scale
hash
Code
is
Different
is
Integer
is
Less
Than
is
Minimal
is
More
Than
is
Small
is
Small
is
Zero
is
Zero
to
Big
Decimal
to
Localized
Pattern
to
Pattern
to
String
with
Decremented
Precision
with
Decremented
Precision
with
Decremented
Scale
with
Decremented
Scale
with
Doubled
Precision
with
Doubled
Scale
with
Format
with
Halved
Precision
with
Halved
Scale
with
Incremented
Precision
with
Incremented
Precision
with
Incremented
Scale
with
Incremented
Scale
with
Math
with
Mode
without
Precision
without
Scale
with
Precision
with
Scale
scale
configure
Format
handle
Format
Exception
handle
Parse
Exception
to
Format
enforce
get
Part
get
Style
get
Unit
with
Format
configure
Format
handle
Format
Exception
handle
Parse
Exception
format
get
Format
parse
with
Format
configure
Format
handle
Format
Exception
handle
Parse
Exception
format
is
Configured
enforce
format
parse
of
of
of
of
of
of
append
append
append
append
append
append
append
clear
prepend
prepend
prepend
prepend
prepend
prepend
prepend
size
supply
To
supply
To
to
Doubles
to
Floats
copy
copy
copy
copy
copy
copy
copy
copy
supply
To
supply
To
new
Instance
new
Instance
wrap
add
add
add
All
add
All
clear
close
contains
contains
All
equals
for
Each
get
hash
Code
index
Of
is
Empty
iterator
last
Index
Of
list
Iterator
list
Iterator
parallel
Stream
remove
remove
remove
All
remove
If
replace
All
retain
All
set
size
sort
spliterator
stream
sub
List
to
Array
to
Array
new
Instance
new
Instance
wrap
clear
close
compute
compute
If
Absent
compute
If
Present
contains
Key
contains
Value
entry
Set
equals
for
Each
get
get
Or
Default
hash
Code
is
Empty
key
Set
merge
put
put
All
put
If
Absent
remove
remove
replace
replace
replace
All
size
values
run
flush
Cache
get
Cached
Object
is
Cache
Set
is
Dirty
make
Dirty
recreate
Cache
dispose
meassure
meassure
meassure
meassure
count
Millis
count
Nanos
is
Less
Than
is
Less
Than
Millis
is
Less
Than
Nanos
is
More
Than
is
More
Than
Millis
is
More
Than
Nanos
reset
reset
restart
restart
stop
stop
of
add
To
add
To
adjust
Into
compare
To
convert
To
double
Value
equals
float
Value
get
get
Units
hash
Code
int
Value
long
Value
subtract
From
to
Duration
In
Millis
to
Duration
In
Nanos
to
String
format
get
Hundred
Years
Ago
get
Thousand
Years
Ago
get
Thousand
Years
From
Now
to
Big
Decimal
to
Big
Decimal
to
Hex
String
is
Same
Date
is
Same
Time
add
To
adjust
Into
to
Duration
In
Millis
to
Duration
In
Nanos
to
Index
to
Key
adjust
Into
from
make
make
make
make
now
to
Calendar
to
Calendar
to
Calendar
to
Calendar
to
Date
to
Local
Date
to
Local
Date
to
Local
Date
Time
to
Local
Time
to
Offset
Date
Time
to
Offset
Date
Time
to
Offset
Date
Time
to
Zoned
Date
Time
value
Of
value
Of
value
Of
millis
adjust
Into
adjust
Into
adjust
Into
compare
To
equals
filter
get
Long
hash
Code
is
Supported
is
Supported
plus
step
step
step
to
Calendar
to
Calendar
to
Calendar
to
Calendar
to
Date
to
Instant
to
Local
Date
to
Local
Date
Time
to
Local
Time
to
Offset
Date
Time
to
String
to
Zoned
Date
Time
until
with
with
count
Excluded
count
Included
exclude
exclude
exclude
All
get
Excluded
get
Included
get
Last
Excluded
get
Last
Included
grow
include
include
include
All
is
Excluded
is
Included
is
Last
Excluded
is
Last
Included
pivot
revert
Last
Exclusion
revert
Last
Inclusion
shrink
shuffle
size
to
String
get
Empty
List
get
Empty
Map
get
Empty
Set
make
Single
Entry
List
make
Single
Entry
Map
make
Single
Entry
Set
to
Display
String
borrow
give
Back
new
Object
reset
decrement
duplicate
equals
halve
hash
Code
increment
to
String
allocate
Byte
Array
allocate
Double
Array
allocate
Float
Array
allocate
Int
Array
allocate
Long
Array
allocate
Short
Array
fill
Byte
Array
fill
Double
Array
fill
Float
Array
fill
Int
Array
fill
Long
Array
fill
Short
Array
get
Byte
get
Double
get
Float
get
Int
get
Long
get
Short
initialise
Byte
Array
initialise
Double
Array
initialise
Float
Array
initialise
Int
Array
initialise
Long
Array
initialise
Short
Array
set
Byte
set
Double
set
Float
set
Int
set
Long
set
Short
allocate
add
get
Rate
get
Total
increment
register
register
get
Rate
get
Total
close
read
empty
managed
managed
mapped
mapped
queued
sequenced
sequenced
close
drain
To
get
iterator
process
All
read
has
Next
next
run
close
drain
To
read
is
Done
close
write
consume
get
Results
merge
reset
consume
get
Results
merge
reset
consume
get
Results
merge
reset
apply
invoke
run
close
write
drain
To
is
More
To
Come
new
Batch
Container
close
read
managed
managed
mapped
queued
sharded
accept
close
write
write
Batch
close
write
write
write
close
read
next
Supplier
write
write
of
close
byte
Value
compare
To
double
Value
float
Value
int
Value
long
Value
short
Value
compare
To
double
Value
compare
To
double
Value
float
Value
compare
To
double
Value
float
Value
int
Value
long
Value
compare
To
double
Value
float
Value
long
Value
compare
To
double
Value
float
Value
int
Value
long
Value
short
Value
of
of
of
of
of
of
value
Of
value
Of
value
Of
value
Of
value
Of
value
Of
get
As
Int
call
call
new
Instance
compute
compute
compute
divider
get
Executor
map
map
map
process
process
process
process
Pair
process
Triplet
reduce
reduce
reduce
run
run
conquer
divide
divide
parallelism
threshold
call
invoke
conquer
adjust
Down
adjust
Up
average
decrement
divide
By
halve
increment
limit
limit
require
require
reserve
Bytes
reserve
Giga
Bytes
reserve
Kilo
Bytes
reserve
Mega
Bytes
reserve
Tera
Bytes
is
Empty
offer
poll
size
add
clear
remove
add
clear
is
Any
Contents
is
Empty
new
View
remove
size
invoke
invoke
invoke
new
Cached
Thread
Pool
new
Fixed
Thread
Pool
new
Scheduled
Thread
Pool
new
Single
Thread
Executor
new
Single
Thread
Scheduled
Executor
new
Thread
Factory
new
Thread
Factory
initialise
needs
Another
Iteration
perform
Iteration
count
Iteration
Constraints
get
Iteration
A
get
Iteration
B
get
Iteration
C
build
Result
get
Iteration
KKT
get
Iteration
RHS
initialise
count
Iteration
Constraints
get
Iteration
A
get
Iteration
B
get
Iteration
C
get
Iteration
L
get
Iteration
Q
get
Slack
E
get
Solution
L
get
Iteration
KKT
get
Iteration
RHS
needs
Another
Iteration
perform
Iteration
arity
get
Constant
get
Gradient
get
Hessian
get
Linear
Factors
invoke
linear
quadratic
set
Constant
new
Instance
count
Additional
Constraints
count
Constraints
count
Equality
Constraints
count
Inequality
Constraints
count
Model
Variables
count
Slack
Variables
count
Variables
get
AE
get
BE
get
BE
get
BI
get
Constraint
Map
get
Objective
get
Rows
AE
get
Rows
AI
get
Slack
index
Of
is
Negated
add
Objective
add
Objective
add
Objective
add
Objective
get
AE
get
AE
get
AI
get
AI
get
AI
get
BI
get
Constraints
Map
reset
set
AE
set
AE
set
AI
set
AI
set
BE
set
BE
set
BI
set
BI
set
Objective
set
Objective
set
Objective
set
Objective
builder
new
Solver
of
to
Objective
Function
dispose
get
Entity
Map
solve
to
String
build
Result
compute
General
count
Equality
Constraints
count
Inequality
Constraints
count
Variables
evaluate
Function
extract
Solution
get
Iteration
KKT
get
Iteration
RHS
get
Matrix
AE
get
Matrix
AE
get
Matrix
AE
get
Matrix
AI
get
Matrix
AI
get
Matrix
AI
get
Matrix
BE
get
Matrix
BI
get
Matrix
BI
get
Matrix
BI
get
Matrix
C
get
Matrix
Q
get
Rank
General
get
Solution
General
get
Solution
General
get
Solution
Q
get
Solution
Q
get
Solution
X
has
Equality
Constraints
has
Inequality
Constraints
initialise
is
Iterating
Possible
is
Solvable
General
is
Solvable
Q
needs
Another
Iteration
perform
Iteration
solve
Full
KKT
solve
LP
is
Patched
Q
is
Zero
Q
handle
Iteration
Solution
shrink
suggest
Using
Lagrange
Magnitude
suggest
Using
Vector
Projection
count
Excluded
count
Included
exclude
extract
Solution
get
Excluded
get
Excluded
get
Included
get
Included
get
Last
Excluded
get
Last
Included
include
initialise
is
Iterating
Possible
needs
Another
Iteration
suggest
Constraint
To
Exclude
suggest
Constraint
To
Include
to
Activator
String
check
Feasibility
count
Iteration
Constraints
get
Constraint
To
Include
get
Inv
QC
get
Iteration
A
get
Iteration
B
get
Iteration
C
get
Iteration
X
get
Slack
I
get
Slack
I
handle
Iteration
Results
reset
Activator
set
Constraint
To
Include
count
Columns
count
Rows
double
Value
get
physical
add
remove
new
Object
reset
exclude
perform
Iteration
add
Constraint
reset
Activator
do
Iteration
do
Solve
build
Result
new
Instance
solve
perform
Iteration
equalities
equality
get
Objective
inequalities
inequality
linear
linear
objective
objective
objective
objective
quadratic
to
Feasibility
Checker
to
Linear
Approximation
to
Linear
Approximation
append
do
Build
get
C
get
Convex
Data
get
Q
extended
Precision
is
Extended
Precision
iterative
iterative
new
Solver
General
new
Solver
SPD
small
Diagonal
small
Diagonal
solver
General
solver
SPD
build
is
Capable
to
Model
State
to
Solver
State
copy
copy
new
Builder
new
Builder
new
Builder
new
Entity
Map
new
Instance
new
Simple
count
get
Entry
is
Entity
Map
match
set
Entry
set
Entry
set
Multiplier
Scale
get
Multiplier
Scale
build
is
Capable
to
Model
State
to
Solver
State
get
Lower
Limit
get
Upper
Limit
is
Constraint
is
Equality
Constraint
is
Lower
Constraint
is
Upper
Constraint
build
extract
Solver
State
is
Capable
to
Model
State
to
Solver
State
dispose
maximise
minimise
validate
get
Contribution
Weight
is
Objective
abort
convex
convex
debug
get
Configurator
integer
integer
linear
linear
progress
set
Configurator
suffice
count
Additional
Constraints
count
Constraints
count
Equality
Constraints
count
Inequality
Constraints
count
Variables
of
of
parse
wrap
compare
To
count
double
Value
equals
get
get
Matched
Multipliers
get
Multipliers
get
Solution
get
State
get
Value
hash
Code
multipliers
multipliers
multipliers
size
to
String
with
Negated
Value
with
Solution
with
Solution
Length
with
State
with
Value
multipliers
multipliers
dispose
solve
solve
is
Approximate
is
Distinct
is
Failure
is
Feasible
is
Optimal
is
Success
is
Unexplored
is
Valid
abs
Value
count
Additional
Constraints
count
Constraints
count
Equality
Constraints
count
Inequality
Constraints
count
Variables
to
String
count
Model
Variables
count
Slack
Variables
get
Constraint
Map
get
Slack
index
Of
is
Negated
from
from
extract
Solver
State
to
Model
State
to
Solver
State
with
Capability
Predicate
with
Options
Modifier
get
Index
In
Solver
is
Switch
new
Validator
set
Switch
simplify
is
Applicable
of
of
of
of
do
Validate
validate
validate
compare
To
equals
hash
Code
get
Execution
Order
is
Applicable
simplify
is
Applicable
free
integer
negative
positive
get
Free
Variables
get
Integer
Variables
get
Negative
Variables
get
Positive
Variables
index
Of
Free
Variable
index
Of
Integer
Variable
index
Of
Negative
Variable
index
Of
Positive
Variable
reset
update
add
Integration
add
Presolver
clear
Integrations
clear
Presolvers
parse
parse
remove
Integration
remove
Presolver
reset
Presolvers
add
Expression
add
Expression
add
Special
Ordered
Set
add
Special
Ordered
Set
add
Variable
add
Variable
add
Variable
add
Variables
add
Variables
bounds
check
Similarity
constraints
copy
copy
copy
count
Expressions
count
Variables
describe
dispose
get
Expression
get
Expressions
get
Fixed
Variables
get
Free
Variables
get
Integer
Variables
get
Negative
Variables
get
Optimisation
Sense
get
Positive
Variables
get
Variable
get
Variable
get
Variables
get
Variable
Values
get
Variable
Values
index
Of
index
Of
Free
Variable
index
Of
Free
Variable
index
Of
Free
Variable
index
Of
Integer
Variable
index
Of
Integer
Variable
index
Of
Integer
Variable
index
Of
Negative
Variable
index
Of
Negative
Variable
index
Of
Negative
Variable
index
Of
Positive
Variable
index
Of
Positive
Variable
index
Of
Positive
Variable
is
Any
Constraint
Quadratic
is
Any
Expression
Quadratic
is
Any
Objective
Quadratic
is
Any
Variable
Fixed
is
Any
Variable
Integer
limit
Objective
maximise
minimise
new
Expression
new
Variable
objective
prepare
reduce
relax
relax
remove
Expression
set
Known
Solution
set
Known
Solution
simplify
snapshot
to
String
validate
validate
validate
validate
validate
validate
validate
validate
variables
write
To
write
To
optimise
scan
Entities
add
Objective
Constant
add
Reference
derive
Adjustment
Range
expressions
get
Integration
get
Known
Solution
get
Objective
Constant
get
References
get
Validation
Failure
Handler
is
Fixed
is
Infeasible
is
Integer
is
Integration
Switch
is
Referenced
is
Relaxed
is
Shallow
Copy
is
Unbounded
presolve
set
Infeasible
set
Integration
Switch
set
Optimisation
Sense
simplify
simplify
simplify
simplify
simplify
check
Feasibility
check
Similarity
reduce
do
Case0
do
Case1
do
Case2
do
Case
N
find
Common
Level
read
Expression
read
Linear
read
Model
Entity
read
Quadratic
read
Variable
write
Expression
write
Linear
write
Model
Entity
write
Quadratic
write
Variable
read
write
new
Object
reset
compare
To
equals
hash
Code
to
String
append
feasible
calculate
Tree
Size
copy
Lower
Bounds
copy
Upper
Bounds
create
Lower
Branch
create
Upper
Branch
dispose
enforce
Bounds
enforce
Bounds
equals
get
Lower
Bound
get
Minimum
Displacement
get
Upper
Bound
is
Sign
Changed
set
Node
State
build
is
Capable
to
String
abandoned
count
Evaluated
Nodes
count
Integer
Solutions
count
Skipped
Nodes
count
Total
Nodes
exhausted
failed
infeasible
integer
make
flush
solve
to
String
new
Printer
build
Result
evaluate
Function
extract
Solution
get
Best
Estimate
get
Best
Result
So
Far
is
Iteration
Necessary
log
Progress
mark
Integer
validate
compute
identify
Non
Integer
Variable
generate
Cuts
generate
Cuts
add
Significance
initialise
is
Cut
Rather
Than
Branch
is
Direct
mark
Infeasible
mark
Integer
to
Comparable
get
Gap
Tolerance
get
GMI
Cut
Configuration
get
Integrality
Tolerance
get
Worker
Priorities
new
Model
Strategy
to
String
count
Integer
Variables
get
Index
initialise
is
Cut
Rather
Than
Branch
is
Direct
is
Good
Enough
mark
Infeasible
mark
Integer
to
Comparable
build
is
Capable
solve
build
Result
evaluate
Function
extract
Solution
add
Priority
Definitions
get
Gap
Tolerance
get
GMI
Cut
Configuration
get
Integrality
Tolerance
get
Worker
Priorities
new
Model
Strategy
with
Gap
Tolerance
with
GMI
Cut
Configuration
with
Model
Strategy
Factory
with
Parallelism
with
Priority
Definitions
with
Fractionality
with
Violation
new
Configurable
get
Gap
Tolerance
get
GMI
Cut
Configuration
get
Integrality
Tolerance
get
Worker
Priorities
new
Model
Strategy
dispose
get
Variable
reset
solve
to
String
update
validate
validate
validate
get
Index
In
Solver
get
Model
get
Result
get
Solver
is
Solved
get
Integration
add
append
build
build
count
Additional
Constraints
count
Equality
Constraints
count
Inequality
Constraints
count
Variables
reset
solve
to
String
append
do
Build
do
Count
Variables
equalities
equality
get
AE
get
AE
get
AE
get
AI
get
AI
get
AI
get
BE
get
BE
get
BI
get
BI
get
C
get
Factory
get
Lower
Bounds
get
Objective
get
Objective
get
Rows
AE
get
Rows
AI
get
Upper
Bounds
inequalities
inequality
set
Number
Of
Variables
set
Objective
add
Constraint
add
Equalities
add
Inequalities
new
Equalities
new
Inequalities
set
Bounds
set
Equalities
set
Inequalities
validate
count
Iterations
count
Time
error
get
Class
Simple
Name
get
Duration
get
State
increment
Iterations
Count
is
Iteration
Allowed
is
Log
Debug
is
Log
Off
is
Log
Progress
log
log
log
log
log
Progress
reset
Iterations
Count
set
State
set
Validator
validate
validate
make
make
Binary
make
Integer
add
To
binary
compare
To
copy
get
Lower
Slack
get
Upper
Slack
get
Value
integer
integer
is
Binary
is
Integer
is
Negative
is
Positive
is
Value
Set
lower
quantify
Contribution
relax
set
Integer
set
Value
upper
assert
Fixed
Value
append
Middle
Part
clone
destroy
validate
derive
Adjustment
Exponent
do
Integer
Rounding
get
Index
is
Fixed
is
Unbounded
set
Fixed
set
Index
set
Unbounded
validate
double
Value
get
Col
Dim
get
Row
Dim
set
do
Pivot
scale
fix
Variable
get
Infeasibility
get
Value
new
Constraints
Body
double
Value
get
Col
Dim
get
Row
Dim
set
new
Constraints
RHS
double
Value
set
size
new
Objective
double
Value
set
size
pivot
to
Dense
double
Value
get
Col
Dim
get
Row
Dim
set
do
Pivot
scale
fix
Variable
get
Infeasibility
get
Value
new
Constraints
Body
double
Value
get
Col
Dim
get
Row
Dim
set
new
Constraints
RHS
double
Value
set
size
new
Objective
double
Value
set
size
pivot
to
Dense
double
Value
get
Col
Dim
get
Row
Dim
set
do
Pivot
scale
fix
Variable
get
Infeasibility
get
Value
new
Constraints
Body
double
Value
get
Col
Dim
get
Row
Dim
set
new
Constraints
RHS
double
Value
set
size
new
Objective
double
Value
set
size
pivot
to
Dense
copy
is
Sparse
make
make
new
Dense
new
Dense
new
Raw
new
Sparse
new
Sparse
count
Columns
count
Rows
get
set
constraints
Body
constraints
RHS
count
Remaining
Artificials
excluded
find
Next
Pivot
Column
fix
Variable
generate
Cut
Candidates
get
Infeasibility
get
Value
is
Able
To
Extract
Dual
is
Artificial
is
Excluded
is
Included
is
Remaining
Artificials
new
Constraints
Body
new
Constraints
RHS
new
Objective
objective
pivot
slice
Body
Column
double
Value
set
size
slice
Body
Row
double
Value
set
size
slice
Constraints
RHS
slice
Dual
Variables
double
Value
set
size
slice
Tableau
Column
double
Value
set
size
slice
Tableau
Row
double
Value
set
size
to
Dense
update
update
update
value
solve
new
Column
new
Matrix
new
Row
build
build
do
Excl
Transp
Mult
pivot
shift
Column
calculate
Dual
Direction
calculate
Iteration
calculate
Iteration
calculate
Primal
Direction
constraints
Body
constraints
RHS
copy
Basic
Solution
copy
Objective
extract
Value
generate
Cut
Candidates
get
Cost
get
Infeasibility
get
Reduced
Cost
get
Tableau
Element
get
Tableau
Element
get
Tableau
RHS
objective
reset
Basis
restore
Objective
slice
Dual
Variables
double
Value
set
size
solve
count
Columns
count
Rows
get
get
Col
Dim
get
Row
Dim
set
to
String
solve
do
Gomory
do
Gomory
Mixed
Integer
fraction
is
Fractional
Enough
pivot
Row
build
build
count
Columns
count
Rows
double
Value
get
get
Col
Dim
get
Row
Dim
set
set
new
Constraints
Body
double
Value
get
Col
Dim
get
Row
Dim
set
new
Constraints
RHS
double
Value
set
size
new
Objective
double
Value
set
size
pivot
pivot
shift
Column
calculate
Dual
Direction
calculate
Iteration
calculate
Iteration
calculate
Primal
Direction
constraints
Body
constraints
RHS
copy
Basic
Solution
copy
Objective
extract
Value
generate
Cut
Candidates
get
Basis
Column
Index
get
Cost
get
Infeasibility
get
Reduced
Cost
get
Tableau
Element
get
Tableau
Element
get
Tableau
RHS
objective
reset
Basis
restore
Objective
slice
Body
Row
double
Value
set
size
slice
Dual
Variables
double
Value
set
size
count
Additional
Constraints
count
Constraints
count
Equality
Constraints
count
Inequality
Constraints
count
Model
Variables
count
Slack
Variables
count
Variables
get
Constraint
Map
get
Slack
index
Of
is
Constraint
Negated
is
Negated
negated
set
Constraint
Map
set
Constraint
Map
set
Constraint
Negated
count
Variables
Totally
is
Any
Artificials
is
Artificial
Variable
is
Full
Set
Of
Artificials
is
Model
Variable
set
Objective
Adjustment
Factor
is
Phase1
is
Phase2
reset
return
To
Phase1
switch
To
Phase2
set
set
to
Convex
State
From
Dual
double
Value
set
size
double
Value
set
size
to
Convex
State
From
Primal
double
Value
set
size
build
build
Dual
build
Primal
do
Solve
Dual
do
Solve
Primal
size
Of
Dual
size
Of
Primal
fix
Variable
generate
Cut
Candidates
get
Entity
Map
solve
clean
Up
Phase1Artificials
get
Row
Objective
infeasibility
is
Tableau
Printable
log
Debug
Tableau
phase
value
build
Result
evaluate
Function
extract
Multipliers
count
double
Value
get
to
String
extract
Solution
initialise
needs
Another
Iteration
validate
find
Next
Pivot
Col
find
Next
Pivot
Row
perform
Iteration
new
Object
reset
btran
count
Columns
count
Rows
ftran
get
Column
btran
count
Columns
count
Rows
ftran
clear
Factors
new
Factor
reset
reset
update
update
key
new
Instance
build
build
build
build
new
Instance
to
String
basis
pivot
shift
Column
calculate
Dual
Direction
calculate
Iteration
calculate
Iteration
calculate
Primal
Direction
constraints
Body
constraints
RHS
copy
Basic
Solution
copy
Objective
extract
Solution
extract
Value
generate
Cut
Candidates
get
Column
State
get
Cost
get
Excluded
Lower
get
Excluded
Unbounded
get
Excluded
Upper
get
Infeasibility
get
Lower
Bound
get
Lower
Bounds
get
Lower
Gap
get
Range
get
Reduced
Cost
get
Tableau
Element
get
Tableau
Element
get
Tableau
RHS
get
Upper
Bound
get
Upper
Bounds
get
Upper
Gap
is
Negated
is
Printable
lower
new
Dual
Simplex
Solver
new
Phased
Simplex
Solver
new
Primal
Simplex
Solver
objective
reset
Basis
restore
Objective
slice
Dual
Variables
unbounded
update
Basis
upper
inequalities
inequality
to
Standard
Form
build
is
Capable
to
Model
State
to
Solver
State
get
Index
In
Solver
equalities
equality
get
Objective
lower
lower
objective
objective
objective
upper
upper
do
Build
get
Lower
Bounds
get
Upper
Bounds
new
Simplex
Store
new
Simplex
Tableau
build
is
Capable
to
Model
State
to
Solver
State
get
Index
In
Solver
to
Model
Variable
Values
build
build
is
Capable
to
Model
State
to
Solver
State
get
Index
In
Solver
new
General
Builder
new
General
Builder
new
Solver
new
Standard
Builder
new
Standard
Builder
solve
to
Objective
Function
of
double
Value
set
size
count
get
set
size
to
String
equals
hash
Code
to
String
column
reset
equals
hash
Code
to
String
column
reset
row
equals
hash
Code
to
String
is
Basis
Update
is
Bound
Switch
is
No
Operation
mark
As
Bound
Switch
reset
generate
Cut
Candidates
get
Entity
Map
get
Implied
Bound
Slack
extract
Multipliers
count
double
Value
get
to
String
extract
Solution
extract
Value
get
Dual
Exit
Candidate
get
Lower
Bound
get
Lower
Bounds
get
Primal
Enter
Candidate
get
Upper
Bound
get
Upper
Bounds
is
Negated
log
Current
State
shift
shift
Bounds
solve
Unconstrained
test
Dual
Enter
Ratio
test
Primal
Exit
Ratio
update
basis
do
Dual
Iterations
do
Primal
Iterations
extract
Result
initiate
Phase1
is
Dual
Feasible
is
Primal
Feasible
prepare
To
Iterate
switch
To
Phase2
simplify
derive
Adjustment
Exponent
is
Infeasible
to
Big
Decimal
add
To
adjust
equals
get
Adjusted
Lower
Limit
get
Adjusted
Upper
Limit
get
Adjustment
Factor
get
Contribution
Weight
get
Lower
Limit
get
Lower
Limit
get
Lower
Limit
get
Name
get
Unadjusted
Lower
Limit
get
Unadjusted
Upper
Limit
get
Upper
Limit
get
Upper
Limit
get
Upper
Limit
hash
Code
is
Constraint
is
Contribution
Weight
Set
is
Equality
Constraint
is
Integer
is
Lower
Constraint
is
Lower
Limit
Set
is
Objective
is
Upper
Constraint
is
Upper
Limit
Set
level
level
level
lower
lower
lower
reverse
Adjustment
shift
to
Adjusted
to
String
to
Unadjusted
upper
upper
upper
weight
weight
weight
get
Lower
get
Upper
append
Left
Part
append
Middle
Part
append
Right
Part
destroy
get
Adjustment
Exponent
validate
validate
append
To
String
derive
Adjustment
Exponent
do
Integer
Rounding
get
Adjustment
Exponent
Value
get
Compensated
Lower
Limit
get
Compensated
Lower
Limit
get
Compensated
Upper
Limit
get
Compensated
Upper
Limit
is
Closed
Range
is
Infeasible
bound
get
Variable
integer
is
Semicontinuous
set
Row
Value
test
get
Expression
get
Type
range
rhs
set
Column
Value
read
to
String
extract
Fields
get
Model
identify
Section
parse
Section
Line
name
Columns
name
Rows
build
is
Capable
solve
new
Integration
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
To
compare
To
compensate
double
Value
double
Value
enforce
evaluate
get
get
get
get
get
get
Adjusted
Gradient
get
Adjusted
Hessian
get
Adjusted
Linear
Factor
get
Adjusted
Linear
Factor
get
Adjusted
Linear
Factor
get
Adjusted
Quadratic
Factor
get
Adjusted
Quadratic
Factor
get
Adjusted
Quadratic
Factor
get
Linear
Entry
Set
get
Linear
Key
Set
get
Quadratic
Entry
Set
get
Quadratic
Key
Set
is
Any
Linear
Factor
Non
Zero
is
Any
Quadratic
Factor
Non
Zero
is
Function
Constant
is
Function
Linear
is
Function
Pure
Quadratic
is
Function
Quadratic
is
Integer
is
Linear
And
All
Binary
is
Linear
And
All
Integer
is
Linear
And
Any
Binary
is
Linear
And
Any
Integer
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
Compound
Factors
Offset
set
Linear
Factors
set
Linear
Factors
Simple
set
Quadratic
Factors
tighten
to
Function
convert
get
Constant
make
Affine
Function
make
Constant
Function
make
Pure
Quadratic
Function
make
Quadratic
Function
to
Positive
Fraction
append
Middle
Part
destroy
add
Objective
Constant
append
To
String
calculate
Set
Value
copy
count
Integer
Factors
count
Linear
Factors
count
Quadratic
Factors
derive
Adjustment
Exponent
do
Integer
Rounding
do
Integer
Rounding
do
Mixed
Integer
Rounding
get
Binary
Variables
get
Linear
get
Model
get
Quadratic
includes
is
Constant
Set
is
Infeasible
is
Negative
On
is
Positive
On
is
Redundant
resolve
set
Constant
set
Constant
set
Constant
set
Infeasible
set
Integer
set
Redundant
fix
Variable
generate
Cut
Candidates
get
Entity
Map
get
Implied
Bound
Slack
is
Mapped
update
Range
equals
hash
Code
to
String
adjust
count
Input
Nodes
count
Output
Nodes
get
Activator
get
Bias
get
Logical
Weights
get
Structure
get
Weight
invoke
invoke
randomise
scale
set
Activator
set
Bias
set
Weight
activate
activate
get
Derivative
In
Terms
Of
Output
is
Single
Folded
invoke
invoke
get
Derivative
builder
builder
builder
builder
from
from
from
from
from
from
do
Identity
do
Re
LU
do
Sigmoid
do
Soft
Max
do
Tanh
depth
equals
get
Activator
get
Bias
get
Weight
hash
Code
new
Invoker
new
Invoker
new
Trainer
new
Trainer
structure
to
String
width
write
To
write
To
write
To
adjust
count
Input
Nodes
count
Input
Nodes
count
Output
Nodes
count
Output
Nodes
get
Output
Activator
get
Weights
invoke
new
Batch
new
Store
randomise
scale
set
Activator
set
Bias
set
Configuration
set
Weight
equals
get
hash
Code
new
Input
Batch
set
Input
adjust
depth
get
Activator
get
Batch
Size
get
Bias
get
Input
get
Input
get
Output
get
Output
get
Output
Activator
get
Weight
get
Weights
invoke
new
Output
Batch
randomise
set
Activator
set
Bias
set
Weight
structure
activator
activators
activators
bias
dropouts
equals
error
hash
Code
lasso
new
Output
Batch
rate
ridge
structure
to
String
train
train
weight
error
invoke
read
write
read
write
read
write
equals
hash
Code
of
invoke
equals
hash
Code
do
L1
do
L2
probability
Did
Keep
Input
probability
Will
Keep
Output
regularisation
equals
get
hash
Code
layer
layer
get
Factory
get
Layers
new
Equation
System
Not
Solvable
new
Failed
To
Parse
String
new
Matrix
Not
Invertible
to
String
make
wrap
copy
copy
copy
copy
function
make
make
Filled
scalar
aggregator
get
Capacity
Limit
make
Segmented
make
Structured
Zero
make
To
Be
Filled
wrap
As
Segments
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
copy
copy
copy
copy
function
get
Math
Type
make
make
Dense
make
Filled
make
Sparse
scalar
tensor
wrap
compute
compute
factory
add
add
add
add
add
add
add
aggregate
Range
byte
Value
byte
Value
clear
contains
count
double
Value
double
Value
equals
fill
All
fill
All
fill
One
fill
One
fill
One
fill
Range
fill
Range
float
Value
float
Value
get
get
hash
Code
index
Of
index
Of
Largest
int
Value
int
Value
is
Empty
long
Value
long
Value
mix
mix
modify
All
modify
Any
modify
Matching
modify
Matching
modify
One
modify
Range
reset
set
set
set
set
set
set
set
set
set
set
set
set
set
set
short
Value
short
Value
size
slice
Range
sort
Ascending
sort
Descending
sub
List
supply
To
to
String
visit
All
visit
One
visit
Range
convert
exchange
get
Delegate
sort
Ascending
sort
Descending
equals
fill
Matching
fill
Matching
fill
Matching
hash
Code
reset
spliterator
copy
Of
Data
exchange
fill
fill
fill
One
fill
One
get
modify
modify
modify
modify
One
search
Ascending
set
set
set
visit
visit
One
modify
modify
modify
value
Of
value
Of
value
Of
make
factory
capacity
clear
comparator
contains
Key
contains
Key
contains
Value
contains
Value
count
double
Value
double
Value
entry
Set
iterator
has
Next
next
get
Key
get
Value
set
Value
size
first
Key
get
get
head
Map
head
Map
is
Empty
key
Set
iterator
size
last
Key
mix
mix
nonzeros
put
put
put
put
All
put
All
remove
remove
size
sub
Map
sub
Map
tail
Map
tail
Map
to
String
values
values
get
Storage
make
collector
factory
add
add
add
add
All
add
All
add
All
aggregate
Range
capacity
clear
contains
contains
All
count
double
Value
double
Value
get
get
index
Of
is
Empty
iterator
last
Index
Of
list
Iterator
list
Iterator
mix
mix
remove
remove
remove
All
retain
All
set
set
set
set
size
sub
List
to
Array
to
Array
to
String
visit
One
ensure
Capacity
set
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
reset
sort
Ascending
sort
Descending
add
add
add
byte
Value
double
Value
exchange
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
is
Absolute
is
Small
modify
modify
modify
modify
One
search
Ascending
set
set
set
set
visit
visit
One
modify
modify
modify
set
column
copy
Of
copy
Of
copy
Of
copy
Of
copy
Of
invoke
row
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
G
invoke
P64
plain
plain
unrolled02
unrolled04
unrolled04
unrolled08
unrolled16
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
add
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
divide
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
multiply
negate
negate
negate
negate
negate
negate
negate
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
subtract
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
fill
invoke
invoke
conjugate
conjugate
conjugate
copy
copy
copy
copy
fill
fill
fill
fill
fill
invoke
transpose
transpose
transpose
transpose
invoke
invoke
invoke
invoke
invoke
visit
visit
visit
All
visit
Column
visit
Diagonal
visit
Range
visit
Row
fill
All
fill
All
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Matching
fill
Matching
fill
Matching
fill
Range
fill
Range
fill
Row
fill
Row
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
exchange
exchange
exchange
exchange
exchange
exchange
exchange
exchange
invoke
conquer
conquer
invoke
conquer
conquer
tred2j
tred2nr
modify
All
modify
Column
modify
Diagonal
modify
Row
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
sort
sort
invoke
index
Of
index
Of
invoke
invoke
exchange
Columns
exchange
Rows
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
add
byte
Value
double
Value
byte
Value
double
Value
reset
set
set
set
set
set
axpy
sort
Ascending
sort
Descending
add
add
byte
Value
double
Value
fill
One
float
Value
index
Of
Largest
int
Value
is
Absolute
is
Small
long
Value
short
Value
set
get
Capacity
Limit
get
Element
Size
make
Dense
Array
make
Structured
Zero
make
To
Be
Filled
modify
modify
modify
make
wrap
wrap
make
wrap
columns
columns
columns
columns
copy
function
get
Math
Type
make
make
Dense
make
Filled
make
Sparse
rows
rows
rows
rows
scalar
tensor
factory
add
add
add
add
add
add
add
add
add
add
add
add
add
add
aggregate
Column
aggregate
Diagonal
aggregate
Range
aggregate
Row
byte
Value
byte
Value
byte
Value
byte
Value
count
count
Columns
count
Rows
double
Value
double
Value
double
Value
double
Value
equals
exchange
Columns
exchange
Rows
fill
All
fill
All
fill
Column
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
One
fill
One
fill
One
fill
One
fill
One
fill
One
fill
Range
fill
Range
fill
Row
fill
Row
fill
Row
flatten
float
Value
float
Value
float
Value
float
Value
get
get
hash
Code
index
Of
Largest
int
Value
int
Value
int
Value
int
Value
long
Value
long
Value
long
Value
long
Value
mix
mix
modify
All
modify
Any
modify
Column
modify
Diagonal
modify
Matching
modify
Matching
modify
One
modify
One
modify
Range
modify
Row
reduce
Columns
reduce
Rows
reset
reshape
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
short
Value
short
Value
short
Value
short
Value
slice
Column
slice
Column
slice
Diagonal
slice
Range
slice
Row
slice
Row
supply
To
to
String
visit
All
visit
Column
visit
Diagonal
visit
One
visit
One
visit
Range
visit
Row
get
Delegate
add
double
Value
float
Value
long
Value
double
Value
float
Value
long
Value
reset
set
set
set
set
set
aggregator
function
scalar
get
Capacity
Limit
get
Math
Type
make
Structured
Zero
make
To
Be
Filled
aggregate
Range
equals
get
Math
Type
hash
Code
index
Of
Largest
is
Primitive
modify
All
modify
Matching
modify
Matching
modify
Range
supply
To
to
String
visit
All
visit
Range
exchange
fill
fill
index
Of
Largest
modify
modify
modify
visit
wrap
In
Array1D
wrap
In
Array2D
wrap
In
Array
Any
D
factory
make
wrap
call
call
double
Value
estimate
Size
for
Each
Remaining
get
has
Next
has
Previous
index
iterator
modify
modify
modify
modify
next
next
Index
previous
previous
Index
try
Advance
try
Split
make
make
factory
add
add
add
axpy
count
count
Nonzeros
count
Zeros
dot
double
Value
double
Value
fill
All
fill
All
fill
One
fill
One
fill
One
fill
Range
fill
Range
first
In
Range
get
index
Of
Largest
limit
Of
Range
modify
All
modify
One
nonzeros
reset
set
set
set
supply
Non
Zeros
To
visit
One
visit
Primitive
Nonzeros
In
Range
visit
Range
visit
Reference
Type
Nonzeros
In
Range
update
update
exchange
fill
fill
index
Of
Largest
modify
modify
modify
visit
capacity
densify
double
Value
Internally
first
Index
get
Actual
Length
get
Internally
get
Values
get
Values
count
double
Value
double
Value
get
index
indices
last
Index
put
put
remove
set
add
double
Value
double
Value
float
Value
float
Value
reset
set
set
set
set
make
wrap
byte
Value
fill
One
float
Value
int
Value
long
Value
set
short
Value
set
add
supply
To
byte
Value
double
Value
fill
One
float
Value
int
Value
set
set
set
add
byte
Value
fill
One
float
Value
int
Value
set
short
Value
set
set
add
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
reset
sort
Ascending
sort
Descending
add
add
add
byte
Value
double
Value
exchange
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
int
Value
is
Absolute
is
Small
modify
modify
modify
modify
One
search
Ascending
set
set
set
short
Value
visit
visit
One
modify
modify
modify
set
set
add
add
add
add
add
add
add
byte
Value
count
double
Value
fill
All
fill
All
fill
One
fill
One
fill
One
fill
Range
fill
Range
float
Value
get
int
Value
long
Value
modify
One
set
set
set
set
set
set
set
short
Value
size
visit
One
is
Small
add
add
add
add
add
add
add
byte
Value
double
Value
exchange
exchange
fill
fill
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
index
Of
Largest
int
Value
is
Absolute
is
Small
long
Value
modify
modify
modify
modify
modify
modify
modify
One
search
Ascending
set
set
set
set
set
set
set
short
Value
sort
Ascending
sort
Descending
visit
visit
visit
One
add
double
Value
float
Value
double
Value
float
Value
int
Value
int
Value
reset
set
set
set
set
set
function
new
Mapped
scalar
aggregator
get
Capacity
Limit
make
Dense
Array
new
Instance
get
Math
Type
function
make
Filled
copy
copy
copy
copy
make
make
Segmented
make
make
make
Filled
scalar
aggregator
make
Dense
Array
get
Math
Type
new
Instance
make
make
make
make
wrap
close
reset
add
add
add
add
add
add
exchange
fill
fill
fill
One
fill
One
get
index
Of
Largest
is
Absolute
is
Small
modify
modify
modify
modify
One
search
Ascending
set
sort
Ascending
sort
Descending
visit
visit
One
modify
modify
modify
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
reset
sort
Ascending
sort
Descending
add
add
add
byte
Value
double
Value
exchange
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
int
Value
is
Absolute
is
Small
long
Value
modify
modify
modify
modify
One
search
Ascending
set
set
set
short
Value
visit
visit
One
modify
modify
modify
set
chunk
fixed
function
get
Math
Type
initial
limit
scalar
segment
get
Dense
Factory
get
Growth
Strategy
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
axpy
sort
Ascending
sort
Descending
add
add
byte
Value
double
Value
fill
One
float
Value
index
Of
Largest
int
Value
is
Absolute
is
Small
long
Value
short
Value
set
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
byte
Value
fill
One
float
Value
set
set
set
add
build
chunk
chunk
initial
initial
segment
segment
new
Builder
new
Instance
chunk
grow
grow
initial
is
Chunked
is
Segmented
make
Chunk
make
Initial
make
Segment
segment
add
double
Value
double
Value
float
Value
float
Value
reset
set
set
set
set
supply
To
byte
Value
double
Value
fill
One
float
Value
int
Value
long
Value
set
set
add
make
wrap
make
wrap
add
add
add
count
double
Value
double
Value
fill
All
fill
All
fill
One
fill
One
fill
One
fill
Range
fill
Range
get
modify
One
reset
set
set
set
visit
One
exchange
fill
fill
modify
modify
modify
visit
grow
set
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
reset
sort
Ascending
sort
Descending
add
add
add
byte
Value
double
Value
exchange
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
is
Absolute
is
Small
modify
modify
modify
modify
One
search
Ascending
set
set
set
set
short
Value
visit
visit
One
modify
modify
modify
set
copy
function
get
Math
Type
make
make
Dense
make
Filled
make
Sparse
scalar
tensor
factory
add
add
add
add
add
add
add
add
add
add
add
add
add
add
aggregate
Range
aggregate
Set
aggregate
Set
byte
Value
byte
Value
byte
Value
count
count
double
Value
double
Value
double
Value
equals
expand
fill
All
fill
All
fill
One
fill
One
fill
One
fill
One
fill
One
fill
Range
fill
Range
fill
Set
fill
Set
fill
Set
fill
Set
flatten
float
Value
float
Value
float
Value
get
get
hash
Code
index
Of
Largest
int
Value
int
Value
int
Value
long
Value
long
Value
long
Value
mix
mix
modify
All
modify
Any
modify
Matching
modify
Matching
modify
One
modify
One
modify
Range
modify
Set
modify
Set
rank
reduce
reduce
reset
reshape
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
shape
short
Value
short
Value
short
Value
slice
Range
slice
Set
squeeze
supply
To
to
String
visit
All
visit
One
visit
One
visit
Range
visit
Set
visit
Set
get
Delegate
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
byte
Value
fill
One
float
Value
set
short
Value
set
set
add
add
double
Value
float
Value
double
Value
float
Value
reset
set
set
set
set
short
Value
short
Value
set
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
axpy
dot
equals
fill
Matching
fill
Matching
fill
Matching
hash
Code
reset
sort
Ascending
sort
Descending
spliterator
stream
supply
To
add
add
byte
Value
copy
Of
Data
double
Value
exchange
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
int
Value
is
Absolute
is
Small
long
Value
modify
modify
modify
modify
One
search
Ascending
set
set
short
Value
visit
visit
One
modify
modify
modify
set
aggregator
function
make
Dense
Array
scalar
get
Capacity
Limit
get
Math
Type
make
Native32
make
Native64
add
add
add
add
add
add
count
fill
All
fill
One
fill
One
fill
One
get
modify
One
visit
One
exchange
modify
modify
modify
aggregator
function
scalar
get
Math
Type
make
Dense
Array
make
wrap
axpy
dot
equals
fill
Matching
fill
Matching
fill
Matching
hash
Code
reset
sort
Ascending
sort
Descending
supply
To
add
add
add
byte
Value
copy
Of
Data
double
Value
exchange
fill
fill
fill
One
fill
One
fill
One
float
Value
get
index
Of
Largest
int
Value
is
Absolute
is
Small
modify
modify
modify
modify
One
search
Ascending
set
set
set
short
Value
visit
visit
One
modify
modify
modify
set
column
columns
columns
columns
columns
copy
make
Filled
make
Filled
row
rows
rows
rows
rows
make
Dense
make
Dense
make
Sparse
make
Sparse
as
Factory1D
function
make
scalar
get
Math
Type
make
make
make
aggregate
All
aggregate
Range
index
Of
Largest
collect
supply
To
double
Value
estimate
Size
get
has
Next
has
Previous
index
iterator
next
previous
to
String
try
Split
count
double
Value
get
supply
To
to
String
slice
Range
visit
All
visit
One
visit
Range
as
Primitive1D
count
double
Value
get
to
String
equals
to
String
wrap
count
double
Value
get
to
String
wrap
count
double
Value
get
to
String
wrap
count
double
Value
get
to
String
as
Collectable1D
count
supply
To
as
Keyed1D
axpy
byte
Value
byte
Value
dot
double
Value
double
Value
elements
float
Value
float
Value
get
int
Value
int
Value
long
Value
long
Value
nonzeros
select
short
Value
short
Value
supply
To
to
Raw
Copy1D
on
All
on
All
on
All
on
All
on
All
on
All
on
Any
on
Matching
on
Matching
byte
Value
count
double
Value
float
Value
get
int
Value
long
Value
set
set
set
set
set
set
set
short
Value
function
get
Math
Type
scalar
get
add
has
Next
has
Previous
next
next
Index
previous
previous
Index
remove
set
on
All
on
All
on
All
on
All
on
All
on
All
on
Any
on
Matching
on
Matching
of
compare
To
equals
hash
Code
to
String
of
compare
To
equals
hash
Code
to
String
reduce
reduce
call
to
Index
to
Index
to
Key
to
Key
to
Key
expand
flatten
reshape
squeeze
count
count
count
count
index
index
loop
Matching
mapper
Of
reference
reference
shape
step
step
step
step
loop
loop
count
count
loop
loop
loop
loop
All
References
loop
References
rank
shape
size
column
row
byte
Value
count
double
Value
float
Value
get
int
Value
long
Value
set
set
set
set
set
set
set
short
Value
transform
exchange
Columns
exchange
Rows
fill
Column
fill
Column
fill
Column
fill
Column
fill
Column
fill
Column
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
Diagonal
fill
One
fill
One
fill
One
fill
One
fill
One
fill
One
fill
Row
fill
Row
fill
Row
fill
Row
fill
Row
fill
Row
mix
mix
mix
mix
add
add
add
add
add
add
add
add
add
add
add
add
add
add
modify
Column
modify
Column
modify
Diagonal
modify
Diagonal
modify
Matching
In
Columns
modify
Matching
In
Columns
modify
Matching
In
Rows
modify
Matching
In
Rows
modify
One
modify
One
modify
Row
modify
Row
modify
Any
accept
is
Acceptable
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
to
Index
to
Key
index
For
New
Key
call
next
previous
to
Index
to
Key
of
compare
To
equals
hash
Code
to
String
after
before
of
compare
To
equals
hash
Code
to
String
call
index
loop
Matching
loop
Range
mapper
new
Decreasing
Range
new
Decreasing
Range
new
Increasing
Range
new
Increasing
Range
replace
Null
Or
Empty
With
Full
to
Int
Indexes
to
Long
Indexes
count
loop
All
size
copy
make
Filled
make
Filled
make
Dense
make
Dense
make
Sparse
make
Sparse
as
Factory1D
function
make
scalar
get
Math
Type
make
make
make
column
compare
To
equals
hash
Code
row
to
String
above
above
above
below
below
below
bidiagonal
column
column
columns
columns
conjugate
diagonal
diagonally
hermitian
hessenberg
left
left
left
limits
offsets
repeat
right
right
right
row
row
rows
rows
superimpose
superimpose
symmetric
transpose
triangular
tridiagonal
column
compare
To
equals
hash
Code
row
to
String
reduce
Columns
reduce
Rows
flatten
reshape
call
of
equals
hash
Code
to
Column
Index
to
Column
Key
to
Index
to
Index
to
Key
to
Row
Index
to
Row
Key
column
column
column
column
column
count
first
In
Column
first
In
Column
first
In
Row
first
In
Row
index
limit
Of
Column
limit
Of
Column
limit
Of
Row
limit
Of
Row
loop
Matching
mapper
Of
row
row
row
row
row
count
count
Columns
count
Rows
first
In
Column
first
In
Row
get
Col
Dim
get
Max
Dim
get
Min
Dim
get
Row
Dim
is
Empty
is
Fat
is
Scalar
is
Square
is
Tall
is
Vector
limit
Of
Column
limit
Of
Row
loop
All
loop
Column
loop
Column
loop
Diagonal
loop
Row
loop
Row
aggregate
Column
aggregate
Column
aggregate
Diagonal
aggregate
Diagonal
aggregate
Row
aggregate
Row
reduce
Columns
reduce
Rows
collect
supply
To
characteristics
column
compare
To
count
double
Value
estimate
Size
for
Each
Remaining
get
go
To
Column
has
Next
has
Previous
iterator
next
previous
remove
stream
supply
To
to
String
try
Advance
try
Split
column
double
Value
estimate
Size
get
has
Next
has
Previous
index
iterator
next
next
Index
previous
previous
Index
row
to
String
try
Split
characteristics
compare
To
count
double
Value
estimate
Size
for
Each
Remaining
get
go
To
Row
has
Next
has
Previous
iterator
next
previous
remove
row
stream
supply
To
to
String
try
Advance
try
Split
count
Columns
count
Rows
double
Value
double
Value
get
supply
To
to
String
slice
Column
slice
Column
slice
Diagonal
slice
Diagonal
slice
Row
slice
Row
visit
Column
visit
Column
visit
Diagonal
visit
Diagonal
visit
One
visit
One
visit
Row
visit
Row
as
Primitive2D
count
count
Columns
count
Rows
double
Value
double
Value
get
to
String
equals
new
Primitive
Column
Collectable
count
Columns
count
Rows
supply
To
new
Primitive
Row
Collectable
count
Columns
count
Rows
supply
To
to
String
wrap
count
count
Columns
count
Rows
double
Value
double
Value
get
to
String
wrap
count
count
Columns
count
Rows
double
Value
double
Value
get
to
String
as
Collectable2D
count
Columns
count
Rows
supply
To
as
Keyed2D
byte
Value
byte
Value
byte
Value
byte
Value
columns
columns
columns
double
Value
double
Value
double
Value
double
Value
elements
float
Value
float
Value
float
Value
float
Value
get
get
int
Value
int
Value
int
Value
int
Value
long
Value
long
Value
long
Value
long
Value
nonzeros
rows
rows
rows
select
select
short
Value
short
Value
short
Value
short
Value
to
Raw
Copy2D
fill
One
fill
One
fill
One
fill
One
fill
One
fill
Set
fill
Set
fill
Set
fill
Set
mix
mix
mix
mix
add
add
add
add
add
add
add
add
add
add
add
add
add
add
modify
One
modify
Set
modify
Set
modify
Any
accept
is
Acceptable
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
set
fill
All
fill
All
fill
Matching
fill
Matching
fill
Matching
fill
One
fill
One
fill
One
fill
Range
fill
Range
mix
mix
add
add
add
add
add
add
add
modify
All
modify
Matching
modify
Matching
modify
One
modify
Range
modify
Any
accept
is
Acceptable
sort
Ascending
sort
Descending
copy
Complex
Argument
copy
Complex
Imaginary
copy
Complex
Modulus
copy
Complex
Modulus
And
Argument
copy
Complex
Real
copy
Complex
Real
And
Imaginary
reset
set
set
set
set
set
set
set
set
set
set
set
set
set
on
All
on
All
on
All
on
All
on
All
on
All
on
Any
on
Columns
on
Matching
on
Matching
on
Rows
transform
characteristics
compare
To
for
Each
Remaining
get
Comparator
has
Previous
index
iterator
next
Index
previous
previous
Index
remove
step
stream
try
Advance
try
Split
transform
copy
copy
copy
copy
make
Filled
make
Filled
make
Dense
make
Dense
make
Sparse
make
Sparse
make
make
make
aggregate
Set
aggregate
Set
reduce
collect
supply
To
double
Value
estimate
Size
get
has
Next
has
Previous
index
iterator
next
next
Index
previous
previous
Index
reference
to
String
try
Split
compare
To
count
count
Columns
count
Rows
double
Value
double
Value
estimate
Size
get
go
To
Matrix
has
Next
has
Previous
index
iterator
next
previous
remove
supply
To
to
String
get
Offset
count
double
Value
get
shape
supply
To
to
String
translate
translate
slice
Set
compare
To
count
double
Value
estimate
Size
get
go
To
Vector
has
Next
has
Previous
index
iterator
next
previous
remove
supply
To
to
String
get
Offset
visit
One
visit
Set
visit
Set
as
Primitive
Any
D
count
count
double
Value
double
Value
get
get
shape
equals
to
String
as
Collectable
Any
D
count
shape
supply
To
byte
Value
byte
Value
byte
Value
double
Value
double
Value
double
Value
elements
float
Value
float
Value
float
Value
get
get
int
Value
int
Value
int
Value
long
Value
long
Value
long
Value
matrices
select
short
Value
short
Value
short
Value
vectors
reference
get
Function
get
Parameter
invoke
invoke
invoke
and
Then
invoke
invoke
invoke
apply
compose
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
parameter
and
Then
double
Value
invoke
double
Value
get
get
As
Double
invoke
double
Value
invoke
invoke
to
Scalar
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
get
Set
average
cardinality
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
boolean
Value
byte
Value
double
Value
float
Value
get
int
Value
invoke
invoke
invoke
invoke
invoke
invoke
invoke
long
Value
reset
short
Value
to
Scalar
filter
reset
to
Scalar
average
cardinality
get
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
double
Value
invoke
invoke
to
Scalar
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
get
Set
average
cardinality
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
double
Value
invoke
invoke
to
Scalar
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
get
Set
average
cardinality
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
double
Value
invoke
invoke
to
Scalar
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
get
Set
average
cardinality
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
double
Value
invoke
invoke
to
Scalar
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
initial
Value
get
int
Value
invoke
reset
get
Set
average
cardinality
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
get
invoke
invoke
to
Scalar
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
initial
Value
double
Value
int
Value
invoke
reset
get
Set
average
cardinality
largest
maximum
minimum
norm1
norm2
product
product2
smallest
sum
sum2
get
Function
build
Derivative
build
Primitive
integrate
invoke
estimate
integrate
invoke
set
get
Derivative
Factor
get
Primitive
Factor
make
Instance
build
Derivative
build
Primitive
count
degree
double
Value
estimate
estimate
estimate
get
invoke
invoke
set
set
size
get
Derivative
Factor
get
Primitive
Factor
make
Instance
degree
estimate
estimate
estimate
set
set
set
estimate
integrate
invoke
set
get
Derivative
Factor
get
Primitive
Factor
make
Instance
estimate
integrate
invoke
set
get
Derivative
Factor
get
Primitive
Factor
make
Instance
estimate
integrate
invoke
set
get
Derivative
Factor
get
Primitive
Factor
make
Instance
estimate
integrate
invoke
set
get
Derivative
Factor
get
Primitive
Factor
make
Instance
estimate
integrate
invoke
set
get
Derivative
Factor
get
Primitive
Factor
make
Instance
get
Constant
set
Constant
linear
quadratic
get
Gradient
get
Hessian
get
Linear
Factors
get
Linear
Factors
to
First
Order
Approximation
to
Second
Order
Approximation
and
Then
arity
invoke
arity
invoke
equals
get
Linear
Factors
hash
Code
to
First
Order
Approximation
to
Second
Order
Approximation
shift
factory
coefficients
make
factory
make
Complex
make
Complex
make
Primitive
make
Primitive
make
Rational
make
Rational
wrap
arity
get
Constant
get
Gradient
get
Hessian
get
Linear
Factors
invoke
quadratic
set
Constant
factory
get
Scalar
Value
linear
make
quadratic
factory
make
Complex
make
Complex
make
Primitive
make
Primitive
make
Rational
make
Rational
wrap
arity
get
Constant
get
Gradient
get
Hessian
get
Linear
Factors
invoke
linear
quadratic
set
Constant
factory
get
Scalar
Value
coefficients
make
factory
make
Complex
make
Complex
make
Primitive
make
Primitive
make
Rational
make
Rational
wrap
arity
get
Gradient
get
Hessian
get
Linear
Factors
invoke
linear
factory
arity
equals
get
Gradient
get
Hessian
hash
Code
invoke
to
String
factory
constant
make
factory
make
Complex
make
Complex
make
Primitive
make
Primitive
make
Rational
make
Rational
arity
get
Constant
get
Gradient
get
Hessian
get
Linear
Factors
invoke
set
Constant
factory
get
Scalar
Constant
arity
equals
get
Gradient
get
Hessian
hash
Code
invoke
to
String
factory
coefficients
make
factory
make
Complex
make
Complex
make
Primitive
make
Primitive
make
Rational
make
Rational
wrap
arity
get
Constant
get
Gradient
get
Hessian
get
Linear
Factors
invoke
linear
set
Constant
factory
get
Scalar
Value
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
get
Set
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
divide
get
Modulo
Mask
modulo
divide
get
Modulo
Mask
modulo
adjust
Down
adjust
Up
exponent
find
find
get
Int
Power
get
Long
Power
is
Power
Of2
is
Power
Of2
largest
Not
Greater
Than
power
Of2Larger
power
Of2Larger
power
Of2Smaller
power
Of2Smaller
power
Of
Int2
power
Of
Long2
smallest
Not
Less
Than
partitions
permutations
subsets
variations
beta
beta
beta
beta
beta
beta
beta
beta
beta
pochhammer
erf
erfc
erfi
lower
lower
lower
upper
upper
upper
gamma
gamma
gamma
lower
lower
lower
upper
upper
upper
gamma
gamma
logarithmic
logarithmic
gamma
gamma
gamma
hypergeometric
acosh
asinh
atan2
atanh
divide
factorial
gcd
gcd
gcd
gcd
gcd
gcd
hypot
hypot
log10
logistic
logit
magnitude
max
max
max
max
max
max
max
max
max
max
max
max
min
min
min
min
min
min
min
min
min
min
min
min
norm
norm
norm
norm
pow
power
power
power
root
root
round
To
Int
scale
signum
sqrt1px2
tanh
to
Min
Int
Exact
to
Min
Int
Exact
to
Min
Int
Exact
to
Min
Int
Exact
factorial
Double
factorial
Int
factorial
Long
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
is
Zero
Modified
and
Then
invoke
invoke
invoke
apply
apply
As
Double
compose
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
get
Set
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
invoke
invoke
invoke
invoke
invoke
invoke
invoke
negate
invoke
invoke
invoke
test
test
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
get
Set
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
accept
accept
compose
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
double
Value
float
Value
get
Function
get
Number
invoke
invoke
invoke
double
Value
float
Value
get
Function
get
Number
invoke
invoke
invoke
and
Then
invoke
invoke
invoke
invoke
apply
apply
As
Double
by
by
first
first
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
second
second
invoke
invoke
invoke
invoke
invoke
invoke
get
Set
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
get
Prime
Number
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
get
Set
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
invoke
get
Set
abs
acos
acosh
add
aggregator
asin
asinh
atan
atan2
atanh
cardinality
cbrt
ceil
conjugate
cos
cosh
divide
enforce
exp
expm1
floor
hypot
invert
log
log10
log1p
logistic
logit
max
min
multiply
negate
pow
power
rint
root
scale
signum
sin
sinh
sqrt
sqrt1px2
subtract
tan
tanh
value
