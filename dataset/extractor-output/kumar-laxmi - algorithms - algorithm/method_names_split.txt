bwt
inverse
BWT
main
compress
decompress
main
get
First
get
Second
compare
To
huffman
assign
Codes
main
main
kadanes
Algo
Unsorted
Array
main
main
hash
insert
search
main
add
query
hash
element
To
Bytes
int
To
Bytes
float
To
Bytes
double
To
Bytes
long
To
Bytes
main
subset
Sum
partition
main
main
min
Jump
main
fibonacci
main
number
Of
Ways
main
SCS
Length
main
find
Hamiltonian
Cycle
main
min
Diff
main
matrix
Chain
Multiplication
main
knapsack
recursion
memoization
tabulation
space
Optimization
main
print
The
Result
homophonic
Substitution
main
convert
To
Morse
Code
main
main
generate
Large
Prime
generate
Generator
random
Big
Integer
is
Generator
generate
Private
Key
generate
Public
Key
encrypt
decrypt
add
Encrypted
Values
get
R
get
M
get
Size
main
key
Generation
encryption
decryption
modular
multiplicative
inverse
main
sha256
prepare
String
construct
Table
digraph
Plain
Text
get
Coordinates
encrypt
main
main
encrypt
decrypt
set
Permutation
Order
encrypt
Message
decrypt
Message
main
main
key
Generation
encryption
decryption
main
encryption
decryption
modulo
Function
multiplicative
Inverse
main
keyword
Generation
encryption
decryption
main
encryption
decryption
main
cipher
decipher
is
Coprime
mod
Inverse
main
fisher
Yates
Shuffle
main
main
Diagonal
Form
downwardbend
downdiagnol
upwardbend
upwarddiagnol
main
display
process
main
permutations
is
Valid
is
Unblocked
is
Destination
calculate
H
Value
trace
Path
a
Star
Search
compare
main
main
Beautiful
convert
main
main
best
Fit
Fixed
Memory
main
next
Fit
Fixed
Memory
main
objective
Function
evaluate
update
Velocity
update
Position
main
purpose
Function
random
Number
hill
Climbing
main
kmp
Algo
main
build
Matching
Machine
find
Next
State
search
Words
main
index
make
zarray
main
search
main
boyer
Moore
Horspool
main
is
Empty
push
pop
top
main
main
Max
Area
main
Rain
Water
main
max
Sum
main
equals
hash
Code
find
Side
line
Dist
quick
Hull
compute
Convex
Hull
main
digits
sum
Power
Oflen
main
compare
segment
Union
Length
main
exp
main
Lucas
Lehmer
main
manhattan
Distance
main
compare
To
on
Segment
orientation
do
Intersect
pred
succ
is
Intersect
main
main
modular
Exponentiation
find
Min
X
main
binet
formula
fib
iterative
fib
recursive
fib
main
copy
display
Relation
reflexive
Closure
symmetric
Closure
transitive
Closure
take
Input
main
can
Place
solve
Sudoku
main
Josephus
Problem
main
factorial
Num
main
value
roman
To
Int
main
main
decimal
To
Binary
binary
To
Decimal
fact
main
func
bisection
main
main
calculate
Loop
calculate
Recursive
do
Calc
factorial
matrix
Vector
Multiply
check
Product
read
Matrix
From
Input
main
main
main
main
main
main
main
mmi
main
Shri
Dharacharya
Formulae
main
factorial
main
reverse
main
main
sieve
Zellercongruence
main
main
main
gcd
lcm
main
factors
main
luhn
Algorithm
main
russian
Peasant
main
add
Page
display
Cache
main
insert
At
Tail
display
intersection
Node
main
reverse
LL
print
main
insert
At
Beginning
insert
At
Position
insert
At
End
print
List
main
delete
At
Beginning
delete
At
Position
delete
At
End
add
Two
Numbers
reverse
List
make
List
print
List
main
merge
split
List
merge
Sort
Top
Down
merge
Sort
Bottom
Up
split
get
List
Size
insert
Node
print
List
main
find
Length
main
insert
display
check
Palindrome
main
clear
size
is
Empty
add
add
First
add
Last
peek
First
peek
Last
remove
First
remove
Last
remove
remove
remove
At
index
Of
contains
as
String
main
compare
merge
Two
Lists
merge
K
Lists
Divide
Conquer
merge
K
Lists
Priority
Queue
merge
K
Lists
Iterative
print
List
main
insert
update
Node
delete
display
main
insert
reverse
print
main
new
Node
print
List
merge
main
main
to
Gray
Scale
apply
Gaussian
Filter
create
Gaussian
Kernel
apply
Sobel
Operator
perform
Non
Max
Suppression
apply
Double
Thresholding
get
Gradient
X
get
Gradient
Y
train
predict
calculate
Mean
calculate
Means
dot
Product
main
sigmoid
logistic
Regression
main
fit
predict

predict
euclidean
Distance
argsort
main
main
min
fib
Monaccian
Search
main
main
jump
Search
main
interpolation
Search
main
insert
At
End
display
List
is
Sublist
main
Rec
ternary
Search
Iter
ternary
Search
main
swap
partition
quick
Select
main
order
Agnostic
Binary
Search
ascending
binary
search
descending
binary
search
main
search
main
binary
Search
exponential
Search
main
main
binarytogray
graytobinary
main
calculate
Parity
Bits
is
Power
Of
Two
calculate
Parity
Value
hamming
Encode
main
set
Bits
main
insert
insert
search
search
main
insert
display
left
View
right
View
top
View
bottom
View
main
postorder
inorder
preorder
main
binary
Search
compare
find
Leaf
Node
find
Leaf
Node
find
Index
Of
Pointer
get
Midpoint
handle
Deficiency
is
Empty
linear
Null
Search
linear
Null
Search
shift
Down
sort
Dictionary
compare
split
Child
Pointers
split
Dictionary
split
Internal
Node
split
Keys
insert
search
search
append
Child
Pointer
find
Index
Of
Pointer
insert
Child
Pointer
is
Deficient
is
Lendable
is
Mergeable
is
Overfull
prepend
Child
Pointer
remove
Key
remove
Pointer
remove
Pointer
delete
insert
is
Deficient
is
Full
is
Lendable
is
Mergeable
compare
To
main
make
Node
add
remove
balance
balance
find
Next
left
Rotate
right
Rotate
pre
Order
display
main
height
max
right
Rotate
left
Rotate
get
Balance
Factor
insert
Node
node
With
Mimum
Value
delete
Node
pre
Order
print
Tree
main
Cost
Update
Cost
Shortest
Path
main
new
Node
is
Symmetric
is
Similar
take
Input
main
build
Segment
Tree
range
Query
update
Element
main
traverse
node
Set
binary
To
BST
convert
To
BST
gen
Tree
main
insert
remove
successor
predecessor
contains
main
next
query
main
parent
first
Child
move
Up
move
Down
swap
Positions
insert
contains
update
extract
Min
get
Value
is
Empty
main
insert
search
main
right
Rotate
left
Rotate
insert
delete
Node
inorder
Traversal
insert
delete
print
Inorder
main
search
search
insert
insert
delete
delete
splay
main
merge
Intervals
compare
main
print
Egyptian
main
minmoves
main
main
main
input
sort
job
sequencing
main
add
Edge
BFS
main
add
Edge
dfs
find
Bridges
main
shortest
Path
main
add
Edge
max
Matching
bfs
bfs
Visit
dfs
main
Prim
main
find
Hamiltonian
Cycle
solve
is
Present
display
main
min
dist
display
main
Stoer
Wagner
Algorithm
main
dijkstra
find
Min
Vertex
main
Add
Edge
shortest
Path
main
find
Parent
union
Sets
compare
kruskal
MST
main
root
connect
connected
Components
print
Answer
main
init
Graph
add
Edge
remove
Edge
print
Euler
Tour
print
Euler
Util
is
Valid
Next
Edge
dfs
Count
main
main
dfs
print
Cycle
main
min
bfs
ford
Fulkerson
main
bfs
edmonds
Karp
main
create
Graph
add
Edge
dinic
Bfs
dinic
Dfs
max
Flow
main
round
Robin
Algo
main
main
main
calc
Turn
Around
Time
calc
Waiting
Time
print
Result
main
compare
main
main
reading
input
printingvalues
bankers
Algo
resource
request
bingo
Sort
main
swap
partition
quick
Sort
prt
Arr
main
swap
cycle
Sort
main
min
Run
Length
insertion
Sort
merge
tim
Sort
main
sort
main
insert
Edge
DFS
main
merge
merge
Sort
main
find
Triplet
main
flip
find
Max
Index
pancake
Sort
main
main
DNF
main
Gnome
Sorting
shell
Sort
main
Sort
Printarr
main
wave
sort
main
get
Next
Gap
comb
Sort
main
data
Append
swap
max
Heap
heapify
heap
Sort
insertion
Sort
find
Pivot
partition
sort
Data
Util
sort
Data
print
Data
main
swap
stooge
Sort
print
Array
main
odd
Even
Sort
main
main
heapify
heap
Sort
main
main
Bucket
Sorting
display
bead
Sort
main
bidirectional
Selection
Sort
main
main
radix
Sort
counting
Sort
get
Max
main
partition
randomized
Partition
randomized
Quicksort
swap
main
main
pigeonhole
Sort
main
shuffle
is
Sorted
bogosort
main
calculate
Grundy
main
run
run
main
print
Solution
is
Safe
solve
NQ
Util
solve
NQ
main
main
karatsuba
add
matrix
subtract
matrix
print
matrix
matrix
multiplication
main
