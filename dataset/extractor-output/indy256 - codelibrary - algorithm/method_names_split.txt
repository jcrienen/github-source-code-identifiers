partition
swap
main
check
quick
Sort
main
q
Sort
merge
Sort
merge
Sort2
in
Place
Merge
Sort
in
Place
Merge
swap
rotate
binary
Search
First
True
heap
Sort
push
Down
bubble
Sort
selection
Sort
insertion
Sort
strange
Sort
counting
Sort
radix
Sort
main
nth
element
partition
swap
nth
element2
main
generate
Primes
generate
Primes
Linear
Time
is
Prime
number
Of
Prime
Divisors
generate
Min
Divisors
generate
Divisors
phi
generate
Phi
main
factorize
get
All
Divisors
pollard
gcd
g
ferma
main
apply
get
generate
Values
generate
Divisors
main
add
sub
mul
div
negate
inverse
abs
signum
double
Value
long
Value
compare
To
equals
hash
Code
to
String
main
gcd
gcd2
lcm
euclid
euclid2
mod
mod
mod
Inverse
mod
Inverse2
generate
Inverses
garner
Restore
simple
Restore
main
get
Divided
Differences
interpolate
main
f
gcd
plus
minus
mul
div
compare
To
to
String
main
subset
Convolution
subset
Convolution
Slow
main
pow
ntt
multiply
main
generate
Primitive
Roots
Of
Unity
convolution
transform
main
fft
multiply
Bigint
multiply
Mod
main
multiply
Bigint
karatsuba
Multiply
main
integrate
simpson
Integration
main
get
Shortest
Hamiltonian
Path
main
max
Palindrome
main
solve
Iterative
solve
Recursive
rec
main
lis
lower
bound
main
method1
method2
main
method0
get
Shortest
Hamiltonian
Cycle
main
get
Lis
main
mis
main
mis
Slow
min
Colors
dfs
main
color
Slow
sign
minus
cross
dot
rotate
CCW
compare
To
intersect
orientation
cw
ccw
is
Cross
Intersect
is
Cross
Or
Touch
Intersect
point
To
Line
Distance
fast
Hypot
angle
Between
angle
main
is
Cross
Intersect
is
Cross
Or
Touch
Intersect
get
Lines
Intersection
main
point
In
Polygon
main
find
Closest
Pair
rec
dist2
main
slow
Closest
Pair
segments
Union
Length
compare
To
main
overlap
compare
To
get
Lines
Intersection
get
Segments
Intersection
is
Cross
Intersect
convex
Cut
orientation
get
Lines
Intersection
main
fast
Hypot
contains
circle
Line
Intersection
circle
Line
Intersection2
intersection
circle
Circle
Intersection
circle
Circle
Intersection
Area
tangents
tangents
min
Enclosing
Circle
get
Circum
Circle
get
Circum
Circle
main
eq
update
update
union
Area
main
find
Closest
Pair
rec
dist2
main
slow
Closest
Pair
point
To
Segment
Distance
fast
Hypot
point
To
Line
Distance
main
get
Random
Polygon
reverse
len
is
Cross
Or
Touch
Intersect
paint
Component
run
main
conj
sub
add
mul
div
mul
len2
abs
norm
cross
cross2
dot
dot2
polar
exp
arg
rot90
rotate
rotate2
reflect
proj
angle
to
String
main
angle
Between
angle
Between2
double
Signed
Area
orientation
is
Middle
is
Middle
compare
To
to
String
rotate
CCW
perpendicular
main
convex
Hull
is
Not
Right
Turn
to
String
main
classify
find
Intersection
cross
is
Cross
Or
Touch
Intersect
main
has
Intersection
conj
sub
add
mul
div
mul
len2
len
norm
cross
dot
rot
proj
polar
exp
rotate
rotate2
reflect
to
String
main
polygon
Circle
Intersection
circle
Triangle
Intersection
angle
Between
circle
Line
Intersection
is
Middle
read
Token
skip
factor
term
expression
main
error
read
Ch
read
Next
Token
error
term
summa
test
expr
paren
Expr
statement
parse
compile
run
main
is
Delim
is
Operator
priority
process
Operator
eval
main
expr
term
prim
error
get
token
main
find
Cycle
dfs
main
color
main
add
Edge
bellman
Ford
min
Cost
Flow
main
add
Edge
max
Flow
main
max
Flow
augment
Path
main
main
get
Random
Permutation
add
Edge
dinic
Bfs
dinic
Dfs
max
Flow
min
Cut
clear
Flow
main
add
Edge
bellman
Ford
dijkstra
Sparse
dijkstra
Dense
min
Cost
Flow
main
min
Cost
Flow
add
Edge
main
max
Flow
find
Path
main
shortest
Paths
set
min
Index
main
shortest
Paths
main
bellman
Ford
find
Negative
Cycle
main
floyd
Warshall
restore
Path
main
shortest
Paths
main
shortest
Paths
main
clear
push
get
enqueue
dequeue
empty
clear
size
find
unite
maximum
matching
reset
count
clear
grow
contract
find
augmenting
path
adjust
dual
variables
do
edmonds
search
rematch
dfs
augment
find
maximal
initialize
main
min
Weight
Perfect
Matching
main
max
Matching
bfs
dfs
main
compare
To
size
empty
clear
min
argmin
get
val
pop
erase
has
update
decrease
key
push
pop
swap
node
down
heap
up
heap
clear
clear
all
empty
used
min
argmin
pop
push
erase
decrease
key
clear
rec
cut
merge
two
pass
pairing
get
enqueue
dequeue
empty
clear
size
next
v
next
b
prev
v
prev
b
compare
To
maximum
weighted
matching
compute
optimal
value
reduced
cost
rematch
fix
mate
and
base
reset
time
reset
blossom
reset
all
do
edmonds
search
fix
blossom
potential
update
heap2
activate
heap2
node
swap
blossom
swap
swap
set
surface
and
group
merge
smaller
blossoms
contract
link
blossom
push
outer
and
fix
potentials
grow
free
blossom
recalculate
minimum
slack
construct
smaller
components
move
to
largest
blossom
expand
augment
adjust
dual
variables
initialize
set
potential
find
maximal
matching
main
pow
rank
max
Matching
main
max
Matching
find
Path
mark
Path
lca
main
max
Matching
find
Path
main
e
delta
update
slack
set
slack
q
push
set
st
get
pr
set
match
rotate
reverse
swap
augment
get
lca
add
blossom
expand
blossom
on
found
edge
matching
solve
add
edge
init
main
max
Matching
find
Path
main
dfs
main
to
String
biconnectivity
dfs
ebc
Tree
main
scc
dfs
scc
Graph
main
dfs
topological
Sort
main
euler
Cycle
Undirected
dfs
euler
Cycle
Undirected2
euler
Cycle
Directed
dfs
euler
Cycle
Directed2
main
dfs
build
Tree
lca
min
Pos
main
dfs1
dfs2
enter
Into
Strip
lca
main
dfs
is
Parent
lca
main
find
Tree
Centers
find
Tree
Centroid
diameter
dfs
main
min
Length
Steiner
Tree
mst
main
mst
Prim
main
main
lis
Size
lis
Size2
lower
bound
check
Lis
point
In
Polygon2
point
In
Polygon3
main
get
Random
Polygon
reverse
len
is
Cross
Or
Touch
Intersect
is
Cross
Intersect
convex
Hull2
cross
main
point
In
Polygon
main
convert
overlap2
get
Polygon
get
Random
Polygon
reverse
len
is
Cross
Or
Touch
Intersect
main
polygon
Circle
Intersection
Monte
Carlo
point
In
Polygon
get
Random
Polygon
reverse
len
is
Cross
Or
Touch
Intersect
main
max
Matching
Slow
main
slow
Min
Vertex
Cover
main
slow
Min
Vertex
Cover
main
min
Weight
Perfect
Matching
Slow
minimum
Weight
Perfect
Matching
Slow2
next
Arrangement
main
get
Random
Tree
calc
Depth
get
Path
From
Ato
B
main
get
Random
Tree
calc
Depth
get
Path
From
Ato
B
main
slow
Lcs
get
Random
String
main
find
get
Random
String
main
slow
Lcs
get
Random
String
main
edge
get
Path
From
Ato
B
get
Random
Tree
next
Restricted
Growth
String
to
Sets
main
count
next
total
Count
to
Number
from
Number
enumerate
count
count
count
count
main
count
main
next
Partition
partition
By
Number
number
By
Partition
generate
Increasing
Partitions
count
Partitions
partition
Function
partition
Function2
main
binomial
Table
binomial
binomial
factorial
factorial2
binomial
main
next
Arrangement
arrangement
By
Number
number
By
Arrangement
count
Of
Arrangements
next
Arrangement
With
Repeats
main
next
Bracket
Sequence
main
prufer
Code2Tree
tree2Prufer
Code
prufer
Dfs
main
next
Permutation
permutation
By
Number
number
By
Permutation
generate
Permutations
next
Permutation
decompose
Into
Cycles
main
get
Random
Tree
get
Random
Tree2
get
Random
Undirected
Connected
Graph
get
Random
Undirected
Connected
Graph2
get
Random
Arrangement
main
check
Graph
shuffle
get
Random
Permutation
get
Random
Arrangement
get
Random
Combination
get
Random
Arrangement2
main
next
Combination
combination
By
Number
number
By
Combination
binomial
next
Combination
With
Repeats
main
gauss
main
matrix
Add
matrix
Mul
matrix
Pow
matrix
Sum
Pow
matrix
Unit
main
det
main
build
Automata
main
suffix
Array
rotation
Array
lcp
main
build
Suffix
Automaton
main
occurrences
lcs
add
String
build
Links
main
get
LCS
get
Levenstein
Distance
main
get
Hash
main
get
Random
String
leq
leq
radix
Pass
suffix
Array
suffix
Array
lcp
main
prefix
Function
find
Substring
min
Period
main
get
Random
String
min
Cyclic
Shift
decompose
main
suffix
Array
main
build
Suffix
Tree
main
lcs
z
Function
main
insert
String
print
Sorted
main
odd
Palindromes
even
Palindromes
main
odd
Palindromes
Slow
even
Palindromes
Slow
get
Random
String
lin
Kernighan
update
Best
reverse
eval
dist
get
Random
Permutation
optimize
paint
Component
main
genetic
Algorithm
cross
Over
mutate
reverse
eval
dist
get
Random
Permutation
optimize
get
Cost
compare
To
next
Generation
paint
Component
main
simplex
main
cnv
cnv
anneal
reverse
eval
dist
paint
Component
main
sums
Lower
Bound
main
add
Line
min
Value
main
find
Minimum
main
is
Root
connect
rotate
splay
expose
find
Root
link
cut
lca
main
root
build
nth
element
partition
dist2
swap
find
Nearest
Neighbour
find
Nearest
Neighbour
main
apply
push
pull
get
Mx
get
Sum
get
Size
split
merge
insert
remove
modify
query
kth
print
main
add
sum
main
root
unite
main
get
add
max
main
add
remove
process
Queries
main
create
Sets
root
unite
main
add
sum
sum
get
set
main
remove
Min
add
up
down
swap
main
min
add
Last
remove
First
main
insert
insert
count
count
main
insert
remove
main
is
Root
apply
push
pull
get
Sub
Tree
Sum
get
Size
connect
rotate
splay
expose
make
Root
connected
link
cut
query
modify
main
get
Path
From
Ato
B
kth
count
Less
Or
Eq
count
Eq
create
Tree
build
stable
Partition
main
is
Root
push
connect
rotate
splay
expose
make
Root
connected
link
cut
main
connected
dfs1
dfs2
get
modify
process
Path
main
add
sum
create
From
Array
sum
get
set
add
get1
add
sum
lower
bound
main
add
remove
Min
remove
change
Value
up
down
swap
main
add
sum
set
max
main
apply
unite
push
pull
build
build
get
get
modify
modify
find
First
find
First
sum
Lower
Bound
main
min
main
build
nth
element
partition
swap
find
Nearest
Neighbour
find
Nearest
Neighbour
main
lg
add
add
Item
ensure
Capacity
change
Value
remove
Min
pull
main
merge
add
remove
Min
main
query
insert
modify
main
build
nth
element
partition
swap
find
Nearest
Neighbour
find
Nearest
Neighbour
get
Dist
point
To
Segment
Squared
Distance
main
build
sum
set
main
build
nth
element
partition
swap
count
count
main
calc
Sizes
find
Tree
Centroid
decompose
centroid
Decomposition
main
search
search
insert
insert
replace
remove
remove
print
print
main
apply
push
pull
get
Mx
get
Sum
get
Size
split
merge
insert
remove
modify
query
find
First
find
First
print
sum
Lower
Bound
main
inversions
main
slow
Inversions
monotonic
Approximation
main
slow
Monotonic
Approximation
maximum
Zero
Submatrix
main
slow
Maximum
Zero
Submatrix
nsv
max
Inscribed
Rectangle
max
Inscribed
Rectangle2
main
dist
main
binary
Search
First
True
Simple
binary
Search
First
True
binary
Search
main
pow
main
rotate1
rotate2
reverse
swap
rotate3
main
dfs1
dfs2
solve2Sat
main
ternary
Search
ternary
Search2
ternary
Search
Double
main
floyd
brent
main
