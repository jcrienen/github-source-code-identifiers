n
net
a
i
d
k
i
j
solver
solution
i
m
net
x
y
solver
solution
xv
yv
xv
yv
solver
solution
count
time
net
x
y
z
net
x
y
net
x
y
net
x
y
z
net
x
i
n
v
j
net
x
y
rel
net
n
min
max
v
i
i
values
solver
solution
vs
i

job
machine

job
pt

job
machine

job
pt

job
machine

job
pt

job
machine

job
pt

job
machine

job
pt

job
machine

job
pt
machine
op
machine
pt
j
k
m
net
makespan
job
j
k
machine
m
j
k
problem
timeout
solver
Names
i
j
network
opt
solvers
name
solver
solution
h
w
M
N
cell
h
cell
w
y0
x0
x
y
c
i
j
i
j
p
n
color
i
d
fc
net
n
region
i
i
v
j
solver
line
tokens
i
k
k
s
i
j
i
j
vsum
hsum
sum
asum
i
j
s
x
solver
solution
data
in
n
v
i
jobs
jobs
pt
machines
machines
pt
j
m
show
Monitor
show
Solution
opt
solver
sa
taboo
best
Solution
solution
value
net
solver
Name
timeout
net
m
limit
n
p
a
x
j
i
sum
j
profit
j
solver
solution
j
net
n
sum
v
i
j
u
i
j
solver
solution
i
j
net
red
green
ivory
yellow
blue
color
englishman
spaniard
ukrainian
norwegian
japanese
nationality
coffee
tea
milk
orange
Juice
water
drink
old
Gold
kools
chesterfields
lucky
Strike
parliaments
smoke
dog
snails
fox
horse
zebra
pet
solver
count
solution
house
net
J
A
V
C
R
E
M
S
O
L
JAVA
CREAM
SOLVER
solver
solution
sum
i
j
sum
i
sum
i
x
FAMILIES
CHILDREN
max
Age
net
is
Boy
age
boy
Age
girl
Age
family
child
family
solver
solution
family
child

is
Boy

age
net
n
v
vs
i
j
i
j
j
i
i0
j0
k
i
j
solver
solution
i
j
i
m
net
q
u
d
i
solver
solution
i
j
count
time
n
net
square
v
k
i
j
s
sum
i
j
j
i
i
i
output
solver
solution
i
j
count
time
n
input
in
done
s
input
Expression
trimmed
Input
source
File
f
buff
line
input
String
str
out
buf
position
start
Command
end
Command
command
end
Block
post
Fix
new
Line
Command
new
Line
End
Block
post
Fix
new
Line
Command
new
Line
End
Block
position
properties
key
val
p
engine
d
matrix
degree
interpolation
x
y
eval
tensor
engine
visual
Set
l1
l2
j
Free
Chart
buffered
Image
graphics
engine
matrix
visual
Set
values
j
Free
Chart
engine
dist
domain
inv1
inv2
visual
Set
j
Free
Chart
engine
domain
visual
Set
j
Free
Chart
n
engine
binomial
Distribution
pdf
cdf
visual
Set
domain
j
Free
Chart
engine
SE2
geometric
Layer
buffered
Image
graphics
domain
color
Data
Indexed
F
color
Data
Indexed
P
piy
index
smoothing
Kernels
tensor
points
path2d
folder
engine
degree
x
y
fit1
x
to
y
fit2
y
to
x
samples
x
samples
y
visual
Set
j
Free
Chart
list
plot
visual
Set
buffer
j
Free
Chart
engine
j
Free
Chart
file
points
hull
geometric
Layer
buffered
Image
graphics
path2d
point
path2d
engine
folder
seed
image
engine
functions
domain
plot
visual
Set
j
Free
Chart
raw
buffered
Image
visual
Image
j
Free
Chart
domain
visual
Set
domain
visual
Set
engine
j
Free
Chart
file
util
result
i
vars
fac
poly
factor
Abstract
map
util
formula
result
buf
util
a
b
c
compound
result
n
x
y
solve
list
i
arg
list
Of
Rules
j
rule
engine
function
result
util
f1Variable
f2Variable
f3Variable
exp
result
sym
sn
ast
util
result
exp1
exp2
exp3
exp4
exp5
exp6
matrix
dims
elements
ring
lalg
row
Echelon
Form
util
expr
result
util
expr
variables
ring
poly
indent
sb
sb
i
ast
children
i
expr
tn1
util
expr
variable
List
a
x1
x2
x1Substitute
x2Substitute
ast
Rules
replaced
Expr
derived
Expr
equation
solved
Equation
matcher
util
input
result
util
exp2
exp3
exp4
exp5
exp6
exp
util
expr
buf
off
util
eq
eq1
result
eq2
util
java
Form
x
function
result
files
buffer
i
class
Name
lc
Class
Name
files
buffer
i
class
Name
lc
Class
Name
files
buffer
i
class
Name
user
Home
source
Location1
source
Location2
epp
p
expr
left
Hand
Side
right
Hand
Side
left
Hand
Side
right
Hand
Side
list
i
last
buffer
list
equals
Rule
Counter
simple
Rule
Counter
i
ast
i
ast
ast
ast
ast
ast
ast
last
buffer
symbol
Buffer
list
i
name
ast
ast
name
ast
ast
last
buffer
list
equals
Rule
Counter
simple
Rule
Counter
i
ast
i
ast
ast
list
list2
i
f
buff
line
input
String
p
automatic
Rules
automatic
Rules
File
files
buffer
engine
i
source
File
expr
out
class
Name
symbol
Name
target
File
out
out
files
buffer
engine
i
source
File
expr
class
Name
symbol
Name
target
File
binary
Data
user
Home
source
Location
java
Target
Location
list
i
i
i
i
i
i
list
i
i
i
i
i
counter
i
sym
builtin
i
sym
builtin
eval
clazz
file
Name
source
Location
line
Counter
buf
canonical
Name
package
Name
parent
Class
index
package
Path
s1
s2
f
line
line
Counter
index
canonical
Name
package
Name
parent
Class
buf
index
package
Path
files
i
class
Name
identifier
symbol
status
user
Home
source
Location
i
list
i
i
i
arg
symbol
builtin
evaluator
function
expected
Arg
Size
min
max
lower
Case
Arg
j
list
i
i
i
i
i
out
buf
status
reader
engine
relaxed
Syntax
user
Home
file
Name
ast2Expr
parser
csv
Format
records
row
List
column
List
node
temp
i
column
List
f
buff
line
input
String
files
i
source
File
function
Name
identifier
symbol
status
function
URL
rules
URL
result
index
j
end
j
end
target
File
sink
user
Home
source
Location
target
Location
list
i
i
i
i
i
str
i
files
i
class
Name
file
html
EXTENSIONS
parser
document
renderer
lines
j
input
in
done
s
user
Home
source
Location
input
Expression
trimmed
Input
that
token
Stream
std
Token
card
Keywords
token
term
stem
card
Keyword
token
Stream
std
Token
stems
token
stem
keywords
Extractor
keywords
buffer
user
Honme
source
Location
files
i
class
Name
file
f
buff
line
input
String
p
file
f
expr
compound
Expression
AST
i
ast
ast
ast
ast
integrate
left
Hand
Side
right
Hand
Side
temp
s
temp
engine
user
Home
file
Names
list
Of
Rules
fcnt
i
buffer
list
cnt
j
ast
Node
file
f
buff
line
input
String
p
file
f
expr
ast
ast
ast
lhs
AST
sym
entry
engine
list
Of
Rules
user
Home
file
Names
i
buffer
list
cnt
fcnt
function
Set
unique
Function
Set
j
ast
Node
spl
function
Name
function
Name
spl
function
Name
number
Of
Arguments
file
byte
Array
result
name
lowercase
Name
temp
p
p
p
util
result
image
Expr
b
Image
html
args
To
Render
js
manipulate
Str
manipulate
Str
js
Str
manipulate
Str
manipulate
Str
manipulate
Str
out
Expr
html
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
p
util
result
java
Script
Str
js
list
i
list
i
super
Clazz
name
super
Name
list
EXTENSIONS
parser
document
renderer
html
file
Name
source
Location
line
Counter
s1
s2
f
line
line
Counter
index
buf
canonical
Name
package
Name
parent
Class
index
package
Path
mapper
node
prime
result
other
ret
seconds
minutes
hours
days
remaining
Hours
remaining
Minutes
remaining
Seconds
remaining
Milli
Seconds
modified
nof
External
Objs
cmp
Idx
internal
Obj
idx
Cmp
idx
Cmp
implicit
Comparator
my
Mult
old
Mult
new
Mult
my
Mult
old
Mult
new
Mult
old
Mult
imult
casted
Key
my
Mult
old
Mult
new
Mult
mult
imult
resultset
my
Mult
my
Key
other
Mult
joint
Mult
sum
flat
List
value
multiplicity
i
factor
Str
multiplicity
other
my
Mult
other
Mult
last
s
Len
buffer
i
ret
s
Len
mask
Len
ret
s
Len
mask
Len
class
Name
last
Point
Index
lengths
max
Length
record
Lengths
record
Lengths
N
length2N
Start
List
progression
To
Max
Length
resolved
i
sequence
n
Start
n
length
lengths
max
Length
record
Lengths
record
Lengths
N
length2N
Start
List
progression
To
Max
Length
resolved
i
sequence
n
Start
n
length
n
List
n
List
period
n
Period
List
period
Diff
n
Count
diffs
i
diff
Count
period
i
mul
add
add2Max
Length
max
Length
unbounded
Progression
Counts
max
Lengths
max
Bounded
Length
unbounded
Progressions
Count
progr
Max
Length
result
i
result
i
result
den
result
den
n
Square
tmp
ret
i
ret
i
bu
i
i
results
n
r
results
n
r
results
n
r
n
i
h
n
Max
r
Max
root
Expr
two
Powx
result
p
exponent
pow
Term1
log
Term1
pow
Term2
log
Term2
log
Term3
total
Log
Term
e
result
p
exponent
epsilon
entry
can
digits
last
Exponent
Sum
wanted
Exponent
Sum
precomputed
Entry
last
X
min
X
max
X
current
X
current
current
Exponent
Sum
cmp
last
Exponent
Sum
wanted
Exponent
Sum
precomputed
Entry
last
Epsilon
min
Epsilon
max
Epsilon
current
Epsilon
current
current
Exponent
Sum
cmp
a
a
Pow
nth
Root
b
Min
b
Max
b
b
Pow
lhs
rhs
b
b
Pow
lhs
rhs
b
b
Pow
lhs
rhs
a
a
Pow
nth
Root
b
Min
b
Max
b
b
Pow
lhs
sqrt
b
b
Pow
lhs
sqrt
b
b
Pow
lhs
sqrt
a
a
Pow
nth
Root
b
b
Pow
lhs
rhs
a
Max
n
m
mod
Pow
mod
Pow
mod
Pow
legendre
Engine
jacobi
Engine
rng
a
List
int
p
List
int
bits
a
List
p
List
i
i
p
a
Int
Iter
a
Int
p
Int
Iter
p
Int
correct
jacobi02
jacobi03
legendre
rng
a
List
int
p
List
int
bits
a
List
p
List
i
i
p
legendre
Engine
jacobi
Engine
t0
p
Mod8
pm1
S
Q
z
c
R
t
M
found
I
i
b
t
k
n2
g
g
Square
p
big
i
t
p
big
n
Mod
P
t
t
Max
tt
tt
Mod
P
f
u
p
Mod8
pm1
S
Q
z
c
R
t
M
found
I
i
b
t
k
n2
g
g
Square
i
ng
t
i2
p
big
n
Mod
P
t
t
Max
tt
tt
Mod
P
f
u
p
Array
i
n
count
n
Array
i
n
p
mse31
p
Array
n
Array
i
a
p
tonelli
case5Mod8
t
mse31
p
Array
n
Array
i
i
i
i
i
i
mod
Pow
mod
Pow
a
Mod
C
mod
Pow
a
Mod
C
p
Mod8
pm1
S
Q
z
c
R
t
M
found
I
i
b
k
t
k
n2
g
g
Square
i
im1
t
u
b1
b1invp
b1Square
b2
u
f
u
a
Cmp
Zero
t
m
Mod8
m
Mod4
a
Mod4
tmp
a
Cmp
Zero
t
m
Mod8
lsb
m
Mod4
a
Mod4
has
Odd
Power
Of2
tmp
a
Cmp
Zero
t
m
Mod8
lsb
has
Odd
Power
Of2
tmp
a
Cmp
Zero
t
m
Mod8
a
int
lsb
tmp
has
Odd
Power
Of2
t
m
Mod8
lsb
has
Odd
Power
Of2
m
int
tmp
t
m
Mod8
lsb
tmp
has
Odd
Power
Of2
easy
Part
m
Cmp
Zero
a
Mod8
m
Cmp1
n
Cmp1
g
s
dv
m
Cmp1
n
Cmp1
cmp
m
Cmp1
n
Cmp1
m
lsb
n
lsb
shifts
t
gcd
a
Zeros
b
Zeros
t
cmp
itr
ret
ret
i
ab
gcd
itr
ret
ret
i
a
b
g
u
v
w
parity
q
tmp
a
g
u
w
parity
tmp
rem
a
g
u
w
parity
tmp
rem
ps
ps1
ps2
parity
dividend
divisor
rem
q
sign
a
Pos
a
b
g
u
v
w
parity
q
tmp
a
g
u
w
parity
tmp
rem
a
g
u
w
parity
tmp
rem
ps
ps1
ps2
dividend
divisor
rem
q
a
Pos
parity
sign
ps1
ps2
parity
dividend
divisor
rem
q
t
sign
a
Pos
m
Cmp1
n
Cmp1
g
s
dv
rem
m
Cmp1
n
Cmp1
m
lsb
n
lsb
shifts
t
gcd
a
Zeros
b
Zeros
t
itr
ret
m
Cmp1
n
Cmp1
g
s
dv
rem
m
Cmp1
n
Cmp1
m
lsb
n
lsb
shifts
t
gcd
a
Zeros
b
Zeros
t
itr
ret
first
Stack
Elem
stack
Elem
rest
prefix
prefix
Size
max
Next
Part
part
new
Prefix
result
partitions
part
Gen
flat
Partition
exp
Partition
start
part
Gen
count
input
in
line
n
i
i
value
Iter
i
elem
Sum
dim
i
dim
lower
upper
last
Non
Null
i
my
Value
other
Value
diff
j
dim
result
other
Iter
i
other
Elem
other
Value
dim
lower
upper
is
Even
index
i
Value
dim
rest
Minus
First
Part
last
Non
Null
last
Part
Smaller
i
diff
last
Part
Value
j
my
Size
other
Iter
i
other
Value
other
ret
i
first
Stack
Elem
stack
Elem
rest
prefix
prefix
Size
max
Next
Part
next
Parts
And
Complements
new
Prefix
result
partitions
part
Gen
flat
Partition
exp
Partition
part
Gen
count
mpi
From
Factors
start
count
input
in
line
q
size
prime
mult
prime
Powers
i
prime
mult
factors
n
big
N
divisors
number
Of
Divisors
prime
Powers
power
Map
power
Map
Size
corrected
Power
Map
Size
ret
part
power
sum
Str
multiplicity
n
big
N
number
Of
Factorizations
record
n
number
Of
Factorizations
record
Ratio
n
number
Of
Factorizations
bits
ratio
i
start
factorial
number
Of
Factorizations
n
start
total
Number
Of
Partitions
partgen
flat
Partition
exp
Partition
mpi
From
Partition
mpi
Part
Gen
factor
Str
multiplicity
result
result
idx
elem
Value
subvalue
complement
idx
elem
Value
subvalue
submpis
submpi
complement
biggest
Elems
subvalues
And
Complements
str
total
entry
count
i
p
Nbits
p
Min
Bits
sqrt
N
floor
Sqrt
N
four
N
sqrt4N
a
b
test
k
i
p
Min
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
test
Numbers
holf
factor
i
rest
adjust
Exp
four
N
sqrt4N
i
k
a
k
Np1
fourk
N
rest
adjust
Exp
adjust
Mod
a2
s
test
s
test
Mod
sqrt
RNG
holf
i
N
adjusts
rest
best
Adjust
Exp
max
S
Min
adjust
Exp
s
Min
sfs
i
s
factor
sqrt
N
floor
Sqrt
N
four
N
sqrt4N
a
b
test
gcd
i
k
adjust1
adjust2
adjust1
adjust2
test
Numbers
holf
factor
i
four
N
sqrt4N
a
b
test
gcd
k
i
a0
adjust
N
min
test
Numbers
k
N
Str
k
Nk
a
bits
test
Engine
i
N
dbl
ln
N
lnln
N
ln
N
Pow
max
Q
Rest
factor
Test
i
p
end
Time
N
long
sqrt
N
floor
Sqrt
N
four
N
sqrt4N
a
b
Q
test
gcd
k
i
aq
Pair
added
Smooth
smooth
Congruence
Count
added
Smooth
smooth
Congruence
Count
adjust1
adjust2
adjust1
adjust2
i
factor
sqrt
N
floor
Sqrt
N
four
N
sqrt4N
a
b
test
gcd
k1
k2
i
k
Np1
adjust1
adjust2
adjust1
adjust2
test
Numbers
holf
factor
i
factor
sqrt
N
floor
Sqrt
N
four
N
sqrt4N
a
b
test
gcd
k
i
adjust1
adjust2
adjust1
adjust2
test
Numbers
holf
factor
i
p
Nbits
p
Min
Bits
sqrt
N
floor
Sqrt
N
four
N
sqrt4N
a
b
test
gcd
k
i
p
Min
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
test
Numbers
holf
factor
k
Max
i
sqrt
I
sqrt
N
k
a
test
b
gcd
test
Numbers
holf
factor
i
r0
r0
a
b
c
upperl
diff
LCGSTATE
shifted
quot
prod
rand
result
x
x1
tmp
s1
s2
d1
d2
swp
i
s1
s2
d1
d2
swp
i
d
e
r
s1
s2
d1
d2
swp
ps1
ps2
parity
dividend
divisor
rem
q
t
t1
t2
t3
t4
u
v
n
t4Big
n
Big
t3Big
t3Correct
curve
result
work
P
sigma
rho
x
q
stg1
b
i
j
k
Pa
Pb
Pd
acc
barray
numb
ab
t
r
f
rng
N
Bits
curves
B1
result
factorizer
test
Numbers
i
N
factor
i
auto
Primes
index
M
args
composite
Factors
result
N
Nexp
composites
To
Test
failed
Composites
exp
r
max
Curves
For
N
NN
max
Curves
For
N
old
Exp
N
Bits
max
Curves
For
N
TX
TZ
UX
UZ
Aux1
Aux2
Aux3
d
N
Montgomery
Mult
R1
Montgomery
Mult
R2
Montgomery
Mult
After
Inv
jj
L1
L2
LS
Pass
I
I
P
index
M
IP
u
i
i
j
u
Pass
J
I
Qaux
max
Index
M
index
M
i
i
j
Q
d
e
r
i
t
x
A
z
A
x
B
z
B
x
C
z
C
c
d
e
r
u
v
w
t
u
v
w
ch
Sign
nbr
Pos
i
Temp
N
Bytes
j
mask
p
i
Number
Length
Cy
i
Number
Length
Cy
i
Number
Length
Max
U
Int
carry
i
carry
i
Number
Length
Cy
i
Number
Length
Max
U
Int
carry
i
Number
Length
Max
U
Int
Pr
j
Number
Length
Max
U
Int
i
j
Pr
Nbr
Number
Length
Max
U
Int
Trial
Quotient
carry
i
d
Aux
i
Ch
Sign
Divisor
Divid
Rem
i
i
Number
Length
Cy
i
i
j
k
i
j
k
k
Number
Length
i
Number
Length
Dif
E
st1
st2
Yaa
Yab
Yba
Ybb
Ygb0
Ymb0
Iaa
Iab
Iba
Ibb
Tmp1
Tmp2
Tmp3
Tmp4
Tmp5
B0l
inv
B0l
Al
Bl
T1
Gl
Ml
carry1
carry2
carry3
carry4
Yaah
Yabh
Ybah
Ybbh
Ymb0h
Ygb0h
Pr1
Pr2
Pr3
Pr4
Pr5
Pr6
Pr7
nbr
Copy
ch
Sign
Temp
result
true
Number
Length
i
is
Negative
NL
N
Bytes
i
digit
zero
Count
NL2
N
Bytes2
NL
N
Bytes
i
digit
test
Nums
ecm
t0
t1
factor
Args
factor
Result
N32
N31
bits
Number
Length
N
Array
i
i
i
i
N
a31Str
b31Str
diff
Str
imax
jmin
i
a
j
b
correct
Result
test
Result
i
a
j
b
correct
Result
test
Result
test
Result32
i
a
j
b
correct
Result
test
Result
i
a
j
b
correct
Result
test
Result
test
Result32
tests
N
Number
Length
ecm
Test
N
x
i
j
Max
U
Int
Pr
Nbr
Prod0
Prod1
Prod2
Prod3
Prod4
Prod5
Prod6
Prod7
Prod8
Prod9
Prod10
Test
Nbr0
Test
Nbr1
Test
Nbr2
Test
Nbr3
Test
Nbr4
Test
Nbr5
Test
Nbr6
Test
Nbr7
Test
Nbr8
Test
Nbr9
Test
Nbr10
Nbr2
0
Nbr2
1
Nbr2
2
Nbr2
3
Nbr2
4
Nbr2
5
Nbr2
6
Nbr2
7
Nbr2
8
Nbr2
9
Nbr2
10
Mont
Dig
i
r0
r0
a
b
c
upperl
diff
LCGSTATE
shifted
quot
prod
rand
result
x
x1
tmp
s1
s2
d1
d2
swp
i
s1
s2
d1
d2
swp
i
d
e
r
s1
s2
d1
d2
swp
ps1
ps2
parity
dividend
divisor
rem
q
t
t1
t2
t3
t4
u
v
n
curve
result
work
P
sigma
rho
q
stg1
b
i
j
k
Pa
Pb
Pd
acc
barray
numb
x
a
u
v
ab
t
r
f
rng
N
Bits
curves
B1
result
factorizer
test
Numbers
i
N
factor
i
r0
r0
a
b
c
upperl
diff
LCGSTATE
shifted
quot
prod
rand
result
x
x1
tmp
s1
s2
d1
d2
swp
i
s1
s2
d1
d2
swp
i
d
e
r
s1
s2
d1
d2
swp
ps1
ps2
parity
dividend
divisor
rem
q
t
t1
t2
t3
t4
u
v
n
curve
result
work
P
sigma
rho
x
q
stg1
b
i
j
k
Pa
Pb
Pd
acc
barray
numb
a
hi
b
hi
a
lo
b
lo
ab
lo
prod
ab
med
prod1
ab
med
prod2
ab
med
term
ab
hi
prod
ab
carry
ab
hi
ab
lo
t
t
hi
N
hi
t
lo
N
lo
t
N
lo
prod
t
N
med
prod1
t
N
med
prod2
t
N
med
term
t
N
hi
prod
t
N
carry
t
N
hi
t
N
lo
r
lo
r
hi
r
f
rng
N
Bits
curves
B1
result
factorizer
test
Numbers
i
N
factor
i
r0
r0
a
b
c
upperl
diff
LCGSTATE
shifted
quot
prod
rand
result
x
x1
tmp
s1
s2
d1
d2
swp
i
s1
s2
d1
d2
swp
i
d
e
r
s1
s2
d1
d2
swp
ps1
ps2
parity
dividend
divisor
rem
q
t
t1
t2
t3
t4
u
v
n
t4Big
n
Big
t3Big
t3Correct
curve
result
work
P
sigma
rho
x
q
stg1
b
i
j
k
Pa
Pb
Pd
acc
barray
numb
ab
t
r
aa
t
r
f
rng
N
Bits
curves
B1
result
factorizer
test
Numbers
i
N
factor
N
dbl
ln
N
lnln
N
ln
N
Pow
max
Q
Rest
factor
Test
k
Map
k
Iter
i
Sqrt
i
end
Time
cc
Report
i
A
im2
A
im1
A
i
P
im1
P
i
Q
i
Q
ip1
two
floor
sqrt
k
N
Q
ip1
sqrt
gcd
Q
test
aq
Pair
added
Smooth
smooth
Congruence
Count
Q
im1
b
i
Q
test
div
sum
two
a
ma
mod
N
product
cfrac
timer
in
line
input
N
factor
duration
N
dbl
ln
N
lnln
N
ln
N
Pow
max
Q
Rest
factor
Test
k
Map
k
Iter
sqrt
k
N
big
diff
i
end
Time
i
A
im2
A
im1
A
i
P
im1
P
i
Q
i
two
floor
sqrt
k
N
is
Square
Q
ip1
sqrt
gcd
Q
test
aq
Pair
added
Smooth
smooth
Congruence
Count
Q
im1
b
i
Q
test
div
sum
m
int
two
a
ma
mod
N
product
Q
rest
lsb
trial
Div
Index
Q
rest
bits
p
tmp
Q
rest
long
p
Q
rest
int
p
Q
rest
lsb
trial
Div
Index
Q
rest
bits
p
Q
rest
int
p
p
Max
Bits
Q
rest
lsb
trial
Div
Index
Q
rest
bits
p
tmp
old
Q
rest
long
p
Q
rest
int
p
is
Smooth
factor1
Q
rest
bits
Q
rest
lsb
trial
Div
Index
Q
rest
bits
p
Q
rest
int
p
is
Smooth
factor1
Q
rest
bits
p
Max
Bits
Q
rest
lsb
trial
Div
Index
Q
rest
bits
p
rem
tmp
Q
rest
long
p
Q
rest
int
p
is
Smooth
factor1
Q
rest
bits
N
Bits
log
N
Bits
wanted
Prime
Count
k
Max
penalty
Mult
k
Count
k
big
k
k
N
k
N
Mod8
f
k
Index
List
k
Index
f
Values2k
i
p
ln
P
Term1
ln
P
Term2
Legendre
N
p
k
Index
Iter
k
Index
k
prime
Factors
lsb
args
factor
Result
untested
Factors
untested
Factor
exp
composite
Factor
exp
N
factor1
max
Q
Rest
Exponent
Str
N
pure
Power
factor1
pure
Power
N
Bits
N
dbl
ln
N
ln
Term
prime
Base
Size
dbl
prime
Base
Size
primes
Array
required
Smooth
Congruence
Count
k
k
N
k
Big
d
t
Array
p
Max
proposed
Sieve
Array
Size
adjusted
Sieve
Array
Size
max
Q
Rest
factor
Test
sieve
Params
log
P
Array
pinv
Array
D
pinv
Array
L
i
base
Arrays
smooth
X
List
aq
Pairs
added
Smooth
smooth
Congruence
Count
congruences
factor
perfect
Smooth
Percentage
partial
Percentage
log
P
Array
i
all
X
List
x
all
AQ
Pairs
poly
Report
sieve
Report
tdiv
Report
cc
Report
init
Poly
Duration
sieve
Duration
tdiv
Duration
p
Max
Bits
q
Rest
Sizes
qs
timer
in
line
input
N
factors
duration
p
Array
x1Array
x2Array
log
P
Array
x1min
log
P
x1
x1
neg
i
p
x1
x1
neg
x2min
x2
x2
neg
smooth
X
List
x
filled
unfilled
fill
Next
lower
upper
lower
Error
upper
Error
initializer
sieve
Array
Size0
block
Base
filled
unfilled
fill
Next
p
Array
r
s
x1Array
x2Array
log
P
Array
x1
x2
i
smooth
X
List
b
block
Offset
block
Offset1
block
Offset2
block
Offset3
block
Offset4
x
x
r
x
d1
log
P
d2
log
P
d2
M
d
p
r
x
d1
log
P
d2
log
P
d2
M
d
p
p
Max
sieve
Array
Size0
B2Base
sieve
Allocation
Size
p
Array
p
Array
x1Array
x2Array
x1
x2
i
smooth
X
List
log
P
Array
i
x1Addr
x2Addr
log
P
p
log
P
p
log
P
next
B2Address
b2
b2Offset
b1
y0
y1
x
relative
X
y00
y01
y10
y11
p
log
P
p
log
P
p
log
P
b2
b2Offset
b1
y0
y1
x
relative
X
y00
y01
y10
y11
r
d1
x
log
P
d2
log
P
d2
M
d
p
r
d1
x
log
P
d2
log
P
d2
M
d
p
filled
unfilled
fill
Next
initializer
sieve
Array
Size0
block
Base
filled
unfilled
fill
Next
p
Array
r
s
x1Array
x2Array
log
P
Array
x1
x2
i
smooth
X
List
b
next
Block
Address
block
Offset
y0
y1
x
relative
X
y00
y01
y10
y11
x
relative
X
y00
y01
y10
y11
r
d1
x
log
P
d2
log
P
d2
M
d
p
r
d1
x
log
P
d2
log
P
d2
M
d
p
p
Max
sieve
Array
Size0
block
Base
sieve
Allocation
Size
p
Array
p
Array
x1Array
x2Array
x1
x2
i
smooth
X
List
log
P
Array
i
log
P
p
log
P
p
log
P
p2
b
block
Offset
block
Offset1
block
Offset2
block
Offset3
block
Offset4
x
p
log
P
p
log
P
p
log
P
p2
b
block
Offset
block
Offset1
block
Offset2
block
Offset3
block
Offset4
x
r
x
d1
log
P
d2
log
P
d2
M
d
p
r
x
d1
log
P
d2
log
P
d2
M
d
p
filled
unfilled
fill
Next
min
Ln
P
Sum
ln
Log
Base
min
Log
P
Sum
log
Base
ln
Small
P
Sum
i
p
log
Small
P
Sum
initializer
Value
initializer
Block
i
p
Max
sieve
Allocation
Size
p
Array
i
p
Array
x1Array
x2Array
log
P
Array
i
j
x1Addr
x2Addr
log
P
p
log
P
p
log
P
p
log
P
smooth
X
List
y0
y1
x
relative
X
y00
y01
y10
y11
p
log
P
p
log
P
p
log
P
p
log
P
x
relative
X
y00
y01
y10
y11
filled
unfilled
fill
Next
p
Max
sieve
Allocation
Size
p
Array
i
p
Array
x1Array
x2Array
log
P
Array
i
x1
x2
j
log
P
p
log
P
p
log
P
p2
p
log
P
p2
smooth
X
List
x
p
log
P
p
log
P
p
log
P
p2
p
log
P
p2
x
filled
unfilled
fill
Next
p
Max
sieve
Array
Size0
B2Base
sieve
Allocation
Size
p
Array
p
Array
x1Array
x2Array
x1
x2
i
smooth
X
List
log
P
Array
i
log
P
p
log
P
p
log
P
p2
b2
b2Offset
b1
b2Offset1
b2Offset2
b2Offset3
b2Offset4
x
p
log
P
p
log
P
p
log
P
p2
b2
b2Offset
b1
b2Offset1
b2Offset2
b2Offset3
b2Offset4
x
r
x
d1
log
P
d2
log
P
d2
M
d
p
r
x
d1
log
P
d2
log
P
d2
M
d
p
filled
unfilled
fill
Next
p
Max
sieve
Array
Size0
block
Base
sieve
Allocation
Size
p
Array
p
Array
x1Array
x2Array
x1
x2
i
smooth
X
List
log
P
Array
i
x1Addr
x2Addr
log
P
p
log
P
p
log
P
next
Block
Address
b
block
Offset
y0
y1
x
relative
X
y00
y01
y10
y11
p
log
P
p
log
P
p
log
P
b
block
Offset
y0
y1
x
relative
X
y00
y01
y10
y11
r
d1
x
log
P
d2
log
P
d2
M
d
p
filled
unfilled
fill
Next
initializer
sieve
Array
Size0
B2Base
filled
unfilled
fill
Next
p
Array
x1Array
x2Array
log
P
Array
x1
x2
i
r
l
r
m
r
s
smooth
X
List
b2
b1
b2Offset
b2Offset1
b2Offset2
b2Offset3
b2Offset4
x
b1
x
r
x
d1
log
P
d2
log
P
d2
M
d
p
r
x
d1
log
P
d2
log
P
d2
M
d
p
powers
power
Count
base
Arrays
merged
Primes
merged
Exponents
merged
Powers
merged
T
Array
mergedlog
P
Array
merged
Pinv
Array
D
merged
Pinv
Array
L
merged
Index
p
Index
p
power
Iter
power
Entry
k
N
UBI
p
Min
Index
p
Min
p
Max
ln
P
Multiplier
power
Entries
sqrt
P
Max
Index
max
Index
p
Index
p
power
long
exponent
last
power
power
log
Power
u
exponents
i
k
N
UBI
p
Min
p
Max
ln
P
Multiplier
power
Entries
sqrt
P
Max
Index
p
Index
p
power
long
exponent
last
power
power
log
Power
u
N
Bits
wanted
Prime
Count
k
Max
k
Count
k
k
N
k
N
Mod8
f
k
Index
List
k
Index
i
p
ln
P
ln
P
Term1
ln
P
Term2
Legendre
N
p
k
Index
Iter
k
Index
k
best
k
best
f
k
Index
aq
Pairs
x
Big
dax
A
Qdiva
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
m
q
div
pass2Index
p
Big
i
aq
Pairs
x
Big
dax
A
Qdiva
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
q1
pass2Index
p
rem
tmp
rest
Is
Prime
factor1
Q
rest
bits
factor2
i
aq
Pairs
x
Big
dax
A
Qdiva
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
m
q
pass2Index
p
rem
tmp
is
Smooth
rest
Is
Prime
factor1
Q
rest
bits
factor2
i
aq
Pairs
x
Big
dax
A
Qdiva
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
m
q
pass2Index
p
rem
tmp
rest
Is
Prime
factor1
Q
rest
bits
factor2
i
percentage
aq
Pairs
A
Q
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
m
q
pass2Index
p
rem
tmp
aq
Pairs
x
Big
dax
A
Qdiva
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
m
q
div
pass2Index
p
Big
is
Smooth
rest
Is
Prime
factor1
Q
rest
bits
factor2
i
aq
Pairs
x
Big
dax
A
Qdiva
aq
Pair
Q
rest
lsb
pass2Count
x
Abs
p
Index
p
x
Mod
P
m
q
pass2Index
p
rem
tmp
i
l
ql
q
Index
t
ql
big
a
div
ql
a
div
ql
mod
Inv
ql
gamma
Bl
v
b
Parameter
Needs
Addition
test
i
correct
B
values
i
B
correct
b
values
i
N
dbl
solutions
Count
filter
Result
v
gray
Code
Sign
Is
Positive
l
ql
t
ql
big
a
div
ql
a
div
ql
mod
Inv
ql
gamma
Bl
b
UBI
p
Array
t
Array
x1Array
x2Array
ainvp
Array
p
Index
p
ainvp
t
b
Mod
P
t
minus
b
mod
P
minus
t
minus
b
mod
P
j
Bainv2Row
B2
p
Index
p
ainvp
filtered
Powers
x1Array
x2Array
p
Index
p
Bainv2
x1
x2
p
Index
p
Bainv2
x1
x2
best
q
best
q
index
min
Index
min
Index
Defect
max
Index
max
Index
Defect
q
Index
Set
i
random
Offset
wanted
q
Index
q
Index
q
q
big
a
rest
best
q
index
q
Index
q
q
big
q
Index
Iter
i
q1
index
q1
error
q0
index
q0
error
step
step
Up
q
Index
step
Down
q
Index
duplicate
A
Count
previous
A
Params
disjunct
Q
Count
Counts
shared
Q
Count
disjunct
Q
Count
i1
i2
shared
Count
cmp
merged
Primes
merged
Exponents
merged
Powers
merged
T
Array
mergedlog
P
Array
merged
Pinv
Array
D
merged
Pinv
Array
L
filtered
Primes
filtered
Exponents
filtered
Powers
filtered
T
Array
filtered
Log
P
Array
filtered
Pinv
Array
D
filtered
Pinv
Array
L
filtered
Out
Count
lastq
Index
q
Set
i
p
src
Pos
dest
Pos
length
src
Pos
dest
Pos
length
filtered
Base
Size
merged
Primes
merged
Exponents
merged
Powers
merged
T
Array
mergedlog
P
Array
merged
Pinv
Array
D
merged
Pinv
Array
L
filtered
Primes
filtered
Exponents
filtered
Powers
filtered
T
Array
filtered
Log
P
Array
filtered
Pinv
Array
D
filtered
Pinv
Array
L
filtered
Out
Count
lastq
Index
q
Set
filtered
Out
Base
Elements
Set
i
p
src
Pos
dest
Pos
length
src
Pos
dest
Pos
length
filtered
Out
Base
Elements
i
filtered
Base
Size
merged
Primes
merged
Exponents
merged
Powers
merged
T
Array
mergedlog
P
Array
merged
Pinv
Array
D
merged
Pinv
Array
L
filtered
Primes
filtered
Exponents
filtered
Powers
filtered
T
Array
filtered
Log
P
Array
filtered
Pinv
Array
D
filtered
Pinv
Array
L
q
Set
filtered
Base
Size
i
p
k
N
UBI
t
Array
i
p
k
N
mod
p
max
Q
Rest
Exponent
Str
N
pure
Power
factor1
pure
Power
N
Bits
N
dbl
ln
N
ln
Term
prime
Base
Size
dbl
prime
Base
Size
primes
Array
required
Smooth
Congruence
Count
k
k
N
k
Big
d
t
Array
p
Max
proposed
Sieve
Array
Size
adjusted
Sieve
Array
Size
max
Q
Rest
factor
Test
sieve
Params
log
P
Array
pinv
Array
D
pinv
Array
L
i
base
Arrays
smooth
X
List
aq
Pairs
added
Smooth
smooth
Congruence
Count
congruences
factor
log
P
Array
i
poly
Report
sieve
Report
tdiv
Report
cc
Report
init
Poly
Duration
sieve
Duration
tdiv
Duration
p
Max
Bits
q
Rest
Sizes
qs
timer
in
line
input
N
factors
duration
i
base
Multiplier
k
Sequence
base
Sequence
j
bits
stop
Mult
base
Multiplier
Factors
base
Multiplier
Index
base
Sequence
base
Sequence
Index
k
diff
factor
i
P
im1
P
i
Q
i
Q
ip1
sqrt
factor
Q
im1
b
i
i
b
i
P
i
Q
i
Q
ip1
P
im1
Q
im1
gcd
squfof31
test
Factorizer
N0
correct
Factors
squfof
Factors
RNG
count
bits
fail
Count
i
N
N
big
tdiv
Factor
squfof
Factor
stop
Mult
bits
base
Multiplier
Factors
k
Sequence
k
sqrt
k
N
big
diff
factor
i
P
im1
P
i
Q
i
Q
ip1
sqrt
factor
Q
im1
b
i
i
b
i
P
i
Q
i
P
i
big
Q
ip1
P
im1
Q
im1
gcd
squfof63
test
Factorizer
N0
correct
Factors
squfof
Factors
RNG
count
bits
fail
Count
i
N
N
big
tdiv
Factor
squfof
Factor
bits
stop
Mult
base
Multiplier
Factors
base
Multiplier
Index
base
Multiplier
k
Sequence
k
diff
factor
i
P
im1
P
i
Q
i
Q
ip1
sqrt
factor
Q
im1
b
i
i
b
i
P
i
Q
i
Q
ip1
P
im1
Q
im1
gcd
squfof31
test
Factorizer
N0
correct
Factors
squfof
Factors
RNG
count
bits
fail
Count
i
N
N
big
tdiv
Factor
squfof
Factor
G
ys
x
c
x0
y
m
r
q
i
k
i
Max
i
diff
diff
sum
input
in
line
start
n
result
Nbits
G
x
ys
c
x0
y
m
r
q
i
k
i
Max
i
diff
diff
sum
input
in
line
start
n
result
bit
Length
product
gcd
c
x
xx
i
sum
G
x
ys
Nbits
m
y
r
q
i
k
i
Max
i
diff
diff
a
u
v
ab
t
r
n
in
line
input
start
result
gcd
bit
Length
x
xx
c
sum
G
x
ys
Nbits
m
y
r
q
i
k
i
Max
i
diff
diff
a
u
v
ab
t
r
n
in
line
input
start
result
G
x
ys
m
c
y
r
q
i
k
i
Max
i
diff
diff
a
u
v
ab
t
reduced
result
sum
n
in
line
input
start
result
gcd
x
xx
c
sum
N
Array
writer
i
N
i
N
min
Bits
max
Bits
i
n1bits
n1
N
n2
min
Bits
i
n1
n2bits
n2
N
bits
num
timer
n
Count
bits
start
test
Numbers
end
size
Counts
bitlen
count
generated
Bit
Lens
sieve
N
Bits
N
Bits
actual
Tdiv
Limit
e
N0
N
exp
max
Curves
For
N
number
Of
Threads
N
line
in
input
parser
number
Of
Threads
N
exit
Code
N
bits
t0
factorizer
result
duration
duration
Str
single
Element
N
min
test
Numbers
factors
factor
Set
Array
correct
Factor
Sets
ms
2
algorithms
i
alg
Name
fail
Count
fail
Example
duration
start
Time
Millis
j
end
Time
Millis
j
N
factor
test
start
Time
Millis
j
end
Time
Millis
j
N
factor
Set
correct
Factors
alg
List
rank
alg
List
j
duration
Str
product
exp
pow
test
Engine
bits
i
p
N
lsb
q
i
p
i
unrolled
Limit
i
p
N
q
i
p
i
unrolled
Limit
N
i
p
exp
i
p
args
untested
Factors
result
N
Nexp
prime
Factors
lsb
p
i
i
p
i
big
div
p
i
square
N
UBI
i
p
old
Exp
N
i
p
exp
i
p
i
p
N
Bits
N
i
p
Min
Bits
p
Min
p
exp
p
exp
r
i
Nbits
p
Min
Bits
p
Min
p
Max
Index
p
Max
tdiv
Inv
test
Factorizer
special
N
tdiv
Factor
test
Factor
RNG
count
bits
fail
Count
i
N
N
big
tdiv
Factor
test
Factor
number
Of
Threads
file
Name
line
in
input
parser
test
Numbers
reader
line
N
factorizer
start
factors
duration
keys
smallest
Found
Factor
smallest
Found
Factor
Bit
Length
f
allocation
Size
address
allocation
Size
total
Q
factors
t0
total
Q
Sqrt
exp
half
Exp
A
Prod
composition
Duration
total
Q
div
minus
Gcd
plus
Gcd
str
str
i
j
k
old
Diagonal
S
St
new
Diagonal
S
St
index
index
C
mask
matrix
D
matrix
E
matrix
E2
matrix
F
matrix
Winv
matrix
Winv1
matrix
Winv2
matrix
Vt
V0
matrix
Vt1V0
matrix
Vt2V0
matrix
Vt
AV
matrix
Vt1AV1
matrix
AV
matrix
Calc
Paren
D
vector
Index
matrix
V
matrix
V1
matrix
V2
matrix
Xm
Y
matrix
Calc3
matrix
Temp
matrix
Calc1
matrix
Calc2
matr
row
Matrix
V
row
Matrix
Xm
Y
seed
Temp
Temp1
step
Nbr
current
Order
current
Mask
row
col
left
Col
right
Col
minind
min
minanswer
row
Matrix
B
left
Matr
matr
Length
prod
Matr
row
col
left
Matr
matr
Length
prod
Matr
row
col
prod
Matr
matr
Length
row
col
i
Mask
row
row
index
prod
Matr
row
Matrix
B
row
congruence
Column
matrix
V
Entry
row
mask1
mask2
matr1
matr2
row
mask1
mask2
matr1
matr2
long
Index
rest
Index
x
long
Index
the
Long
rest
Index
x
Max
max
Long
Index
long
Index
long
Index
the
Long
i
result
i
the
Long
x
j
is
Set
other
i
str
i
other
rows
row
Iter
pivot
Row
pivot
Column
Index
row
biggest
Column
Index
row
total
AQ
Pairs
congruence
matrix
Rows
row
Index
number
Of
Rows
column
Indices
From
Odd
Exp
Factors
row
Index
History
matrix
Row
odd
Exp
Factors
column
Index
Bitset
row
Index
History
matrix
Blength
matrix
B
i
odd
Exp
Factors
matrix
Row
j
column
Index
matrix
V
mask
total
AQ
Pairs
row
congruence
congruences
Copy
odd
Exp
Factors
2
congruences
factors
2
indices
found
Singleton
congruence
Iter
congruence
odd
Exp
Factors
congruence
List
congruence
List
index
factors
2
column
Indices
added
large
Factors
large
Factors
Count
i
large
Factor
r1
r2
q
vertex
Count
cycle
Count
roots2
rbp
pbr
chains
odd
Exp
Big
Factors
factors
List
partial
Congruence
List
smooths
From
Partials
tables
Changed
r0Iter
r0
r0Factors
p
ri
List
ri
Factors
all
Partials
smooth
ri
Chain
partials
p
List
congruences
Copy
large
Factors
2
partials
factors
2
indices
found
Singleton
congruence
Iter
congruence
congruence
List
congruence
List
index
factors
2
column
Indices
rows
row
Iter
pivot
Row
pivot
Column
Index
row
biggest
Column
Index
row
total
AQ
Pairs
congruence
smooth
Congruence
matrix
Rows
row
Index
number
Of
Rows
column
Indices
From
Odd
Exp
Factors
row
Index
History
matrix
Row
odd
Exp
Factors
column
Index
Bitset
row
Index
History
all
Factors
all
Factors
i
other
all
Factors
smooth
added
partial
odd
Exp
Big
Factors
odd
Exp
Big
Factors
Count
related
Partials
found
Smooths
added
Count
max
Large
Factor
Count
large
Factor
Count
odd
Exp
Big
Factor
Bits
processed
Large
Factors
related
Partials
current
Large
Factors
next
Large
Factors
partial
List
partial
Congruence
List
odd
Exp
Big
Factor
Bits
partial
Congruence
List
added
Smooth
smooth
Congruence
Count
congruences
smooth
From
Partials
Str
partials
Str
percentiles
total
Factor4Smooth
Count
result
Map
i
required
Count
count
size
Count
total
Partial
Big
Factor
Count
non
Int
Partial
Big
Factor
Count
size
count
partial
Percentage
total
Smooth
Big
Factor
Count
non
Int
Smooth
Big
Factor
Count
size
count
smooth
Percentage
partial
With
Positive
Q
Percentage
smooth
With
Positive
Q
Percentage
small
Factors
With
Odd
Exp
aq
Pair
Count
i
odd
Exp
Small
Factor
set
other
all
A
all
Q
distinct
Big
Factors
Count
exp
i
result
i
set
all
Factors
all
Factors
i
count
i
all
Factors
i
result
i
count
i
insert
Position
i
insert
Position
i
copy
copy
str
i
count
i
p
jacobi
insert
Position
i
copy
copy
str
i
cbrt
sixth
Root
k
four
KN
four
Sqrt
K
sqrt4k
N
limit
a0
adjust
a
test
b
gcd
k
N
Term
N
min
test
Numbers
k
N
Str
k
k
N
a0
adjust
counts
a0
bits
test
Engine
cbrt
sixth
Root
k
four
KN
four
Sqrt
K
sqrt4k
N
limit
a
test
b
gcd
n
mod
a
Mod
k
Mod
last
Mod
lastk
Mod
lasta
Mod
test
Mod
four
K
Mod
N
Mod
test
Mod2
is
Quadratic
Residue
qr
Count
plot
Array
k2
qr
For
K
a2
test2
is
Quadratic
Residue2
qr
Count2
i
is
Quadratic
Residue2
c
analyzer
bits
test
Numbers
k
k
Max
With
Multiplier
i
count
k
Array
Tmp
sqrts
Tmp
sqrt
Invs
Tmp
refined
Index
array
Index
sqrt
K
count
cbrt
factor
k
Limit
k
Two
A
sixth
Root
Term
i
k
Limit2
i
a
Limit
a
Start
a
Step
i
k
sqrt4k
N
k
Plus
N
adjust1
adjust2
fourk
N
a
test
b
a
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
test
b
i
k
a
test
b
test
Numbers
lehman
factor
cbrt
sixth
Root
k
four
KN
four
Sqrt
K
sqrt4k
N
limit
a
test
b
gcd
k
N
Term
m
bits
test
Numbers
last
A
For
KN
k
N
last
A
List
elem
k
N
Str
total
A
Count
k
N
a
Success
Counts
kn
Success
Count
a
List
a
avg
A
Success
Count
kn
Start
k
N
row
i
total
Dropped
A
Count
kn
Start
k
N
dropped
A
List
k
N
row
i
a
Counts
n
last
A
Count
right
Exp
next
A
Count
cbrt
k
Limit
sixth
Root
Term
k
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
Plus
N
adjust1
adjust2
fourk
N
a
test
b
gcd
k
Two
A
k
a
test
b
k
Max
k
Factor
Strings
max
Factor
Str
Length
k
factor
String
len
bits
test
Numbers
factor
String
Mask
k
k
Str
factor
Str
counts
Str
successes
i
count
Str
i
success
Rate2Progressions
j
j
success
Rate
progressions
success
Sum
num
Count
k
Limit
k
success
Count
avg
Success
Count
progressions
test
Engine
cbrt
k
Limit
sixth
Root
Term
k
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
Plus
N
adjust1
adjust2
fourk
N
a
test
b
gcd
Nfactored
By
K
test
Numbers
ncount
previous
Best
N
Set
i
best
K
best
Number
Of
Factors
best
N
Set
k
N
Set
best
N
Set
Size
test
Engine
cbrt
k
Limit
sixth
Root
Term
k
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
Plus
N
adjust1
adjust2
fourk
N
a
test
b
gcd
k
Two
A
k
a
test
b
test
Numbers
sum
k
probs
entropy
k
p
divergence
k
m
test
Engine
cbrt
i
p
k
Limit
k
Two
A
sixth
Root
logged
Overflow
k
four
KN
four
Sqrt
K
sqrt4k
N
limit
a
test
b
gcd
test
Numbers
lehman
cbrt
factor
k
Limit
sixth
Root
Term
k
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
Plus
N
fourk
N
a
test
b
k
Two
A
k
a
test
b
test
Numbers
lehman
factor
successful
K
Count
successful
K
To
Factors
Map
cbrt
k
Limit
sixth
Root
Term
k
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
Plus
N
adjust1
adjust2
fourk
N
a
test
b
gcd
k
Two
A
k
a
test
b
test
Numbers
test
Engine
N
min
test
Numbers
N
Array
i
t0
t1
sum
m
bits
test
Engine
cbrt
k
Limit
sixth
Root
Term
k
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
Plus
N
adjust1
adjust2
fourk
N
a
test
b
gcd
test
Numbers
initial
Progressions
j
success
Rate2Progressions
avg
Success
Count
progressions
List
j
success
Rate
progressions
test
Engine
cbrt
k
Limit
sixth
Root
Term
k
fourk
N
sqrt
K
sqrt4k
N
a
Start
a
Limit
a
Step
k
N
k
Np1
adjust1
adjust2
adjust1
adjust2
k
Plus
N
adjust1
adjust2
a
test
b
gcd
test
Numbers
initial
Progressions
j
success
Rate2Progressions
avg
Success
Count
progressions
List
j
success
Rate
progressions
test
Engine
cbrt
factor
sixth
Root
k
four
KN
four
Sqrt
K
sqrt4k
N
limit
a
test
b
gcd
k
Max
i
sqrt
I
cbrt
factor
k
Limit
k
Two
A
sixth
Root
Term
k
sqrt4k
N
a
Start
a
Limit
a
Step
k
Plus
N
fourk
N
a
test
b
k
a
test
b
k
a
k
Plus
N
test
b
k
a
test
b
test
Numbers
lehman
factor
max
Q
Rest
Exponent
Str
smooth
X
List
aq
Pairs
N
pure
Power
factor1
pure
Power
N
Bits
N
dbl
ln
N
ln
Term
prime
Base
Size
dbl
prime
Base
Size
primes
Array
k
k
N
k
Big
t
Array
p
Max
proposed
Sieve
Array
Size
adjusted
Sieve
Array
Size
max
Q
Rest
factor
Test
sieve
Params
log
P
Array
pinv
Array
D
pinv
Array
L
i
base
Arrays
thread
Array
thread
Index
factor
kill
Start
thread
Index
log
P
Array
i
stack
Trace
poly
Report
sieve
Report
tdiv
Report
thread
Index
cc
Report
init
Poly
Duration
sieve
Duration
tdiv
Duration
p
Max
Bits
max
Q
Rest
Exponent
Str
max
Q
Rest
Exponent
Str
timer
qs
in
line
input
N
factors
duration
cmp1
mag
elem
Prec
max
Err
r
square
xpow
i
den
s
Element
internal
Scale
max
Err
r
pow2
i
s
Element
den
optimal
Degree
internal
Scale
root
series
lnx
Approximate
result
Magnitude
result
Scale
x
Bits
d
r
lnr
Term
ln2Precision
ln2Term
x
Mag
out
Mag
out
Precision
is
Reciprocal

x

x
Mag

x
Scale
x
Bits
d
r
lnr
Term
ln2Precision
ln2Term
result
x
Mag
out
Mag
out
Precision
is
Reciprocal

x

x
Mag

x
Scale
binary
Out
Precision
m
Max
m
s
b
Scale
b
agm
Mag
agm
Scale
agm
r
pi
t
ln2Scale
ln2Term
mln2
u
x
Bits
d
r
lnr
Term
ln2Precision
ln2Term
x
Mag
out
Mag
out
Precision
is
Reciprocal

x

x
Mag

x
Scale
x
Bits
d
r
lnr
Term
ln2Precision
ln2Term
result
internal
Scale
d
root
series
lnx
x
Bits
d
r
lnr
Term
ln2Precision
ln2Term
x
Mag
out
Mag
out
Precision
is
Reciprocal

x

x
Mag

x
Scale
x
Bits
d
r
lnr
Term
ln2Precision
ln2Term
result
t0
t1
y
scale
scale
scale
scale
scale
scale
scale
scale
input
x
scale
in
line
tok
x
Mag
error
Scale
max
Err
r
xpow
i
Fac
i
elem
internal
Scale
d
ln2Scale
ln2
d
Term
y
exp
Y
Scale
r
result
out
Mag
out
Scale
w
Mag
w
Mag
Bits
K
x
out
Mag
exp
X
Scale
exp
X
ex
y
Precision
y
ln2Scale1
optimal
D
d
ln2Scale2
ln2
y
exp
Y
Scale
exp
Y
r
y
out
Scale
t0
t1
input
x
scale
in
line
tok
out
Mag
out
Precision
out
Precision
Bits
a
Scale0
a
Mag
a
Precision
a
Scale1
b
Scale0
b
Mag
b
Precision
b
Scale1
internal
Scale
x
y
err
total
Shifts
t
min
Bits
shifts
a
Abs
b
Abs
low
high
high
Mag
low
Mag
mag
Diff
input
a
b
max
Scale
in
line
tok
t0
t1
agm
scale
k
lnk
Estimate
lnk
Magnitude
internal
Scale
minus
K
num
sum1
sum2
factorial
r
Max
r
rp1
rp1Square
den1
den2
elem1
elem2
ln
K
gamma
k
lnk
Estimate
lnk
Magnitude
internal
Scale
minus
K
num
sum2
factorial
r
Max
r
rp1
rp1Square
den2
elem2
ln
K
gamma
t0
t1
max
Scale
scale
scale
max
Err
i
internal
Scale
s
Element
four
i
eight
i
den
den
Magnitude
num
Scale
c1
c2
c3
c4
t0
dec
Prec
t1
factors
k
e
n
Max
results
n
big
N
left
right
median
index
array
bs
exact
Sqrt
lsb
ln
N
log3N
b
Index
N
reduced
b
floor
bth
Root
b
floor
bth
Root
exact
Sqrt
lsb
ln
N
a
Max
max
Exp
N
UBI
int
Len
rest
quotient
tmp
a
a
Index
exp
rem
b
Max
N
square
b2
b2Index
b
Index
b
b2p
mod
root
N
reduced
N
reduced
square
b2
b2Index
b
Index
b
b2p
mod
root
pow
Test
rng
bits
test
Set
i
r1
r2
pow
Test
rng
bits
test
Set
i
t0
t1
pow
Test
in
line
input
N
pure
Power
result
result
x
Scale
x
Unscaled
contained
Twos
missing
Twos
n
Div
Max
Int
x
Pow
Max
Int
ret
n
Int
result
Magnitude
result
Precision
x
Internal
x
Precision
cut
Precision
inner
Prec
result
x
Internal
x
Precision
cut
Precision
guess
x
Mag
shifts
Right
shifts
Modi
shifts
Modi
x
Shifted
dbl
root
dbl
guess
cmp
To
Zero
last
Guess
max
Allowed
Error
internal
Scale
error
i
big
im1
big
term1
pow
term2
x
max
Scale
t0
t1
i
scale
sign
bits
shifts
Right
sqrt
initial
Guess
initial
Guess
initial
Guess
sqrt
sqrt
big
cmp
N
long
sqrt
sqrt
big
cmp
last
Guess
cmp
test
Set
i
test
Num
bits
test
Set
lower
lower
Square
upper
upper
Square
bits
test
Set
t0
t1
hashset
lsb
bits
i
next
Mod
rest
isqrt
guess
x
Mag
shifts
Right
x
Shifted
dbl
sqrt
dbl
guess
cmp
To
Zero
last
Guess
max
Allowed
Error
internal
Scale
error
x
max
Scale
t0
t1
scale
ret
max
Result
Bit
Index
bit
Idx
next
cmp
guess
cmp
guess
Plus1
guess
Minus1
i
Minus1
i
big
i
Minus1
big
last
Guess
guess
cmp
guess
Plus1
guess
Minus1
i
Minus1
i
big
delta
guess
Plus1
guess
Minus1
bits
shifts
Right
shifts
Left
int
shifts
Left
frac
root
initial
Guess
initial
Guess
test
Set
i
test
Num
bits
test
Set
root
lin
Result
heron
Result
bits
test
Set
root
t0
t1
m
k
count
rest
rez
test
n
start
t
end
element
result
i
max
grid
n
row
k
limit
t0
t1
n
k
n
k
n
k
result
k
result
k
Factorial
k
C
C
num
den
result
i
max
grid
n
row
k
result
j
elem
xprod
xn
i
new
Stirlings
i
nkp
ret
Value
ret
i
elem
diag
i
next
Diag
n1
next
Diag
i
nof
Args
a1
a2
b
num
den
power
Term
div
Mod
gcd
sum
fraction
n
dn
i
diag
fac
a1
a2
b1
b2
num
den
gcd
div
Mod
sum
isum
fraction
bi
f
i1
dn
i2
i
diag
fac
mu
n
stirlings1
i
stirling1
n
start
i
k
i
k
i
k
i
k
ret
i
x
i
f
product
i
prime
q
p
n
number
Of
Tests
start
result
i
end
result
Luschny
i
k
Nall
i
ret
i
result
m
Bits
i
Max
i
left
Term
j
entry
complement
n
Odd
residues
count
m
i
out
Count
n
Odd
j
elem
j
elem
quadratic
Residue
Counts
quadratic
Residue
Counts
v2
a004215Entry
Counts
a004215Entry
Counts
v2
a004215Entry
Counts
v3
n
m
t0
quadratic
Residues
Mod2Pow
N
t1
quadratic
Residues
Mod2Pow
N
v2
a004215Entries
a004215Entries
v2
a004215Entries
v3
count
m
last
M
i
rem
quotient
m
gcd
a
Rest
k
list
m
a
list
m
a
p
Residues
last
List
last
M
i
next
List
j
elem
j
result
i
next
List
i
offset
m
last
M
i
rem
quotient
list
m
a
last
List
last
M
i
next
List
counts
v0
counts
v1
counts
v2
counts
v3
counts
v4
n
t0
t1
quadratic
Residues
Mod2Pow
N
v0
quadratic
Residues
Mod2Pow
N
v1
quadratic
Residues
Mod2Pow
N
v2
quadratic
Residues
Mod2Pow
N
v3
array
count
counts
counts
v2
counts
v3
counts
v4
n
m
t0
t1
quadratic
Residues
Mod
Pow
quadratic
Residues
Mod
Pow
v2
quadratic
Residues
Mod
Pow
v3
quadratic
Residues
Mod
Pow
v4
quadratic
Residues
k
quadratic
Residues
k
c
m
last
M
i
m
last
M
i
m
lsb
i
rest
list
m
a
a
Big
list
m
a
list
m
a
last
List
last
M
i
next
List
last
Count
last
M
i
j
next
Count
i
Odd
j
elem
complement
m
list
counts
counts
v2
counts
v3
n
m
quadratic
Residues
Mod
Pow
quadratic
Residues
Mod
Pow
v2
quadratic
Residues
Mod
Pow
v3
next
List
i
offset
counts
removed
Counts
last
Set
n
m
last
M
last
Powered
Up
next
Set
quotient
is
Exact
quadratic
Residues
Mod100
counts
even
Counts
n
m
quadratic
Residues
Mod2Pow
N
even
Quadratic
Residues
Mod2Pow
N
digits
test
test
Digits
test
test
Digits
test
i
current
Digits
exceeding
Digits
current
Scale
i
x
Square
minus1
sqrt
Term
angle
x
Square
minus1
sqrt
Term
angle
x
Square
plus1
sqrt
Term
angle
fraction
ln
Term
fraction
ln
Term
n
n
Str
x
T
n
of
x
n
n
Str
x
U
n
of
x
diff
rand
rand
normalized
diff
rand
normalized
internal
Scale
result
internal
Precision
result
result
Magnitude
result
Precision
ret
ret
result
result
Magnitude
result
Scale
dbl
Bit
Rep
is
Negative
e
M
result
dbl
Bit
Rep
is
Negative
e
M
result
str
mask
i
bit
list
tokenizer
token
sum
sum
prod
i
k
ith
Row
j
row
Size
expected
Row
Size
row
Sum
k
entry
n
row
Sums
m
row
Sum
n
number
list
m
k
entry
max
Width
buf
row
Buf
offset
i
bytes
i
j
b
Pos
b
int
Array
From
N
Shifts
i2
i
i
rem
divisor
long
current
Dividend
quot
i
divisor
long
rem
current
Dividend
quot
i
rem
divisor
long
current
Dividend
i
other
i
result
i
byte
Length
bytes
i
digit
b
Pos
N
bit
String
i
elem
filler
j
test
Set
i
test
Num
bits
test
Set
N
reverse
quotient
bits
test
Set
divisor
reference
Result
remainder
bits
test
Set
divisor
correct
Remainder
remainder
quotient
divisors
divisors
big
i
bits
test
Set
test
Set
UBI
t0
t1
result
result
list
tokenizer
token
result
n
d
n
d
n
n
d
d
n
d
gcd
multiplier
div
diff
other
prime
result
number
Of
Columns
row
Length
number
Of
Columns
column
Widths
j
j
str
Len
column
Masks
j
buffer
header
j
i
line
j
value
Str
n
number
list
nmax
resul
n
coef
nleft
o
lo
o
hi
r
lo
r
hi
a
b
a
b
r
lo
r
hi
a
hi
b
hi
a
lo
b
lo
lo
prod
med
term
hi
prod
r
hi
r
lo
a
hi
b
hi
a
lo
b
lo
lo
prod
med
prod1
med
prod2
med
term
hi
prod
r
hi
r
lo
a
hi
b
hi
a
lo
b
lo
lo
prod
med
prod1
med
prod2
med
term
hi
prod
carry
r
hi
r
lo
a
hi
a
lo
lo
prod
med
prod
med
term
hi
prod
carry
r
hi
r
lo
a
hi
b
hi
a
lo
b
lo
lo
prod
med
term
r
lo
p
lo
p
hi
q
r
r
hi
r
lo
s
t
b
hi
q
hat
mul
Result
u
hi
u
lo
w
lo
w
hi
qhat
t
rh
rl
rh
rl
RNG
i
a
hi
big
a
lo
big
b
hi
big
b
lo
big
a
hi
a
lo
b
hi
b
lo
a128
b128
sum128
sum128Big
sum
Big
sum128
v2
sum128Big
v2
prod128
prod128Big
correct
Prod
RNG
NCOUNT
a
arr
b
arr
a128
arr
b128
arr
i
t0
i
t1
i
i
i
factors
divisors
test
small
Divisors
all
Divisors
i
biggest
Small
Divisor
small
Divisor
factorizer
factors
primes
powers
divisors
stack
divisor
i
power
i
power
reduced
Powers
primes
max
Powers
divisors
stack
empty
Powers
i
powers
divisor
i
power
i
max
Power
power
enhanced
Powers
divisors
d
max
small
Divisors
d
factorizer
factors
d
max
primes
max
Powers
divisors
stack
empty
Powers
i
powers
divisor
i
power
i
max
Power
power
enhanced
Powers
sum
factorizer
factors
entry
Sums
p
exp
entry
Sum
summand
i
product
Of
Entry
Sums
factorizer
factors
count
test
factorizer
factors
small
Divisors
n
n
fac
sigma
t0
t1
factors
n
fac
factors
t2
div
Set3
t3
div
Set4
t4
div
Set5
t5
div
Count1
t6
div
Count2
t7
n
fac
t1
factors
div
Set2
t2
t0
t1
rng
NCOUNT
bits
test
Set
i
n
segment
Size
sqrt
is
Composite
i
j
array
Size
double
Primes
next
primes
Count
s
n
low
sieve
Is
Composite
high
i
j
k
nn
nn
Max
limit
start
callback
sieve
limit
is
Composite
i
j
n
callback
limit
start
sieve
count
correct
Callback
correct
Sieve
nth
Prime
Upper
Bound
correct
Count
correct
Result
segmented
Callback
segmented
Sieve
segmented
Result
primes
Array
count
start
primes
Array
odd
Primes
Count
i
p
nth
Prime
Upper
Bound
callback
segmented
Sieve
nth
Prime
Upper
Bound
count
Upper
Bound
next
Count
nth
Prime
Upper
Bound
segmented
Sieve
primes
restwins
inverses
pc
inc
res
pc
mc
inv
r
n
B
maxpairs
range
pg
md
rscnt
res
posn
sqrt
N
kmax
prms
modk
r
k
prm
r
prime
prod
bit
r
kpm
ri
modk
r
hi
k
r
nextp
r
hi
r
lo
j
k
r
r
inv
ro
ko
ri
ki
kmin
kmax
sum
Kn
hi
tp
seg
nextp
j
k
upk
cnt
m
ts
pairscnt
twinscnt
lo
range
te
stealing
Pool
sieve
Task
callback
indx
t1
last
twin
Kn
t2
user
Input
stop
start
tmp
end
div
div2
y
t0
t1
t2
t3
t4
scale
exp
Gamma
can
Iter
m
can
Entry
n
n
flt
lnln
n
robin
factors
sigma
diff
t0
t1
t2
t2b
t3
t4
t5
t6
scale
exp
Hn
Precision
can
Iter
m
can
Entry
n
harmonic
lb
exp
Hn
ln
Hn
hs
Expr
factors
sigma
diff
factors
i
i
p
i
unrolled
Limit
