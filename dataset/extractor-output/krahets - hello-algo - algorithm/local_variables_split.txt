dp
i
a
b
i
tmp
n
res
count
n
res
n
MAX
dp
a
i
a
n
MAX
dp
i
a
coins
amt
res
no
yes
no
yes
n
dp
i
c
n
dp
i
c
wgt
val
cap
n
res
mem
up
left
up
left
n
m
dp
j
i
i
j
n
m
dp
j
i
j
grid
n
m
res
mem
n
dp
i
n
a
b
i
tmp
cost
res
choices
state
res
n
res
count
mem
n
res
n
dp
i
c
n
dp
i
c
wgt
val
cap
res
dp
i
n
res
insert
delete
replace
insert
delete
replace
n
m
dp
i
j
i
j
n
m
dp
j
i
leftup
j
temp
s
t
n
m
res
mem
n
dp
i
i
a
n
dp
i
a
coins
amt
res
i
j
m
i
j
m
target
nums
index
i
j
m
i
j
m
nums
index
index
i
target
nums
index
head
node
target
nums
map
i
index
head
map1
node
size
i
j
size
dic
i
nums
target
res
i
i
j
nums
index
node
num
node
res
i
queue
peek
pop
size
is
Empty
node
val
f
Next
r
Prev
node
res
i
deque
peek
First
peek
Last
pop
Last
pop
First
size
is
Empty
queue
peek
pop
size
is
Empty
deque
peek
First
peek
Last
pop
Last
pop
First
size
is
Empty
stack
peek
pop
size
is
Empty
node
num
node
res
i
stack
peek
pop
size
is
Empty
stack
peek
pop
size
is
Empty
rear
num
res
i
j
capacity
queue
peek
pop
size
is
Empty
i
rear
num
num
last
res
i
j
deque
peek
First
peek
Last
pop
Last
pop
First
size
is
Empty
root
n1
n2
n3
n4
n5
P
cur
cur
pre
node
cur
pre
child
tmp
bst
nums
node
res
i
res
res
res
arr
root
abt
i
l
r
p
res
child
grand
Child
child
grand
Child
balance
Factor
child
temp
cur
avl
Tree
node
queue
list
node
root
list
a
b
n
res
i
j
res
cap
ht
res
items
i
res
wgt
val
cap
res
i
count
coins
amt
res
random
Index
random
Num
res
i
i
i
count
i
i
arr
nums
random
Num
index
numbers
nums
num
count
i
nums1
j
num
j
size
arr
i
nums
num
i
n1
P
n1
i
index
n0
n1
n2
n3
n4
node
index
i
state
start
res
nums
target
res
i
state
start
res
nums
target
res
root
res
vals
root
vals
i
choice
res
nums
res
i
state
total
res
nums
target
res
copy
State
col
diag1
diag2
state
i
row
j
cols
diags1
diags2
res
n
res
root
vals
duplicated
i
choice
res
nums
res
root
vals
res
stack
res
i
res
n
res
a
b
nums
node
i
c
i
nums
nodes
i
map
i
num
Matrix
num
List
i
tmp
j
nums
root
n
root
nums
i
res
i
i
i
n
nums
index
count
size
i
count
i
count
count
i
j
count
i
j
tmp
count
base
i
j
count
count
i
count
i
n
count
nums
i
res
i
res
i
res
i
res
i
j
n
res
res
Str
root
res
vets
i
vals
dum
head
list
prev
str
trunk
list
root
pan
n
A
B
C
root
m
inorder
Map
i
root
preorder
inorder
root
m
n
target
nums
index
res
visited
v
edges
graph
res
res
visited
que
vet
v
edges
graph
res
tmp
v
edges
graph
v5
n
new
Row
j
vertices
edges
graph
map
name
i
index
bucket
index
bucket
pair
index
bucket
buckets
Tmp
i
res
map
name
i
index
index
pair
pair
index
index
pair
Set
key
Set
value
Set
map
name
index
first
Tombstone
index
index
index
buckets
Tmp
hashmap
name
num
hash
Num
bol
hash
Bol
dec
hash
Dec
str
hash
Str
arr
hash
Tup
obj
hash
Obj
hash
MODULUS
hash
MODULUS
hash
MODULUS
hash
MODULUS
key
hash
i
tmp
p
val
l
r
ma
queue
max
Heap
peek
val
size
is
Empty
heap
i
i
nums
k
res
val
min
Heap
max
Heap
peek
size
is
Empty
tmp
i
j
pivot
tmp
med
i
j
pivot
tmp
i
j
pivot
nums
nums1
nums2
i
base
j
nums
tmp
i
j
k
mid
nums
k
buckets
i
i
i
nums
m
counter
i
num
j
m
counter
i
n
res
i
num
i
nums
nums1
n
i
k
j
temp
nums
l
r
ma
temp
i
i
tmp
nums
counter
n
i
d
i
res
i
d
j
i
m
exp
nums
i
j
tmp
i
flag
j
tmp
nums
nums1
n
MAX
dp
n
MAX
dp
coins
amt
res
dp
n
res
count
mem
n
res
n
dp
n
a
b
tmp
cost
res
count
n
res
no
yes
no
yes
n
dp
n
dp
weight
val
cap
n
res
mem
choices
state
res
n
res
up
left
up
left
n
m
dp
n
m
dp
grid
n
m
res
mem
insert
delete
replace
insert
delete
replace
n
m
dp
n
m
dp
leftup
temp
s
t
n
m
res
mem
n
dp
n
dp
wgt
val
cap
res
dp
a
b
tmp
n
res
n
dp
n
dp
coins
amt
res
target
nums
index
head
node
i
j
m
i
j
m
nums
index
index
size
size
dic
nums
target
res
i
j
m
i
j
m
target
nums
index
i
i
j
nums
index
target
nums
map
index
head
map1
node
stack
peek
pop
size
is
Empty
node
val
f
Next
r
Prev
node
res
deque
peek
First
peek
Last
pop
Last
pop
First
size
is
Empty
queue
peek
pop
size
is
Empty
rear
num
res
capacity
queue
peek
pop
size
is
Empty
deque
peek
First
peek
Last
size
is
Empty
node
num
node
res
stack
peek
pop
size
is
Empty
val
stack
peek
pop
size
is
Empty
node
num
node
res
queue
peek
pop
size
is
Empty
rear
num
num
last
res
deque
peek
First
peek
Last
pop
Last
pop
First
size
is
Empty
cur
cur
pre
node
cur
pre
child
tmp
bst
nums
node
res
res
res
res
arr
root
abt
i
l
r
p
res
queue
list
node
root
list
n1
n2
n3
n4
n5
P
child
grand
Child
child
grand
Child
balance
Factor
Int
child
temp
cur
avl
Tree
node
root
i
j
res
cap
ht
res
items
res
wgt
val
cap
res
a
b
n
res
i
count
coins
amt
res
random
random
Index
random
Num
res
count
arr
nums
random
Num
index
numbers
nums
num
count
nums1
num
arr
nums
num
n1
P
n1
index
n0
n1
n2
n3
n4
node
index
duplicated
choice
res
nums
res
state
start
res
nums
target
res
root
res
choices
state
total
res
nums
target
res
root
choice
res
nums
res
state
start
res
nums
target
res
root
copy
State
diag1
diag2
state
row
cols
diags1
diags2
res
n
res
root
res
res
i
res
i
res
n
res
res
Str
a
b
nums
node
c
nums
nodes
map
num
Matrix
num
List
tmp
nums
root
n
root
nums
index
n
nums
index
res
stack
res
res
n
res
a
count
size
count
count
count
count
count
bas
count
count
count
n
count
nums
dum
head
list
head
root
res
vets
vals
list
prev
str
trunk
list
tree
new
Queue
list
tree
m
n
target
nums
index
root
m
inorder
Map
root
preorder
inorder
root
pan
n
A
B
C
tmp
v
edges
graph
v5
res
visited
que
vet
v
edges
graph
res
res
visited
v
edges
graph
res
n
new
Row
vertices
edges
graph
hash
MODULUS
hash
MODULUS
hash
MODULUS
hash
MODULUS
key
hash
index
index
index
buckets
Tmp
res
map
name
map
name
index
index
pair
pair
index
index
pair
Set
key
Set
value
Set
map
name
index
first
Tombstone
index
index
index
buckets
Tmp
map
name
num
hash
Num
bol
hash
Bol
dec
hash
Dec
str
hash
Str
arr
hash
Tup
obj
hash
Obj
val
min
Heap
max
Heap
peek
size
is
Empty
list
heap
nums
k
res
size
p
val
l
r
ma
queue
max
Heap
peek
val
size
is
Empty
flag
nums
nums1
tmp
i
j
k
mid
nums
i
j
pivot
med
i
j
pivot
i
j
pivot
nums
nums1
nums2
m
counter
i
m
counter
n
res
num
nums
nums1
l
r
ma
nums
counter
n
d
res
d
j
m
nums
k
buckets
i
j
nums
n
k
nums
bas
j
nums
