inputs
test
Coverage
get
Min
Weight
Cost
compute
Matching
Cost
solve
next
Permutation
get
First
swap
get
Implementations
create
Empty
Matrix
add
Undirected
Weighted
Edge
test
Small
Graph
odd
Size
test
Smallest
Matrix1
test
Small
Matrix1
test
Small
Matrix2
test
Medium
Matrix1
test
Medium
Matrix2
test
Medium
Graph
even
Size
from
Slides
test
Medium
Graph
even
Size
non
Perfect
Matching
From
Slides
test
Negative
Edge
Weights
test
Negative
Edge
smaller
Than
INF
Weights
test
Disjoint
Graph
test
Harder
Wmcm
from
Slides
test
Matching
Outputs
Unique
Nodes
test
Matching
And
Cost
Are
Consistent
test
Against
Brute
Force
large
Values
test
Against
Brute
Force
small
Values
random
Fill
Symmetric
Matrix
assert
Optimal
Matching
test
Coin
Change
test
Coin
Change
Selected
Coins
test
Coin
Change
Space
Efficient
Selected
Coins
setup
suffix
Array
Length
lcs
Unique
Characters
increasing
LCP
Test
lcp
Test1
lcp
Test2
sa
Construction
query
Result
Test
min
Query
max
Query
sum
Query
mult
Query
gcd
gcd
Query
test
All
Operations
simple
small
Range
Random
Array
Tests
random
Array
Tests
verify
Index
Is
Always
Leftmost
Position
When
There
Are
Collisions
verify
Index
Is
Always
Leftmost
Position
randomized
gen
Rand
Array
test
Index
test
Index
With
Non
Existing
Value
test
Insert
Greater
Than
Max
Value
test
Insert
Lesser
Than
Min
Value
test
Simple
Functionality
test
Size
test
Find
test
Duplicate
test
Remove
Non
Existing
test
Remove
Head
Tail
test
Dimensions
Zero
test
Dimensions
Negative
test
Insert
test
Insert
Null
test
Insert
Mismatch
Dimensions
test
Search
test
Search
Null
test
Search
Mismatch
Dimensions
test
Find
Min
test
Find
Min
Out
Of
Bounds
test
Find
Min
Negative
test
Delete
Empty
test
Delete
Root
test
Delete
test
Delete
Null
test
Delete
Mismatch
Dimensions
hash
Code
equals
setup
test
Null
Key
test
Illegal
Creation1
test
Illegal
Creation2
test
Illegal
Creation3
test
Legal
Creation
test
Updating
Value
assert
Capacity
Is
Power
Of
Two
test
Table
Size
test
Iterator
test
Concurrent
Modification
Exception
test
Concurrent
Modification
Exception2
random
Remove
remove
Test
remove
Test
Complex1
test
Random
Map
Operations
random
Iterator
Tests
rand
Int
gen
Rand
List
gen
Unique
Rand
List
main
test
Linear
Probing
test
Quadratic
Probing
test
Double
Hashing
test
Hash
Map
Speed
setup
test
Illegal
Creation1
test
Illegal
Creation2
test
Illegal
Creation3
test
Legal
Creation
test
Updating
Value
test
Iterator
test
Concurrent
Modification
Exception
test
Concurrent
Modification
Exception2
random
Remove
remove
Test
test
Random
Map
Operations
random
Iterator
Tests
rand
Int
gen
Rand
List
gen
Unique
Rand
List
hash
Code
equals
setup
test
Null
Key
test
Illegal
Creation1
test
Illegal
Creation2
test
Illegal
Creation3
test
Legal
Creation
test
Updating
Value
test
Iterator
test
Concurrent
Modification
Exception
test
Concurrent
Modification
Exception2
random
Remove
remove
Test
remove
Test
Complex1
test
Random
Map
Operations
random
Iterator
Tests
rand
Int
gen
Rand
List
gen
Unique
Rand
List
hash
Code
equals
setup
test
Illegal
Creation1
test
Illegal
Creation2
test
Illegal
Creation3
test
Legal
Creation
test
Updating
Value
test
Iterator
test
Concurrent
Modification
Exception
test
Concurrent
Modification
Exception2
random
Remove
remove
Test
remove
Test
Complex1
test
Random
Map
Operations
random
Iterator
Tests
rand
Int
gen
Rand
List
gen
Unique
Rand
List
int
Hash
vector
Hash
string
Hash
compute
Hash
hash
Code
hash
Code2
equals
setup
test
Rect
Intersection
test
Rect
Containment
test
Point
Containment
test
Counting
Points
brute
Force
Count
randomized
Query
Tests
setup
test
Empty
Queue
testoffer
One
Element
test
All
test
Peek
One
Element
testpoll
One
Element
test
Random
inputs
test
Empty
Queue
test
Poll
On
Empty
test
Peek
On
Empty
test
Offer
test
Peek
test
Poll
test
Exhaustively
setup
test
Empty
test
Heap
Property
test
Priority
Queue
Size
Param
test
Priority
Random
Operations
test
Clear
test
Removing
Duplicates
gen
Rand
Array
gen
Rand
List
gen
Unique
Rand
List
setup
test
Empty
test
Heap
Property
test
Heapify
test
Clear
test
Containment
test
Containment
Randomized
sequential
Removing
test
Removing
test
Removing
Duplicates
test
Randomized
Polling
test
Randomized
Removing
test
PQ
Reusability
gen
Rand
Array
gen
Rand
List
gen
Unique
Rand
List
setup
test
Empty
test
Heap
Property
test
Heapify
test
Clear
test
Containment
test
Containment
Randomized
sequential
Removing
test
Removing
test
Removing
Duplicates
test
Randomized
Polling
test
Randomized
Removing
test
PQ
Reusability
gen
Rand
Array
gen
Rand
List
gen
Unique
Rand
List
setup
test
Illegal
Size
Of
Negative
One
test
Illegal
Size
Of
Zero
test
Legal
Size
test
Contains
Valid
Key
test
Contains
Invalid
Key
test
Duplicate
Keys
test
Update
Key
Value
test
Test
Decrease
Key
test
Test
Decrease
Key
No
Update
test
Test
Increase
Key
test
Test
Increase
Key
No
Update
test
Peek
And
Poll
Min
Index
test
Peek
And
Poll
Min
Value
test
Insertion
And
Value
Of
test
Operations
test
Random
Insertions
And
Polls
test
Random
Insertions
And
Removals
gen
Rand
Array
sort
Pairs
By
Value
compare
gen
Unique
Rand
List
setup
test
String
Set
All
Subsets
test
String
Set
All
Subsets
Failure
contains
Tests
rand
Num
random
String
hash
Code
equals
setup
test
Add
Remove
randomized
Set
Test
randomized
Set
Test2
t
gen
Rand
List
gen
Unique
Rand
List
get
Root
splay
Insert
Delete
Search
insert
Search
find
Max
splay
Tree
Priority
Queue
Consistency
Test
add
pre
Order
in
Order
post
Order
level
Order
setup
test
Is
Empty
test
Size
test
Height
test
Add
test
Remove
test
Contains
concurrent
Modification
Error
Pre
Order
concurrent
Modification
Error
In
Order
Order
concurrent
Modification
Error
Post
Order
concurrent
Modification
Error
Level
Order
concurrent
Modification
Error
Removing
Pre
Order
concurrent
Modification
Error
Removing
In
Order
Order
concurrent
Modification
Error
Removing
Post
Order
concurrent
Modification
Error
Removing
Level
Order
random
Remove
Tests
gen
Rand
List
validate
Tree
Traversal
test
Pre
Order
Traversal
test
In
Order
Traversal
test
Post
Order
Traversal
test
Level
Order
Traversal
setup
test
Empty
List
test
Remove
First
Of
Empty
test
Remove
Last
Of
Empty
test
Peek
First
Of
Empty
test
Peek
Last
Of
Empty
test
Add
First
test
Add
Last
test
Add
At
test
Remove
First
test
Remove
Last
test
Peek
First
test
Peek
Last
test
Peeking
test
Removing
test
Remove
At
test
Clear
test
Randomized
Removing
test
Randomized
Remove
At
test
Randomized
Index
Of
test
To
String
gen
Rand
List
gen
Unique
Rand
List
set
Up
tear
Down
empty
When
Created
no
Longer
Empty
After
Add
singleton
Queue
Returns
Sole
Item
On
Poll
is
Empty
After
Sole
Element
Removed
returns
Ordered
Items
insert
Single
Item
insert
Same
Values
And
Returns
Ordered
Items
returns
Ordered
Items
From
Random
Insert
add
All
And
Contins
Item
clear
Queue
offer
Peek
And
Element
element
Throws
Exception
test
Bad
Trie
Delete1
test
Bad
Trie
Delete2
test
Bad
Trie
Delete3
test
Bad
Trie
Insert
test
Bad
Trie
Count
test
Bad
Trie
Contains
test
Contains
test
Count
test
Insert
test
Clear
test
Delete
test
Edge
Cases
setup
simple
Test
test
Random
Range
Assign
Updates
With
Sum
Range
Queries
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
test
All
Function
Combinations
get
Rand
Value
By
Test
Type
generate
Random
Array
By
Test
Type
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Mul
gcd
brute
Force
Gcd
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
setup
test
Illegal
Segment
Tree
Creation1
test
Illegal
Segment
Tree
Creation2
test
Sum
Query
test
All
Sum
Queries
brute
Force
Sum
setup
simple
Test
test
Random
Range
Sum
Updates
With
Sum
Range
Queries
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
setup
test
Random
Range
Assign
Updates1With
Min
Range
Queries1
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
setup
test
Sum
Query
Sum
Update
Simple
test
Sum
Query
Sum
Update
Range
Update
test
Sum
Query
Assign
Update
simple
test
Sum
Query
Mul
Update
simple
min
Query
Sum
Updates
simple
max
Query
Sum
Update
simple
maxmin
Query
Mul
Update
simple
max
Query
Mul
Update
simple
min
Query
Mul
Update
simple
test
All
Function
Combinations
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
setup
simple
Test
simple
Test2
simple
Test3
simple
Test4
simple
Test5
test
Random
Range
Sum
Updates
With
Sum
Range
Queries
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
setup
simple
Test
test
Random
Range
Sum
Updates
With
Sum
Range
Queries
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
setup
simple
Test
test
Random
Range
Sum
Updates
With
Sum
Range
Queries
brute
Force
Sum
brute
Force
Min
brute
Force
Max
brute
Force
Sum
Range
Update
brute
Force
Mul
Range
Update
brute
Force
Assign
Range
Update
test
Num
Components
test
Component
Size
test
Connectivity
test
Size
test
Bad
Union
Find
Creation
inputs
test
Empty
Stack
test
Pop
On
Empty
test
Peek
On
Empty
test
Push
test
Peek
test
Pop
test
Exhaustively
setup
test
Null
Insertion
test
Tree
Contains
Null
Left
Left
Case
test
Left
Right
Case
test
Right
Right
Case
test
Right
Left
Case
random
Treap
Operations
gen
Rand
List
rand
Value
setup
test
Null
Insertion
test
Tree
Contains
Null
test
Left
Left
Rotation
test
Left
Right
Rotation
test
Right
Left
Rotation
test
Right
Right
Rotation
test
Left
Uncle
Case
test
Right
Uncle
Case
interesting
Case1
test
Randomized
Value
Insertions
Against
Tree
Set
test
Removal
test
Null
Removal
test
Number
Doesnt
Exist
random
Remove
Tests
test
Tree
Height
assert
Null
Children
assert
Correct
Parent
Links
assert
Binary
Search
Tree
Invariant
validate
Parent
Links
Are
Correct
gen
Rand
List
rand
Value
setup
test
Null
Insertion
test
Null
Removal
test
Tree
Contains
Null
test
Left
Left
Case
test
Left
Right
Case
test
Right
Right
Case
test
Right
Left
Case
test
Randomized
Balance
Factor
Test
validate
Balance
Factor
Values
test
Randomized
Value
Insertions
Against
Tree
Set
test
Tree
Height
random
Remove
Tests
gen
Rand
List
rand
Value
setup
test
Interval
Sum
Positive
Values
test
Interval
Sum
Negative
Values
test
Interval
Sum
Negative
Values2
test
Randomized
Static
Sum
Queries
do
Random
Range
Query
test
Randomized
Set
Sum
Queries
test
Reusability
low
Bound
high
Bound
rand
Value
test
Illegal
Creation
gen
Rand
List
get
update
Range
setup
test
Illegal
Creation
test
Fenwick
Tree
Range
Update
Point
Query
Negative
Numbers
test
Fenwick
Tree
Range
Update
Point
Query
Simple
test
Fenwick
Tree
Range
Update
Point
Query
Simple2
test
Fenwick
Tree
Range
Update
Point
Query
Repeated
Addition
test
Fenwick
Tree
Range
Update
Point
Query
Overlapping
Ranges
low
Bound
high
Bound
rand
Value
test
Empty
Case
convex
Hull
Redundant
Points
unique
Points
On
Hull
test3Points
test2Points
test1Point
repeated
Single
Point
Minimum
Cost
Convex
Polygon
Triangulation
Basic
Test
Minimum
Cost
Convex
Polygon
Triangulation
Invalid
Test
Minimum
Cost
Convex
Polygon
Triangulation
Convex
setup
test
Null
Graph
Input
test
Singleton
Graph
test
Two
Node
Graph
test
Three
Node
Graph
test
Shortest
Path
Against
Bellman
Ford
generate
Random
Graph
create
Graph
add
Edge
test
Tree
Case
graph
With
Cycles
Test
test
Graph
In
Slides
test
Disconnected
Graph
get
Sorted
Bridges
test
No
Terminal
Nodes
Gives
Zero
test
One
Terminal
Node
Gives
Zero
test
Tree
Graph
test
Cycle
Graph
test
Steiner
create
Graph
add
Undirected
Edge
get
Graph1
test
Simple
Rooting1
simple
Test1
singleton
two
Node
Tree
simple
Test2
simple
Test3
simple
Test4
test
Tree
Center
Vs
Other
Impl
generate
Random
Tree
create
First
Tree
From
Slides
test
Lca
Tree
From
Slides1
test
Lca
Tree
From
Slides2
test
Lca
Of
The
Same
Node
Is
Itself
randomized
Lca
Queries
Vs
Other
Impl
generate
Random
Tree
create
First
Tree
From
Slides
test
Lca
Tree
From
Slides1
test
Lca
Tree
From
Slides2
test
Lca
Of
The
Same
Node
Is
Itself
empty
Tree
Throws
Exception
singleton
Trees
Are
Isomorphic
test
Two
Node
Tree
test
Small
test
Similar
Chains
simple
Test
different
Number
Of
Nodes
test
Isomorphism
Equivilance
Against
Other
Impl
generate
Random
Tree
simple
Test1
singleton
two
Node
Tree
simple
Test2
simple
Test3
simple
Test4
test
Singleton
test
Two
Node
Tree
test
Small
test
Similar
Chains
test
Slides
Example
t
create
Graph
add
Edge
test
Tree
Case
test
Closed
Cycle
test
Star
Graph
With
Root
As
Middle
test
Star
Graph
With
Root
Not
In
Middle
test
Bi
Connected
Graph
test
Butterfly
Graph
test
Butterfly
Graph
With
Three
Wings
test
Disconnected
Graph
test
Single
Node
Graph
test
Two
Node
Graph
test
Multi
Cycle
Graph
test
Three
Node
Line
Graph
create
Graph
add
Edge
null
Graph
Constructor
singleton
Case
test
Two
Disjoint
Components
test
Butterfly
Case
test
Disjoint
Tree
test
Disjoint
Tree
From
Hackerrank
test
First
Graph
In
Slides
test
Last
Graph
In
Slides
is
Scc
setup
create
Matrix
add
Random
Edges
test
Directed
Graph
test
Negative
Cycle
Graph
test
Apsp
Against
Bellman
Ford
non
Negative
Edge
Weights
test
Apsp
Against
Bellman
Ford
with
Negative
Edge
Weights
test
Path
Reconstruction
Bellman
Ford
non
Negative
Edge
Weights
test
Simple
Negative
Cycle
Detection
test
Negative
Cycle
Propagation
test
Single
Node
Negative
Cycle
Detection
find
is
Topsort
Ordering
cycle
In
Graph
verify
Is
Topsort
Ordering
random
Test
random
Tests
set
Up
test
Singleton
test
Two
Node
Graph
test
Triangle
Graph
test
Disjoint
Bipartite
Graph
Components
test
Square
Bipartite
Graph
test
Square
Bipartite
Graph
With
Additional
Edge
set
Up
create
All
Solvers
add
Edge
assert
Flow
And
Cost
test
Negative
Cycle1
set
Up
create
All
Solvers
add
Edge
assert
Flow
line
Graph
Test
test
Disconnected
Graph
test
Small
Flow
Graph
classic
Network
evil
Network1
test
Medium
Size
Flow
Graph
test
Flow
In
Equals
Flow
Out
create
Graph
test
Simple
Satisfiable
test
Simple
Impossible
test
Impossible
Four
Node
Cycle
set
Up
initialize
Empty
Graph
add
Directed
Edge
verify
Eulerian
Path
test
Empty
Graph
test
Graph
With
No
Edges
test
Graph
All
Equal
Edge
Frequency
test
Graph
All
Equal
Edge
Frequency2
test
Invalid
Graph1
test
Invalid
Graph2
test
Invalid
Graph3
test
Invalid
Graph4
test
One
Node
Self
Loop
Graph
test
One
Node
Multiple
Self
Loops
Graph
test
Multi
Part
Disconnected
Graph
test
Multi
Part
Disconnected
Graph2
test
Simple
Graph
test
Path
Unique
Start
And
End
Nodes
test
Graph
With
Unique
Path
test
Somewhat
Complex
Path
create
Graph
add
Edge
test
Tree
Case
graph
With
Cycles
Test
test
Graph
In
Slides
test
Disconnected
Graph
get
Sorted
Bridges
create
Graph
add
Edge
null
Graph
Constructor
singleton
Case
test
Two
Disjoint
Components
test
Butterfly
Case
test
Disjoint
Tree
test
Disjoint
Tree
From
Hackerrank
test
First
Graph
In
Slides
test
Last
Graph
In
Slides
is
Scc
test
Tsp
Recursive
Invalid
Start
Node
test
Tsp
Iterative
Invalid
Start
Node
test
Tsp
Recursive
Non
Square
Matrix
test
Tsp
Iterative
Non
Square
Matrix
test
Tsp
Recursive
Small
Graph
test
Tsp
Iterative
Small
Graph
test
Tsp
small1
test
Dp
Vs
Bf
test
Generated
Tour
test
Different
Starting
Nodes
test
Tsp
Recursive
Performance
test
Tsp
Iterative
Performance
random
Fill
Dist
Matrix
get
Tour
Cost
test
Set
Bit
test
Power
Of
Two
test
Clear
Bit
range
Update
Test1
range
Update
Test2
random
Range
Addition
Tests
slow
Range
Add
random
Fill
rand
Value
small
Window
Test
randomized
Sliding
Window
Test
fill
Random
randomized
Test
get
Sorting
Algorithm
verify
Sorting
Algorithms
small
Positive
Integers
Only
verify
Sorting
Algorithms
small
Negative
Integers
Only
test
Quick
Select
test
Get
Max
test
Calculate
Number
Of
Digits
random
Radix
Sort
small
Numbers
random
Radix
Sort
large
Numbers
rand
Int
setup
should
Return
Empty
Array
On
Null
Or
Empty
Input
text
Contains
A
Single
Character
Repeated
text
Contains
All
Distinct
Characters
text
Contains
Repeated
Pattern
setup
should
Return
Empty
List
On
Null
Input
should
Return
One
Occurrence
should
Return
Multiple
Occurrences
should
Return
Empty
For
Pattern
Length
Larger
Then
Text
should
Return
Dynamic
String
get
Occurrences
Brute
Force
generate
Random
String
get
Longest
Common
Substrings
verify
Multiple
K
Values
multiple
K
Value
Test1
multiple
K
Value
Test2
multiple
K
Value
Test3
multiple
K
Value
Test4
multiple
K
Value
Test5
no
Longest
Common
Substring
Test
simple1
simple2
simple3
simple4
simple5
k
Value
Test
k
Value
Test2
k
Value
Test3
k
Value
Test4
small
Strings
random
Lcss
With
Brute
Force
Solver1
random
Lcss
With
Brute
Force
Solver2
random
Lcss
With
Brute
Force
Solver3
create
Random
Strings
create
String
test
Large
Alphabet
multiply
mult
transform
main
sieve
main
gcd
main
eulers
Totient
prime
Factorization
pollard
Rho
gcf
is
Prime
main
set
Bit
is
Not
Set
is
Prime
prime
Sieve
main
egcd
is
Prime
main
gcd
egcd
mod
Inv
mod
Pow
main
rand
Long
rand
Long
totient
sieve
main
prime
Factorization
pollard
Rho
gcd
is
Prime
main
gcf
are
Coprime
main
gcd
lcm
main
egcd
mod
Inv
main
eliminate
Coefficient
reduce
crt
prime
Factorization
pollard
Rho
egcd
gcf
is
Prime
compute
big
Integer
N
Choose
R
Mod
P
main
fft
poly
Mult
pad
ifft
plus
minus
times
scalar
conjugate
f
discrete
Ternary
Search
main
binary
Search
main
interpolation
Search
main
ternary
Search
main
main
lps
lps
get
Min
Weight
Cost
get
Min
Weight
Cost
Matching
solve
Recursive
f
solve
reconstruct
Matching
get
Bit
Position
main
include
test1
test2
lcs
main
main
solution1
f
main
solution1
print
Matrix
solution2
rob
find
Robbed
Houses
main
init
iterative
Solution
recursive
Solution
f
main
min
edit
Distance
f
micah
Edit
Distance
main
min
f
f
main
Program
main
test2
test1
ok
main
query
num
Tilings
f
make
State
main
get
Min
Weight
Cost
get
Matching
edit
Distance
main
min
edit
Distance
f
main
main
lis
main
maximum
Subarray
Value
lcs
main
knapsack
main
unbounded
Knapsack
unbounded
Knapsack
Space
Efficient
main
create
Infinite
Value
Matching
Cost
update
Matching
Cost
is
Better
Matching
Cost
to
String
set
Cost
Matrix
get
Min
Weight
Cost
get
Matching
solve
f
reconstruct
Matching
get
Bit
Position
main
test
coin
Change
coin
Change
Space
Efficient
coin
Change
Recursive
coin
Change
Recursive
p
p
main
example4
example1
example2
example3
josephus
main
get
Min
Weight
Cost
get
Matching
solve
reconstruct
Matching
get
Bit
Position
main
test
get
Text
Length
get
Sa
get
Lcp
Array
build
Suffix
Array
build
Lcp
Array
to
Int
Array
construct
kasai
to
String
compare
To
to
String
construct
main
construct
main
compare
To
to
String
construct
main
main
query
Min
query
Min
Index
init
print
Table
query
query
Index
min
Query
Index
max
Query
Index
sum
Query
mult
Query
query
main
example1
example
From
Slides
example3
set
Head
Tail
size
find
search
search
insert
insert
remove
decrease
Rank
increase
Rank
modify
Rank
get
Index
compare
To
compare
To
get
Dimensions
get
Root
Point
insert
insert
Recursive
search
search
Recursive
find
Min
find
Min
Recursive
delete
delete
Recursive
Root
delete
Recursive
Search
delete
Recursive
Extract
setup
Probing
probe
adjust
Capacity
next
Power
Of
Two
setup
Probing
probe
increase
Capacity
adjust
Capacity
setup
Probing
probe
adjust
Capacity
setup
Probing
probe
adjust
Capacity
increase
Capacity
clear
size
get
Capacity
is
Empty
put
add
contains
Key
keys
values
resize
Table
normalize
Index
gcd
insert
has
Key
get
remove
to
String
iterator
has
Next
next
remove
equals
to
String
size
is
Empty
normalize
Index
clear
contains
Key
has
Key
put
add
insert
get
remove
bucket
Remove
Entry
bucket
Insert
Entry
bucket
Seek
Entry
resize
Table
keys
values
iterator
has
Next
next
remove
to
String
int
Hash
vector
Hash
string
Hash
compute
Hash
hash
Code
hash
Code2
equals
hash
Code2
is
North
to
String
compare
To
to
String
add
count
k
Nearest
Neighbors
knn
intersects
contains
contains
add
count
k
Nearest
Neighbors
get
Points
get
Points
size
is
Empty
peek
poll
offer
iterator
offer
poll
peek
size
is
Empty
is
Empty
size
peek
is
Full
offer
poll
main
bench
Mark
Test
offer
poll
peek
size
is
Empty
is
Full
adjust
Index
size
is
Empty
clear
peek
poll
add
sink
swim
min
Child
less
swap
is
Empty
clear
size
peek
poll
contains
add
less
swim
sink
swap
remove
remove
At
is
Min
Heap
to
String
is
Empty
clear
size
peek
poll
contains
add
less
swim
sink
swap
remove
remove
At
is
Min
Heap
map
Add
map
Remove
map
Get
map
Swap
to
String
size
is
Empty
contains
peek
Min
Key
Index
poll
Min
Key
Index
peek
Min
Value
poll
Min
Value
insert
value
Of
delete
update
decrease
increase
sink
swim
min
Child
swap
less
less
to
String
is
Not
Empty
Or
Throw
key
Exists
And
Value
Not
Null
Or
Throw
key
Exists
Or
Throw
value
Not
Null
Or
Throw
key
In
Bounds
Or
Throw
is
Min
Heap
is
Min
Heap
compute
Hash
compute
Hash
Shallow
add
add
remove
contains
contains
add
add
contains
to
String
compute
Hash
add
add
add
All
Substrings
add
Right
add
Right
add
Left
add
Left
remove
Left
remove
Left
remove
Right
remove
Right
contains
contains
to
String
size
clear
is
Empty
add
remove
contains
iterator
to
String
get
Left
set
Left
get
Right
set
Right
get
Text
get
Data
set
Data
to
String
get
Root
search
insert
delete
find
Max
find
Min
find
Max
find
Min
to
String
right
Rotate
left
Rotate
splay
Util
splay
split
join
inorder
main
is
Empty
size
add
add
remove
remove
find
Min
find
Max
contains
contains
height
height
traverse
pre
Order
Traversal
has
Next
next
remove
in
Order
Traversal
has
Next
next
remove
post
Order
Traversal
has
Next
next
remove
level
Order
Traversal
has
Next
next
remove
random
Integer
List
random
Uniform
Unique
Integer
List
random
Uniform
Unique
Integer
List
rand
Int
rand
Long
sorted
Integer
List
get
Left
get
Right
get
Text
get
Tree
Display
to
String
clear
size
is
Empty
add
add
Last
add
First
add
At
peek
First
peek
Last
remove
First
remove
Last
remove
remove
At
remove
index
Of
contains
iterator
has
Next
next
remove
to
String
get
Parent
set
Parent
get
Left
set
Left
get
Right
set
Right
get
Child
set
Child
get
Degree
incraese
Degree
decraese
Degree
is
Marked
set
Marked
get
Element
to
String
move
To
Root
add
add
All
clear
contains
contains
All
is
Empty
iterator
remove
remove
All
retain
All
size
to
Array
to
Array
element
offer
peek
poll
remove
consolidate
link
cut
cascading
Cut
potential
compare
to
String
add
Child
insert
insert
delete
delete
contains
count
clear
clear
min
Function
build
Segment
Tree
range
Query1
range
Query1
range
Update1
assign
Function
propagate
Lazy
propagate1
range
Update1
print
Debug
Info
print
Debug
Info
main
build
Tree
update
sum
min
propagate
max
Function
sum
Function
min
Segment
Update
Fn
build
Segment
Tree
range
Query1
range
Query1
range
Update1
propagate
Lazy
propagate1
range
Update1
print
Debug
Info
print
Debug
Info
main
build
Segment
Tree
range
Query
range
Query2
range
Query
range
Query2
point
Update
point
Update
range
Update
main
range
Sum
Query
Example
range
Min
Query
Example
range
Max
Query
Example
to
String
apply
safe
Sum
safe
Mul
safe
Min
safe
Max
build
Segment
Tree
range
Query1
range
Query1
propagate1
propagate
Lazy1
range
Update1
range
Update1
print
Debug
Info
print
Debug
Info
main
min
Query
Sum
Update
sum
Query
Sum
Update
Example
min
Query
Assign
Update
Example
sum
Function
build
Segment
Tree
range
Query1
range
Query1
range
Update1
propagate
Lazy
propagate1
range
Update1
print
Debug
Info
print
Debug
Info
main
min
Function
sum
Function
min
Segment
Update
Fn
build
Segment
Tree
range
Query1
range
Query1
range
Update1
propagate
Lazy
propagate1
range
Update1
print
Debug
Info
print
Debug
Info
main
apply
safe
Sum
safe
Mul
safe
Min
safe
Max
build
Segment
Tree
range
Query1
range
Query1
propagate1
propagate
Lazy1
range
Update1
range
Update1
print
Debug
Info
print
Debug
Info
main
product
Query
Mul
Update
Example
gcd
Query
Mul
Update
Example
gcd
Query
Assign
Update
Example
sum
Query
Sum
Update
Example
t
min
Query
Assign
Update
Example
function
modify
query
main
example1
example2
sum
Function
mult
Ruf
mult
Lruf
build
Segment
Tree
range
Query1
range
Query1
range
Update1
propagate
Lazy
propagate1
range
Update1
print
Debug
Info
print
Debug
Info
main
sum
Combination
Fn
sum
Range
Update
Assign
Fn
build
Segment
Tree
range
Query1
range
Query1
range
Update1
assign
Function
propagate
Lazy
propagate1
range
Update1
print
Debug
Info
print
Debug
Info
main
find
connected
component
Size
size
components
unify
size
is
Empty
push
pop
peek
search
iterator
size
is
Empty
peek
push
pop
main
bench
Mark
Test
size
is
Empty
push
increase
Capacity
pop
peek
size
is
Empty
push
pop
peek
get
Color
set
Color
get
Value
set
Value
get
Left
set
Left
get
Right
set
Right
get
Parent
set
Parent
size
is
Empty
contains
insert
insert
Fix
left
Rotate
right
Rotate
delete
delete
Fix
successor
transplant
search
height
height
swap
Colors
update
Parent
Child
Link
find
Min
find
Max
iterator
has
Next
next
remove
main
height
size
is
Empty
contains
insert
insert
update
balance
left
Left
Case
left
Right
Case
right
Right
Case
right
Left
Case
left
Rotation
right
Rotation
remove
remove
find
Min
find
Max
iterator
has
Next
next
remove
validate
BST
Invarient
get
Value
set
Value
get
Left
get
Right
get
Text
size
contains
contains
is
Empty
insert
insert
insert
left
Rotation
right
Rotation
remove
remove
get
Left
get
Right
get
Text
height
size
is
Empty
contains
contains
insert
insert
update
balance
left
Left
Case
left
Right
Case
right
Right
Case
right
Left
Case
left
Rotation
right
Rotation
remove
remove
find
Min
find
Max
iterator
has
Next
next
remove
to
String
validate
BST
Invarient
lsb
prefix
Sum
sum
get
add
set
to
String
update
Range
add
get
prefix
Sum
lsb
size
is
Empty
get
set
add
remove
At
remove
reverse
binary
Search
sort
iterator
has
Next
next
remove
to
String
main
line
Circle
Intersection
main
display
circular
Segment
Area
triangle
Area
angle
Between
Vectors
main
equals
line
Segment
Line
Segment
Intersection
orientation
point
On
Line
segments
Intersect
get
Common
Endpoints
main
cost
minimum
Cost
Triangulation
collinear
collinear2
main
slope
Point
To
Line
normalise
get
Perp
Bisector
intersection
to
String
rotate
Point
main
contains
Point
collinear
dist
angle
Between
Vectors
main
segment
To
General
Form
main
convex
Polygon
Area
main
arccos
Safe
circle
Circle
Intersection
Area
circle
Circle
Intersection
rotate
Point
arcsin
Safe
point
Circle
Tangent
Points
main
angle
Between
Vectors
main
compare
convex
Hull
orientation
triangle
Area
triangle
Area
triangle
Area
triangle
Area
main
point
Inside
Triangle
point
Inside
Triangle2
collinear
main
create
Convex
Hull
compare
compare
collinear
main
coplanar
cross
dot
main
dist
compare
compare
closest
Pair
to
String
sort
CW
cut
intersect
orientation
make
List
make
Array
main
to
String
find
Edge
get
Tour
create
Infinite
Value
Matching
Cost
update
Matching
Cost
is
Better
Matching
Cost
to
String
set
Cost
Matrix
get
Min
Weight
Cost
get
Matching
solve
f
reconstruct
Matching
get
Bit
Position
get
Eulerian
Path
set
Up
graph
Has
Eulerian
Path
find
Start
Node
dfs
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
main
euler
Test1
cpp
Test1
compare
To
prims
main
compare
To
get
Mst
get
Mst
Cost
relax
Edges
At
Node
solve
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
main
example1
first
Graph
From
Slides
square
Graph
From
Slides
disjoint
On
First
Node
disjoint
Graph
eager
Prims
Example
From
Slides
lazy
Vs
Eager
Analysis
size
is
Empty
contains
peek
Min
Key
Index
poll
Min
Key
Index
peek
Min
Value
poll
Min
Value
insert
value
Of
delete
update
decrease
increase
sink
swim
min
Child
swap
less
less
to
String
is
Not
Empty
Or
Throw
key
Exists
And
Value
Not
Null
Or
Throw
key
Exists
Or
Throw
value
Not
Null
Or
Throw
key
In
Bounds
Or
Throw
is
Min
Heap
is
Min
Heap
get
Tour
get
Tour
Cost
solve
not
In
combinations
combinations
main
main
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
compare
To
get
Mst
get
Mst
Cost
mst
Exists
solve
relax
Edges
At
Node
size
is
Empty
contains
peek
Min
Key
Index
poll
Min
Key
Index
peek
Min
Value
poll
Min
Value
insert
value
Of
delete
update
decrease
increase
sink
swim
min
Child
swap
less
less
to
String
is
Not
Empty
Or
Throw
key
Exists
And
Value
Not
Null
Or
Throw
key
Exists
Or
Throw
value
Not
Null
Or
Throw
key
In
Bounds
Or
Throw
is
Min
Heap
is
Min
Heap
compare
To
get
Mst
get
Mst
Cost
add
Edges
solve
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
main
example1
first
Graph
From
Slides
square
Graph
From
Slides
lazy
Prims
Demo
From
Slides
get
Eulerian
Path
set
Up
graph
Has
Eulerian
Path
find
Start
Node
dfs
initialize
Empty
Graph
add
Directed
Edge
main
example
From
Slides
small
Example
scc
Count
get
Sccs
solve
dfs1
dfs2
create
Transpose
Graph
create
Graph
add
Edge
main
example
From
Cp4
example4
example3
example2
example1
run
Kosaraju
kahns
main
example
From
Slides
test1
test2
cycle
Test
compare
add
Edge
get
Graph
reconstruct
Path
dijkstra
create
Empty
Graph
find
Bridges
dfs
main
create
Graph
add
Edge
bellman
Ford
main
dfs
main
add
Directed
Edge
find
connected
size
union
compare
To
kruskals
dfs
main
add
Directed
Edge
tsp
compute
Tour
Cost
next
Permutation
get
First
swap
main
count
Connected
Components
main
add
Undirected
Edge
find
connected
component
Size
size
components
unify
reconstruct
Path
bfs
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
add
Unweighted
Undirected
Edge
main
format
Path
to
String
compare
To
astar
heuristic
main
add
Edge
compare
To
dijkstra
min
Length
Steiner
Tree
floyd
Warshall
main
is
Empty
peek
enqueue
dequeue
bfs
main
add
Directed
Edge
get
Components
count
Components
solve
dfs
create
Graph
add
Undirected
Edge
main
topological
Sort
visit
dag
Shortest
Path
main
dfs
topological
Sort
dag
Shortest
Path
main
find
Tree
Centers
create
Empty
Tree
add
Undirected
Edge
main
get
Value
tree
Height1
tree
Height2
is
Leaf
Node
main
test
Tree
Height1
test
Tree
Height2
make
Tree
get
Value
get
Children
add
Child
tree
Sum
main
make
Tree
add
Children
id
parent
children
to
String
trees
Are
Isomorphic
find
Tree
Centers
root
Tree
build
Tree
encode
create
Empty
Graph
add
Undirected
Edge
main
simple
Isomorphism
Test
test
Encoding
Tree
From
Slides
add
Children
id
parent
children
to
String
equals
root
Tree
build
Tree
create
Graph
add
Undirected
Edge
main
add
Children
set
Size
size
id
parent
children
root
Tree
build
Tree
to
String
lca
helper
create
Empty
Graph
add
Undirected
Edge
main
create
First
Tree
From
Slides
dfs
tree
Diameter
main
create
Graph
reset
Graph
add
Undirected
Edge
main
create
First
Tree
From
Slides
create
Empty
Graph
add
Undirected
Edge
add
Children
set
Size
size
index
parent
children
root
Tree
build
Tree
to
String
setup
dfs
visit
lca
init
query
Index
create
Empty
Tree
add
Undirected
Edge
find
Tree
Centers
encode
Tree
trees
Are
Isomorphic
main
dfs
find
Tree
Centers
create
Empty
Tree
add
Undirected
Edge
main
eccentricity
graph
Diameter
main
create
Graph
add
Undirected
Edge
find
Bridges
main
create
Graph
add
Edge
is
Empty
peek
push
pop
dfs
main
add
Directed
Edge
compare
To
get
Mst
get
Mst
Cost
relax
Edges
At
Node
solve
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
get
Mst
get
Mst
Cost
relax
Edges
At
Node
solve
create
Empty
Graph
add
Directed
Edge
add
Undirected
Edge
main
density
Test
size
is
Empty
contains
peek
Min
Key
Index
poll
Min
Key
Index
peek
Min
Value
poll
Min
Value
insert
value
Of
delete
update
decrease
increase
sink
swim
min
Child
swap
less
less
to
String
is
Not
Empty
Or
Throw
key
Exists
And
Value
Not
Null
Or
Throw
key
Exists
Or
Throw
value
Not
Null
Or
Throw
key
In
Bounds
Or
Throw
is
Min
Heap
is
Min
Heap
ford
Fulkerson
dfs
solve
bfs
main
test
Small
Flow
Graph
is
Residual
remaining
Capacity
augment
to
String
initialize
Empty
Flow
Graph
add
Edge
get
Graph
get
Max
Flow
visit
visited
mark
All
Nodes
As
Unvisited
execute
solve
add
Edge
solve
dfs
main
is
Residual
remaining
Capacity
augment
to
String
initialize
Empty
Flow
Graph
add
Edge
get
Graph
get
Max
Flow
execute
solve
solve
bfs
dfs
main
main
solve
is
Residual
remaining
Capacity
augment
to
String
initialize
Empty
Flow
Graph
add
Edge
get
Graph
get
Max
Flow
execute
solve
solve
dfs
is
Residual
remaining
Capacity
augment
to
String
initialize
Empty
Flow
Graph
add
Edge
get
Graph
get
Max
Flow
visit
visited
mark
All
Nodes
As
Unvisited
execute
solve
solve
bfs
main
is
Residual
remaining
Capacity
augment
to
String
initialize
Empty
Flow
Graph
add
Edge
get
Graph
get
Max
Flow
execute
solve
solve
dfs
main
solve
get
Augmenting
Path
main
test
Small
Network
mcbm
augment
create
Empty
Graph
add
Edge
main
solve
dfs
main
example
From
Slides2
example
From
Slides
test
Small
Flow
Graph
is
Bipartite
get
Two
Coloring
solve
color
Graph
main
display
Graph
is
Residual
remaining
Capacity
augment
to
String
initialize
Graph
add
Edge
add
Edge
visit
visited
mark
All
Nodes
As
Unvisited
get
Graph
get
Max
Flow
get
Min
Cost
get
Min
Cut
execute
solve
add
Edge
solve
dfs
main
test
Small
Flow
Graph
test
Example
From
My
Slides
init
adjust
Edge
Costs
solve
get
Augmenting
Path
compare
To
solve
bfs
dfs
main
test
Small
Flow
Graph
test
Graph
From
Slides
get
Apsp
Matrix
solve
reconstruct
Shortest
Path
create
Graph
main
scc
Count
get
Sccs
solve
dfs
create
Graph
add
Edge
main
get
Shortest
Paths
reconstruct
Shortest
Path
solve
main
get
Tour
get
Tour
Cost
solve
tsp
main
main
dfs
get
Strongly
Connected
Components
count
Strongly
Connected
Components
find
Articulation
Points
dfs
create
Graph
add
Edge
main
test
Example1
test
Example2
create
Graph
add
Edge
bellman
Ford
main
create
Empty
Graph
add
Edge
get
Graph
dijkstra
reconstruct
Path
size
is
Empty
contains
peek
Min
Key
Index
poll
Min
Key
Index
peek
Min
Value
poll
Min
Value
insert
value
Of
delete
update
decrease
increase
sink
swim
min
Child
swap
less
less
to
String
is
Not
Empty
Or
Throw
key
Exists
And
Value
Not
Null
Or
Throw
key
Exists
Or
Throw
value
Not
Null
Or
Throw
key
In
Bounds
Or
Throw
is
Satisfiable
solve
create
Implication
Graph
add
Xor
Clause
add
Or
Clause
main
to
String
compare
To
get
Mst
get
Mst
Cost
solve
check
main
find
connected
size
union
compare
To
get
Mst
get
Mst
Cost
kruskals
find
connected
size
union
main
bfs
bfs
main
add
Undirected
Edge
block
ID
set
query
main
combinations
With
Repetition
print
Combinations
With
Repetition
main
combinations
combinations
main
add
done
main
advance
shrink
get
Max
generate
Permutations
permutations
next
Permutation
get
First
swap
main
set
Bit
is
Set
clear
Bit
toggle
Bit
set
All
is
Power
Of
Two
power
Set
Using
Binary
power
Set
Recursive
main
combinations
Choose
R
combinations
next
Combination
main
sort
quicksort
quicksort
partition
swap
main
sort
quick
Sort3
partition3
randomized
Quick
Sort
swap
main
sort
heapsort
sink
swap
main
sort
bubble
Sort
swap
main
sort
sort
mergesort
merge
main
sort
get
Max
calculate
Number
Of
Digits
radix
Sort
count
Sort
main
sort
insertion
Sort
swap
main
sort
counting
Sort
main
sort
selection
Sort
swap
main
quick
Select
quick
Select
partition
swap
main
sort
bucket
Sort
main
random
Integer
Array
random
Long
Array
random
Integer
List
random
Uniform
Unique
Integer
List
rand
Value
rand
Value
create
Empty
Adjacency
List
add
Directed
Edge
add
Undirected
Edge
rand
create
Dag
main
randomize
Vector
product
freivalds
matrix
Deep
Copy
square
Matrix
Mult
matrix
Power
main
print2D
Matrix
solve
is
Inconsistent
has
Multiple
Solutions
main
simplex
rotate
main
rref
inverse
is
Inconsistent
has
Multiple
Solutions
egcd
mod
Inv
main
main
determinant
laplace
construct
Matrix
multiply
main
matrix
Deep
Copy
square
Matrix
Mult
matrix
Power
create
Transformation
Matrix
solve
Recurrence
compute
Initial
Values
main
inverse
solve
is
Inconsistent
has
Multiple
Solutions
main
tsp
fitness
true
Travel
Cost
mutate
select
Individual
crossover
main
mutate
shuffle
Array
to
String
run
fitness
to
String
mutate
select
Individual
crossover
main
run
fitness
mutate
select
Individual
crossover
main
to
String
knapsack
kmp
kmp
Helper
main
calculate
Z
main
to
Int
Array
construct
kasai
display
least
Cyclic
Rotation
main
main
add
Sentinels
get
Text
Length
get
Sa
get
Lcp
Array
build
Suffix
Array
build
Lcp
Array
to
Int
Array
construct
kasai
to
String
find
Color
From
Pos
to
String
to
String
compare
To
construct
init
compute
Text
Length
build
Reverse
Color
Mapping
verify
Min
And
Max
Ascii
Values
compute
Shift
build
Text
enough
Unique
Colors
In
Window
retrieve
String
log
add
Lcs
get
Longest
Common
Substrings
solve
advance
shrink
get
Min
function
modify
query
main
to
Int
Array
construct
contains
manachers
pre
Process
find
Palindrome
Substrings
main
main
rabin
Karp
rabin
Karp
Backwards
add
Right
remove
Right
add
Left
remove
Left
compute
Hash
main
to
Int
Array
construct
kasai
lrs
display
find
Occurrences
generate
Skip
Table
main
