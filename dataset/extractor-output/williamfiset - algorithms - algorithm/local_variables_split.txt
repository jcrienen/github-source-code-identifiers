arr
index
t
i
ii
jj
permutation
i
matching
Cost
first
to
Swap
i
tmp
cost
Matrix
i
j
n
g
mwpm
cost
matching
expected
Matching
cost
Matrix
impls
cost
matching
expected
Matching
cost
Matrix
impls
cost
matching
expected
Matching
cost
Matrix
impls
cost
matching
expected
Matching
cost
Matrix
impls
cost
matching
expected
Matching
cost
Matrix
impls
cost
matching
expected
Matching
n
g
mwpm
cost
matching
expected
Matching
n
g
mwpm
cost
matching
expected
Matching
n
g
mwpm
cost
matching
expected
Matching
n
g
mwpm
cost
expected
Cost
matching
expected
Matching
n
g
mwpm
cost
matching
n
g
mwpm
cost
matching
expected
Matching
loop
n
cost
Matrix
impls
matching
set
i
loop
n
cost
Matrix
impls
loop
n
cost
Matrix
impls
matching
bf
Mwpm
dp
Soln
bf
Soln
loop
n
cost
Matrix
impls
bf
Mwpm
dp
Soln
bf
Soln
i
j
val
total
i
i
values
coin
Values
amount
solution1
solution2
v1
v2
v3
i
values
coin
Values
amount
solution
selected
Coins
Sum
i
values
coin
Values
amount
solution
selected
Coins
Sum
str
sa1
sa2
sa3
sa1
sa2
sa3
suffix
Arrays
i
UNIQUE
CHARS
sa1
sa2
sa3
suffix
Arrays
i
text
lcp
Values
sa1
sa2
sa3
suffix
Arrays
i
text
lcp
Values
sa1
sa2
sa3
suffix
Arrays
i
text
sa1
sa2
sa3
suffix
Arrays
i
j
s1
s2
k
m
i
m
i
m
i
m
i
m
i
min
st
max
st
sum
st
mult
st
gcd
st
i
j
values
i
values
i
values
values
st
i
j
min
min
Index
k
loop
values
min
st
max
st
i
j
min
max
min
Index
max
Index
k
sl
sl
sl
sl
sl
sl
sl
sl
sl
sl
kd
Tree
point
Root
point
Left
point
Right
kd
Tree
kd
Tree
kd
Tree
point1
point2
point3
point4
kd
Tree
kd
Tree
kd
Tree
min1
min2
min3
kd
Tree
kd
Tree
kd
Tree
kd
Tree
Barren
kd
Tree
Left
kd
Tree
Right
kd
Tree
Two
root
Point
left
Point
right
Point
kd
Tree
point1
point2
point3
point4
point5
point6
point7
point8
kd
Tree
kd
Tree
ho
sz
loops
sz
ht
i
map2
loop
rand
nums
count
set
map
loop
keys
set
i
random
Val
keys
map
i
i
map
o1
o2
o3
o4
jmap
loop
probability1
probability2
nums
i
r
key
val
m
hm
loop
sz
probability
i
index
l1
l2
rand
val
lst
i
lst
i
i
hashtable
start
i
val
end
hashtable
start
i
val
end
hashtable
start
i
val
end
jmap
start
i
val
end
o1
o5
on7
jmap
mmap
loop
rand
nums
count
set
o1
o2
o3
o4
o1
o2
o3
map
loop
keys
set
i
random
Val
obj
keys
map
o11
o12
o13
i
i
jmap
loop
probability1
probability2
nums
i
r
key
val
m
hm
loop
sz
probability
i
key
Value
key
l1
l2
rand
Val
lst
i
rand
Num
obj
lst
i
obj
ho
map2
loop
rand
nums
count
set
map
loop
keys
set
i
random
Val
keys
map
i
i
map
o1
o2
o3
o4
jmap
loop
probability1
probability2
nums
i
r
key
val
m
hm
loop
sz
probability
i
index
l1
l2
rand
val
lst
i
lst
i
ho
map2
loop
rand
nums
count
set
map
loop
keys
set
i
random
Val
keys
map
i
i
map
o1
o2
o3
o4
jmap
loop
probability1
probability2
nums
i
r
key
val
m
hm
loop
sz
probability
i
index
l1
l2
rand
val
lst
i
lst
i
i
val
i
INITIAL
VALUE
prime
power
i
ch
obj
r1
r1Center
r1NW
Corner
r1SW
Corner
r1SE
Corner
r1NE
Corner
r1Above
r1Below
r1Left
r1Right
r1
r1Center
r1NW
Corner
r1SW
Corner
r1SE
Corner
r1NE
Corner
r1Above
r1Below
r1Left
r1Right
r1
SZ
region
quad
Tree
i
sum
i
j
test
W
H
quad
Tree
grid
i
x
y
i
x1
y1
x2
y2
region
expected
Pts
quad
Tree
Count
queue
queue
n
queue
i
i
i
i
i
i
i
i
queue
queue
q
Size
int
Q
java
Q
operations
r
elem
queues
q
q
nums
i
i
lst
pq
pq2
loop
p1
p2
tmp
ar
d
pq
pq2
i
e
r
strs
q
in
pq
lst
i
lst
i
lst
i
q
q
nums
i
i
i
lst
pq
pq2
q
strs
strs
q
i
rand
Nums
PQ
pq
j
j
rand
Val
pq
PQ
i
elem
in
remove
Order
in
pq
i
sz
rand
Nums
pq1
pq2
v1
v2
i
sz
rand
Nums
pq1
pq2
index
remove
Num
S
Zs
PQ
pq
nums
i
rand
Num
remove
Num
lst
i
lst
i
lst
i
q
q
nums
i
i
i
lst
pq
pq2
q
strs
strs
q
i
rand
Nums
PQ
pq
j
j
rand
Val
pq
PQ
i
elem
in
remove
Order
in
pq
i
sz
rand
Nums
pq1
pq2
v1
v2
i
sz
rand
Nums
pq1
pq2
index
remove
Num
S
Zs
PQ
pq
nums
i
rand
Num
remove
Num
lst
i
lst
i
lst
i
pq
pq
pq
pq
pq
pq
pq
pq
pairs
n
pq
i
min
Index
i
pairs
n
pq
i
min
Value
i
names
pq
i
i
n
pq
n
bound
random
Values
pq1
pq2
p
i
n
indexes
pq1
pq2
indexes
To
Remove
p
i
ii
items
To
Remove
iii
index
To
Remove
contains1
contains2
lst
i
s
set
i
j
sub
small
Primes
collision
Happened
s
set
len
i
j
sub
i
j
sub
sz
loops
set
javaset
l
rand
Str
l
rand
Str
range
sb
i
s
loop
nums
i
num
s
loop
sz
hs
nums
i
num
obj
ch1
ch2
s
lst
i
lst
i
splay
Tree
data
splay
Tree
data
splay
Tree
data
splay
Tree
data
splay
Tree
data
pq
splay
Tree
Max
q
tree
tree
tree
tree
tree
tree
bst
iter
bst
iter
bst
iter
bst
iter
bst
iter
bst
iter
bst
iter
bst
iter
i
size
tree
lst
j
value
lst
i
out
expected
test
Tree
tree
iter
i
i
input
i
input
i
input
i
input
strs
java
Linked
List
loops
rand
Nums
i
rm
val
iter1
iter2
i
rm
val
iter1
iter2
java
Linked
List
loops
rand
Nums
i
rm
index
num1
num2
iter1
iter2
java
Linked
List
loops
rand
Nums
i
elem
index1
index2
iter1
iter2
strs
lst
i
i
lst
i
i
r
expected
i
number
i
c
r
i
number
t
t
t
t1
t2
t3
t1
t2
t3
t
t
t
t
c
c
ar
st
n
ar
st
i
j
k
i1
i2
bf
Sum
seg
Tree
Sum
i3
i4
rand
Value
s
i
m
i
m
i
i
i
i
combination
Fns
range
Update
Fns
n
loop
ar
st
i
j
k
i1
i2
i3
i4
rand
Value
bf
seg
Tree
Answer
s
i
m
i
m
i
m
i
gcd
s
i
i
i
i
tree
size
tree
values
tree
n
ar
tree
i
j
bf
Sum
seg
Tree
Sum
s
i
ar
st
n
ar
st
i
j
k
i1
i2
i3
i4
rand
Value
bf
Min
seg
Tree
Min
s
i
m
i
m
i
i
i
i
n
ar
st
i
j
k
i1
i2
bf
Min
seg
Tree
Min
i3
i4
rand
Value
s
i
m
i
m
i
i
i
i
values
st
ar
st
ar
st
ar
st
ar
st
ar
st
ar
st1
st2
ar
st1
ar
st1
combination
Fns
range
Update
Fns
n
ar
st
i
j
k
i1
i2
i3
i4
rand
Value
bf
seg
Tree
Answer
s
i
m
i
m
i
i
i
i
ar
st
ar
st
ar
st
ar
st
ar
st
n
ar
st
i
j
k
i1
i2
i3
i4
rand
Value
bf
Sum
seg
Tree
Sum
s
i
m
i
m
i
i
i
i
ar
st
n
ar
st
i
j
k
i1
i2
i3
i4
rand
Value
bf
Sum
seg
Tree
Sum
s
i
m
i
m
i
i
i
i
ar
st
n
ar
st
i
j
k
i1
i2
i3
i4
rand
Value
bf
Max
seg
Tree
Max
s
i
m
i
m
i
i
i
i
uf
uf
sz
uf
i
i
i
i
i
j
uf
stacks
ts
i
size
lst
j
value
lst
i
values
set
i
v
ts
i
lst
j
value
tree
Set
Remove
tree
Remove
n
height
upper
Bound
is
Valid
lst
i
i
set
i
v
n
height
c
b
upper
Bound
ts
i
size
lst
j
value
lst
i
ar
ft
ar
ft
ar
ft
i
i
rand
List
ft
j
sum
N
lo
hi
k
n
rand
List
ft
j
index
rand
val
SIZE
ft
arr
loop
i
val
lst
i
k
values
ft
values
ft
values
ft
n
values
ft
sum
delta
loop
i
n
values
i
ft
mocked
Ft
loop
i
delta
lo
hi
pts
expected
hull
pts
expected
hull
pts
expected
hull
pts
expected
hull
pts
expected
hull
pts
expected
hull
pts
cost
pts
cost
pts
cost
n
graph
path
expected
n
graph
expected
path
n
graph
expected
path
loops
i
n
graph
graph2
s
e
bf
Solver
p1
p2
edge
Matrix
graph2
num
Edges
i
u
v
graph
i
n
graph
solver
sorted
Bridges
expected
n
graph
solver
sorted
Bridges
expected
n
graph
solver
sorted
Bridges
expected
n
graph
solver
sorted
Bridges
expected
bridges
i
node1
node2
pair
i
i
graph
i
graph
graph1
node6
children
node2
node7
node8
node1
node3
node0
node4
node5
graph
graph
graph
graph
graph
n
loops
tree
impl1
impl2
nodes
g
next
Node
random
Node
n
tree
root
fast
Solver
root
fast
Solver
root
fast
Solver
id
n
g
root1
root2
slow
Solver
fast
Solver
i
l
r
L
R
lca1
lca2
nodes
g
next
Node
random
Node
n
tree
root
solver
root
solver
root
solver
id
tree1
tree2
tree1
tree2
n
tree1
tree2
tree3
tree1
tree2
tree1
tree2
n
loops
tree1
tree2
impl1
impl2
nodes
g
next
Node
random
Node
graph
graph
graph
graph
graph
tree1
tree2
tree1
tree2
tree1
tree2
n
tree1
tree2
tree3
tree
tree
Encoding
expected
Encoding
tree
node0
node1
node2
node3
node4
node5
node6
node7
node8
node9
graph
i
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
n
graph
solver
actual
expected
graph
i
n
g
solver
actual
expected
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
set
scc
Component
Ids
component
Id
m
i
j
n
i
j
v
solver
soln
solver
soln
TRAILS
n
trail
m
num
Random
Edges
fw
s
bf
TRAILS
n
trail
m
num
Random
Edges
fw
s
bf
TRAILS
n
trail
m
num
Random
Edges
fw
Solver
s
bf
Solver
e
fwp
bfp
n
s
e
m
fw
fw
Path
n
s
e
m
i
fw
fw
Path
n
s
e
m
solver
soln
edges
n
i
j
g
solver
g
order
dag
Gen
g
solver
order
p
dag
Gen
g
solver
order
n
n
n
n
n
n
n
s
t
n
s
t
n
s
t
n
s
t
n
s
t
k
k
t
i
i
n
s
t
n
s
t
g
in
Flows
out
Flows
i
edges
i
graph
i
n
g
solver
n
g
solver
n
g
solver
graph
i
solver
n
ordering
map
from
hash
count
i
from
to
hash
count
count
graph
solver
graph
solver
n
graph
n
graph
n
graph
solver
n
graph
solver
n
graph
solver
n
graph
solver
n
graph
n
graph
n
graph
solver
n
graph
solver
n
graph
n
graph
n
graph
solver
path
expected
n
graph
graph
i
n
graph
solver
sorted
Bridges
expected
n
graph
solver
sorted
Bridges
expected
n
graph
solver
sorted
Bridges
expected
n
graph
solver
sorted
Bridges
expected
bridges
i
node1
node2
pair
graph
i
n
g
solver
actual
expected
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
n
g
solver
expected
Sccs
set
scc
Component
Ids
component
Id
dist
dist
dist
dist
dist
dist
n
dist
expected
tsp
Recursive
Tour
Cost
tsp
Iterative
Tour
Cost
n
i
dist
dp
Recursive
Solver
dp
Iterative
Solver
dp1
dp2
bf
n
i
dist
dp
Recursive
Solver
dp
Iterative
Solver
bf
Path
dp1
dp2
bf
n
dist
bf
Path
bf
start
Node
dp
Recursive
Solver
dp
Iterative
Solver
dp1
dp2
n
dist
solver
n
dist
solver
i
j
val
total
i
a
lazy
Range
Adder
expected
a
lazy
Range
Adder
expected
n
arr1
arr2
lazy
Range
Adder
i
l
r
x
i
i
values
w
sz
i
r
ar
window
lo
hi
max
i
size
sorter
values
copy
size
sorter
values
copy
size
quick
Select
values
k
copy
kth
Largest
Element
array
size
values
i
copy
size
values
i
copy
run
Length
run
upper
Char
Text
upper
Char
Pattern
max
Length
Text
max
Length
Pattern
text
pattern
occurrences
text
Index
match
pat
Index
all
Substrings
sets
h
string
set
i
j
substring
ans
count
x
expected
Lcss
solver
lcss
strs
answers
strs
answers
strs
answers
strs
answers
strs
answers
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
k
strs
ans
solver
lcss
len
strings
k
solver
lcss
slow
Solver
lcss2
len
strings
k
solver
lcss
slow
Solver
lcss2
len
strings
k
solver
lcss
slow
Solver
lcss2
strings
i
sz
chrs
i
k
strs
i
ans
solver
lcss
i
i
i
z
Length
log
N
xx
yy
zz
i
n
Z
z
n
Inverse
i
z
n
w
i
i
j
Max
k
Step
index
step
j
zeta
k
kk
x
y
z
polynomial1
polynomial2
result
num
Primes
primes
index
is
Composite
sqrt
Limit
i
j
i
primes
factors
divisor
Queue
divisor
next
divisor
x
c
y
d
limit
i
x
chunk
mask
num
Chunks
sqrt
Limit
chunks
i
j
limit
sieve
i
ret
tmp
limit
i
v
tmp
v
x
p
r
i
mask
A
N
M
r1
a
n
m
r2
i
ans
i
p
num
Primes
primes
index
is
Composite
sqrt
Limit
i
j
i
x
factors
divisor
Queue
divisor
next
divisor
x
c
y
d
limit
i
lcm
v
tmp
v
gcd
x
d
inv
a
New
m
New
i
factors
iterator
val
total
next
Val
i
j
res
i
M
i
inv
i
x
i
factors
divisor
Queue
divisor
next
divisor
x
c
y
d
ret
tmp
limit
i
factorial
i
num
den
gcd
N
R
P
expected
actual
n
arr
k
q
k
r
y
k
kth
wk
exp
length
c
d
e
i
padded
i
n
y
i
i
i
mid1
mid2
res1
res2
lo
hi
min
Value
mid
value
lo
hi
target
function
sqrt
Val
radius
Lower
Bound
radius
Upper
Bound
volume
sphere
Volume
Function
sphere
Radius
lo
mid
hi
values
best
mid1
mid2
res1
res2
function
root
dp
c1
c2
dp
history
p1
p2
best
State
minimum
reduced
State
match
Cost
dp
history
num
Pairs
pair
States
pair
Cost
k
i
j
state
state
i
pair
new
State
new
Cost
map
left
Nodes
i
state
pair
Used
left
Node
right
Node
i
right
Node
count
to
Include
n
pts
i
cost
i
j
mwpm
min
Cost
matching
i
ii
jj
cost
Matrix
mwpm
cost
n
m
dp
i
j
lcs
Len
lcs
index
i
j
v
A
B
ln
ribbon
Squares
plains
ans
scenes
len
n
dp
i
i
j
dp
i
n
i
j
n
robbed
Houses
i
j
robber
houses
amount
robbed
Houses
sum
dp
i
dp
count
n
tiles
solver
i
m
dp
substitute
delete
insert
AL
BL
arr
i
j
min
a
b
solver
solver2
m
room
Value
sc
N
K
sum
i
index
N
K
N
K
line
C
N
M
dp
i
cows
day
i
i
day
farms
frequencies
i
ans
state
t3
t4
count
state
s
n
AL
BL
dp
i
j
min
a
b
m
dp
substitute
Or
Skip
delete
insert
a
b
solver
solver2
n
len
dp
i
j
n
max
Value
sum
i
n
m
dp
i
j
lcs
Len
lcs
index
i
j
v
A
B
N
DP
i
w
v
sz
sz
items
Selected
i
item
Index
capacity
V
W
N
DP
i
w
v
sz
N
DP
sz
i
W
V
knapsack
Value
new
Cost
Matrix
i
j
i
dp
history
matching
Cost
p1
p2
best
State
best
Matching
Cost
reduced
State
match
Cost
map
left
Nodes
matching
Size
i
state
pair
Used
left
Node
right
Node
i
j
left
Node
right
Node
count
cost
Matrix
mwpm
cost
matching
i
node1
node2
m
dp
i
coin
Value
j
solution
change
coin
Index
coin
Value
can
Select
Coin
dp
i
solution
i
selected
Coin
Value
cell
With
Fewest
Coins
dp
min
Coins
value
n
coins
coins
coins
coins
dp
i
n
k
dp
history
num
Pairs
pair
States
pair
Cost
k
i
j
state
state
i
pair
new
State
new
Cost
map
left
Nodes
i
state
pair
Used
left
Node
right
Node
i
right
Node
count
cost
Matrix
mwpm
cost
matching
i
node1
node2
t
i
inv
i
i
len
k
sb
i
suffix
Len
suffix
Array
j
k
suffix
formatted
Str
cmp
suffix
Ranks
ranks
i
pos
i
suffix
Rank
new
Rank
i
last
Suffix
Rank
curr
Suffix
Rank
i
sa
i
p
r
sa
min
len
i
i
i
suffix
sa
values
sparse
Table
i
i
p
i
left
Interval
right
Interval
length
p
k
length
p
k
left
Interval
right
Interval
gcd
i
i
i
j
left
Interval
right
Interval
i
len
p
left
Interval
right
Interval
len
p
left
Interval
right
Interval
sum
p
result
p
len
p
values
sparse
Table
values
sparse
Table
values
sparse
Table
curr
Left
curr
Right
i
node
node
Height
curr
node
node
node
new
Node
elem
Node
next
Node
left
Sub
Tree
right
Sub
Tree
min
Sub
Tree
min
remove
Elem
replaced
Point
removed
removed
next
Node
replaced
Point
pow2
i
hashtable
Keys
i
hashtable
Values
i
old
Key
Table
old
Value
Table
key
Table
Tmp
value
Table
Tmp
i
offset
i
j
x
old
Value
offset
i
j
x
offset
i
j
x
offset
i
x
old
Value
sb
i
MODIFICATION
COUNT
bucket
Index
new
Entry
bucket
Index
bucket
Index
entry
bucket
Index
entry
links
bucket
existent
Entry
old
Val
bucket
new
Table
i
bucket
Index
bucket
keys
values
element
Count
next
Iter
sb
i
i
val
i
INITIAL
VALUE
prime
power
i
ch
obj
cx
cy
count
i
heap
neighbors
i
xx
yy
radius
distance
point
Quadrant
radius
cx
cy
dx
dy
check
Horizontal
Cell
check
Vertical
Cell
check
Diagonal
Cell
quadrant
points
i
q
n
int
Q
start
i
i
end
array
Deque
i
i
i
root
j
index
from
to
j
tmp
heap
Size
i
i
heap
Size
i
i
index
Of
Last
Elem
node1
node2
parent
heap
Size
left
right
smallest
elem
i
elem
j
i
index
Of
Last
Elem
removed
data
elem
heap
Size
left
right
heap
Size
i
i
index
Of
Last
Elem
node1
node2
parent
heap
Size
left
right
smallest
i
elem
j
elem
index
index
Of
Last
Elem
removed
data
elem
heap
Size
left
right
set
set
set
set1
set2
i
minki
min
Value
i
value
i
old
Value
j
index
from
to
j
tmp
lst
i
from
to
j
i
j
i
mod
j
prime
j
j
i
i
i
block
i
i
block
MASK
max
Sz
matrix
k
i
block
offset
mask
sb
i
n
big
Alpha
i
mod
i
j
i
k
right
Char
i
k
right
Char
left
Char
N
values
i
i
j
k
sb
l
r
left
right
search
Result
left
Subtree
right
Subtree
temp
temp
temp
temp
p
p
right
left
l
r
splay
Tree
sc
data
c
cmp
tmp
cmp
expected
Node
Count
stack
node
expected
Node
Count
stack
node
expected
Node
Count
stack1
stack2
node
expected
Node
Count
queue
node
lst
i
lst
i
lst
i
lst
i
sb
lines
level
next
nn
widest
line
aa
tmp
perpiece
i
line
hpw
j
c
k
k
k
j
f
gap1
gap2
k
k
trav
next
temp
i
new
Node
data
data
data
i
trav
trav
index
trav
data
sb
trav
node
z
num
Of
Kids
x
temp
Right
minimum
array
Size
node
Sequence
i
num
Roots
x
degree
next
y
pointer
z
o1Comparable
stack
buf
curr
start
node
created
new
node
is
prefix
i
ch
next
Node
node
i
ch
cur
Node
node
i
ch
next
Node
N
tm
tm
tm
tm
v
st
i
mid
N
tm
tm
tm
tm
v
st
N
tm
tm
tm
overlaps
Left
Segment
overlaps
Right
Segment
tm
values
st
l
r
values
st
l
r
values
st
l
r
N
tm
segment
Value
min
Value
max
Value
segment
tm
tm
v
st
l
r
q
v
st
l
r
q
v
st
l
r
q
N
tm
tm
range
Sum
range
Sum
tm
tm
v
st
l
r
N
tm
tm
tm
tm
v
st
gcd
N
tm
tm
tm
tm
v
st
l
r
q
v
st
l
r
q
v
st
l
r
q
v
st
l
r
q
v
st
v
st
l
r
q
i
res
values
st
values
st
N
tm
tm
tm
tm
v
st
N
tm
tm
tm
tm
v
st
i
root
next
root1
root2
s
n
int
Stack
start
i
i
end
array
Deque
i
i
list
Stack
i
i
array
Stack
i
i
elem
node
cmp
x
y
z
y
y
x
z
x
y
y
original
color
w
w
tmp
Color
expected
Node
Count
stack
node
values
rb
Tree
node
cmp
new
Root
inserted
Node
cmp
new
Left
Node
new
Right
Node
left
Node
Height
right
Node
Height
new
Parent
new
Parent
new
Root
removed
Node
cmp
new
Left
Node
new
Right
Node
successor
Value
replacement
successor
Value
replacement
expected
Node
Count
stack
node
val
is
Valid
cmp
cmp
new
Parent
new
Parent
cmp
cmp
cmp
left
Node
Height
right
Node
Height
new
Parent
new
Parent
cmp
successor
Value
successor
Value
expected
Node
Count
stack
node
val
is
Valid
i
parent
sum
fenwick
Tree
i
parent
sum
i
i
tmp
index
sb
i
ar
i
A
B
C
D
x1
y1
x2
y2
vx
dx
dy
cx
cy
x1
y1
x2
y2
circle
Area
half
Circle
Area
three
Points
Area
v1x
v1y
v2x
v2y
angle
pizza
Slice
Area
v1
x
v1
y
v2
x
v2
y
determinant
dotproduct
v1Length
v2Length
value
center
p1
p2
endpoints
n
singleton
collinear
Segments
mid
Point1
mid
Point2
m
b
m
b
m1
m2
b1
b2
x
y
value
o1
o2
o3
o4
points
p1
p2
p3
p4
points
point
point1
point2
len
dp
i
j
k
v1
x
v1
y
v2
x
v2
y
determinant
area
a
b
c
p2
middle
perp
Slope
x
y
fpx
fpy
ptx
pty
x
y
x
Rotated
y
Rotated
angle
fixed
Point
point
rotated
Point
i
p0
lo
hi
mid
p1
sign
p1
p2
bound
Sign
seg
Sign1
seg
Sign2
ax
ay
bx
by
cx
cy
area
d
Lat
d
Lon
a
dotproduct
v1Length
v2Length
value
abc
abc
N
fp
area
fpx
fpy
i
pt1
pt2
a
b
c
d
N
points
r
R
c
C
dist
intersections
d
part1
part2
part3
r
R
c
C
dist
cx
Cx
cy
Cy
vx
vy
x
y
point
angle
pt1
pt2
fpx
fpy
ptx
pty
x
y
x
Rotated
y
Rotated
px
py
cx
cy
dx
dy
dist
angle
angle1
angle2
p1
p2
radius
circle
Center
origin
points
pt1
pt2
dotproduct
v1Length
v2Length
value
n
k
hull
i
last
Upper
Chain
Index
i
index
last
Pt
i
value
s
v1
x
v1
y
v2
x
v2
y
determinant
a
b
c
side1
side2
side3
dir1
dir2
dir3
dir1
dir2
dir3
ax
ay
bx
by
cx
cy
area
a
b
c
i
j
p
i
j
p
k1
k2
N
hull
i
top
dx1
dy1
dx2
dy2
area
pts
hull
v1
v2
v3
v4
v3x
v3y
v3z
dx
dy
n
x
Queue
Front
x
Queue
Back
y
Working
Set
pt1
pt2
d
i
next
Point
pt
upper
Bound
next
dist
lower
Bound
dist
l
centroid
X
centroid
Y
i
center
a1
a2
n
res
i
j
d1
d2
a1
a2
b1
b2
c1
c2
det
x
y
cross
list
i
l
temp
i
square
Polygon
p1
p2
list
poly1
poly2
mapping
inv
Mapping
id
odd
Degree
Node
Count
i
matrix
i
from
Node
Id
to
Node
Id
wmcm
matching
i
node1
node2
from
to
edge
e1
e2
i
euler
Path
Solver
cpp
Tour
tour
Total
new
Cost
Matrix
i
j
i
dp
history
matching
Cost
p1
p2
best
State
best
Matching
Cost
reduced
State
match
Cost
map
left
Nodes
matching
Size
i
state
pair
Used
left
Node
right
Node
i
j
left
Node
right
Node
count
soln
i
from
start
Nodes
end
Nodes
i
start
i
next
Edge
g
i
n
g
solver
path
n
g
cpp
n
sum
visited
Nodes
pq
connected
i
edge
i
NUM
NODES
graph
mst
Cost
edges
dest
Node
Index
m
edge
Count
degree
dest
Node
Index
edge
g
i
n
g
solver
cost
n
g
solver
cost
n
g
solver
cost
n
g
solver
cost
n
g
solver
cost
n
g
solver
cost
n
g1
g2
i
j
r
eager
Solver
lazy
Solver
start
Time
eager
Cost
end
Time
lazy
Cost
i
minki
min
Value
i
value
i
old
Value
j
index
from
to
j
tmp
lst
i
from
to
j
END
STATE
memo
end
r
next
subset
Without
Next
min
Dist
end
new
Distance
i
tour
Cost
last
Index
state
i
best
Index
best
Dist
j
new
Dist
subsets
elements
Left
To
Pick
i
n
distance
Matrix
start
Node
solver
n
g
solver
g
i
m
edge
Count
degree
dest
Node
Index
edge
edges
dest
Node
Index
i
minki
min
Value
i
value
i
old
Value
j
index
from
to
j
tmp
lst
i
from
to
j
edges
m
edge
Count
edge
node
Index
g
i
n
g
solver
cost
n
g
solver
cost
n
g
solver
cost
n
g
solver
cost
soln
i
from
start
Nodes
end
Nodes
i
start
i
next
graph
i
n
graph
solver
n
graph
solver
i
u
graph
i
n
graph
n
graph
n
graph
n
graph
n
graph
n
solver
sccs
multimap
i
n
in
Degree
q
i
index
order
at
g
solver
ordering
g
solver
g
solver
g
solver
dist
path
at
pq
visited
node
edges
i
edge
new
Dist
i
i
n
graph
solver
bridges
i
node1
node2
graph
i
dist
relaxed
An
Edge
v
v
E
V
start
edges
d
i
count
edges
num
Nodes
graph
node
Count
list
i
root
next
root1
root2
sum
uf
count
visited
stack
node
edges
num
Nodes
graph
node
Count
list
n
permutation
i
best
Tour
best
Tour
Cost
tour
Cost
cost
i
from
to
last
first
first
to
Swap
i
tmp
n
matrix
edge
Cost
optimal
Tour
i
best
Tour
tour
Cost
uf
i
edges
num
Nodes
graph
components
list
i
root
next
root1
root2
path
at
visited
queue
node
edges
graph
i
n
graph
solver
start
end
path
G
F
open
Set
closed
Set
pq
node
edges
i
edge
g
h
RANDOM
n
graph
i
X
Y
N
connections
locations
m
k
i
j
ii
jj
node1
node2
i
s
e
d
a
dx
dy
dists
pq
visited
node
edges
i
edge
new
Dist
v
t
dp
i
mask
j
mask
j
sub
Mask
j
k
n
k
i
j
k
i
j
INF
matrix1
matrix2
ret
val
count
visited
queue
DEPTH
TOKEN
node
edges
num
Nodes
graph
node
Count
i
j
list
i
graph
i
n
graph
solver
count
components
i
n
visited
order
index
u
v
n
dist
v
new
Dist
N
adj
Matrix
ordering
dists
edges
ordering
visited
i
at
topsort
dist
i
node
Index
adjacent
Edges
new
Dist
N
graph
i
ordering
dists
n
degree
leaves
i
edges
processed
Leafs
new
Leaves
tree
i
graph
graph2
graph3
graph4
graph5
graph6
root
root
node0
node1
node2
node3
node4
node5
node6
node7
node8
total
root
root
node4
node3
node1
nodem6
node0
node7
nodem4
node2
node9
node8
centers1
centers2
rooted
Tree1
tree1Encoding
rooted
Tree2
tree2Encoding
n
degree
leaves
i
edges
processed
Leafs
new
Leaves
root
child
labels
sb
graph
i
tree1
tree2
tree
root0
root
child
graph
i
graph
root
root
subtree
Node
Count
child
count
graph
i
root
solver
n
tree
best
Dist
index
edges
tuple
dist
furthest
Index
diameter
graph
num
Nodes
diameter
graph
i
i
root
solver
lca
n
tree
graph
i
root
rooted
Tree
subtree
Node
Count
child
euler
Tour
Size
l
r
i
i
i
p
i
left
Interval
right
Interval
len
p
left
Interval
right
Interval
tree
i
n
degrees
leaves
i
edges
processed
Leafs
new
Leaves
n
root
degree
parent
visited
leafs
q
at
edges
new
Leafs
map
i
tree
Size
p
labels
parent
Inner
Parentheses
l1
l2
tree1
tree2
encoding1
encoding2
best
Dist
index
edges
result
dist
centers
n
visited
prev
result
furthest
Node1
furthest
Node2
path
i
tree
i
graph
graph2
graph3
graph4
graph5
graph6
depth
id
edges
diameter
radius
eccentricity
graph
diameter
graph
i
i
stack
parent
Stack
at
to
parent
edges
n
graph
solver
bridges
i
node1
node2
graph
i
count
visited
stack
node
edges
num
Nodes
graph
node
Count
list
edges
dest
Node
Index
m
edge
Count
degree
dest
Node
Index
edge
g
i
to
cost
m
edge
Count
degree
dest
Node
Index
edge
Cost
rows
header
percentage
n
g1
g2
num
Edges
Included
i
j
r
adj
List
Solver
matrix
Solver
start
list
Cost
end
list
Time
Ms
matrix
Cost
matrix
Time
Ms
i
minki
min
Value
i
value
i
old
Value
j
index
from
to
j
tmp
lst
i
from
to
j
n
visited
min
Cut
max
Flow
flow
cap
i
dfs
Flow
flow
i
prev
q
node
cap
bottle
Neck
edge
edge
n
s
t
solver
u
v
i
e1
e2
f
cap
bottle
Neck
n
s
t
solver
result
Graph
u
v
i
e1
e2
next
f
q
node
cap
num
Edges
edge
cap
bottle
Neck
n
s
t
solver
mice
holes
M
H
N
S
T
solver
i
i
mouse
j
hole
i
u
v
i
e1
e2
f
edges
bottle
Neck
u
v
i
e1
e2
flow
q
prev
node
cap
bottle
Neck
edge
edge
n
s
t
solver
result
Graph
u
v
i
e1
e2
f
edges
bottle
Neck
n
s
t
solver
result
Graph
path
bottle
Neck
dist
prev
i
from
path
edge
n
s
t
solver
N
matches
visited
next
i
opposite
Node
graph
i
n
graph
f
i
edges
rcap
bottle
Neck
n
s
t
solver
g
n
s
t
solver
g
n
s
t
solver
nodes
Visited
next
Color
visit
Count
edges
count
n
graph
n
f
solver
u
v
i
e1
e2
e1
e2
f
i
edges
cap
bottle
Neck
n
s
t
solver
n
s
t
solver
dist
i
from
path
bottle
Neck
dist
prev
pq
node
edges
i
edge
new
Dist
path
edge
next
f
i
q
node
cap
num
Edges
edge
cap
bottle
Neck
n
s
t
solver
n
s
t
solver
i
j
k
i
j
k
i
j
path
at
matrix
i
n
m
solver
dist
i
j
i
j
path
str
i
node
graph
i
n
graph
solver
sccs
multimap
i
i
path
at
k
i
j
k
i
j
n
graph
i
start
solver
d
i
i
str
Path
path
nodes
state
memo
prev
index
next
Index
next
State
min
Cost
index
next
next
State
new
Cost
n
distance
Matrix
solver
NUM
NODES
adj
Matrix
sccs
u
min
v
v
i
edges
graph
i
n
graph
solver
is
Articulation
Point
i
n
graph
solver
is
Articulation
Point
i
graph
i
dist
i
i
E
V
start
graph
d
i
i
degree
ipq
visited
node
Id
min
Value
new
Dist
path
dist
at
i
minki
min
Value
i
value
i
old
Value
j
index
from
to
j
tmp
lst
i
sccs
i
graph
i
n
graph
cmp
uf
cheapest
stop
i
e
uc
vc
i
e
uf
u
v
u
v
x
y
x
y
n
m
i
g
solver
ans
i
root
next
root1
root2
pq
uf
index
edge
i
root
next
root1
root2
num
Nodes
edges
solver
cost
visited
queue
at
neighbors
depth
n
graph
i
i
sum
lo
Id
hi
Id
i
i
lo
Max
hi
Min
i
i
values
range
N
i
j
item
Count
n
used
Count
seq
used
n
subset
i
i
r
set
i
i
array
lazy
Range
Adder
used
picked
N
i
i
first
to
Swap
i
tmp
sequence
alpha
N
MAX
VAL
subset
i
mask
i
set
used
N
elements
Left
To
Pick
i
i
i
j
R
set
colors
selection
split
Point
pivot
i
j
tmp
sorter
array
j
k
m
mid
p
m
k
t
m
tmp
sorter
array
n
i
i
left
right
largest
tmp
sorter
array
sorted
i
tmp
array
sorter
sorted
Values
i
n
left
right
n1
n2
n
i1
i2
ar
i
array
max
i
maximum
number
Of
Digits
place
Value
range
frequency
sorted
Values
i
digit
i
i
digit
sorter
numbers
i
j
tmp
sorter
array
min
Value
max
Value
i
sz
b
i
i
k
sorter
nums
N
i
swap
Index
j
tmp
sorter
array
index
split
Point
pivot
i
j
tmp
quick
Select
array
kth
Largest
Element
min
Value
max
Value
i
N
M
num
Buckets
buckets
i
i
bi
bucket
bi
j
bucket
k
sorter
array
ar
i
ar
i
lst
i
lst
i
graph
i
n
levels
nodes
Per
Level
n
l
g
level
Index
l
i
j
gen
i
N
vector
i
j
n
v
expected
result
N
new
Matrix
i
N
new
Matrix
i
j
k
N
new
Matrix
i
P
matrix
matrix2
result
identity
n
Rows
n
Cols
lead
r
i
temp
lv
j
j
n
Cols
y
x
n
Cols
n
Empty
Rows
y
x
augmented
Matrix
x
y
z
min
c
j
r
i
v
v
j
i
j
n
i
inv
I
j
inv
J
tmp
matrix
n
m
r
i
k
t
inverse
k
j
c
k
n
augmented
i
j
inv
i
j
n
Cols
y
x
n
Cols
n
Empty
Rows
y
x
ret
tmp
p
augmented
Matrix
inv
i
x
y
z
m
n
n
a
b
c
d
e
f
g
h
i
det
i
c
sign
n
new
Matrix
r
Ptr
i
c
Ptr
j
a
Rows
a
Cols
b
Rows
b
Cols
c
i
j
k
a
b
c
N
new
Matrix
i
N
new
Matrix
i
j
k
N
new
Matrix
i
P
T
i
i
initial
Values
size
T
result
ans
j
N
DP
n
i
coefficients
k
i
fib
coefficients2
N
DP
n
answer
n
augmented
i
j
inv
i
j
n
Rows
n
Cols
lead
r
i
temp
lv
j
j
n
Cols
y
x
n
Cols
n
Empty
Rows
y
x
matrix
inv
N
max
generation
next
Generation
i
lo
hi
fitness
tour
fittest
Indv
fittest
Indv
Fitness
epoch
fitness
Sum
i
in
best
Epoch
Indv
best
Epoch
Fitness
i
in
norm
best
Epoch
Travel
Cost
best
Travel
Cost
best
Epoch
Travel
Cost
best
Travel
Cost
i
parent1
parent2
child
j
fitness
i
from
to
last
first
fitness
i
from
to
last
first
r
mid
l
h
new
Path
start
end
minimum
maximum
missing
j
i
i
n
m
path
i
i
from
to
last
first
i
i
j
tmp
index
i
generation
next
Generation
i
lo
hi
epoch
fitness
Sum
i
in
fittest
max
Fitness
i
in
norm
i
parent1
parent2
child
j
i
score
i
r
mid
l
h
split
Point
new
DNA
N
generation
next
Generation
i
lo
hi
fitness
best
Fitness
epoch
fitness
Sum
i
in
best
Epoch
Fitness
i
norm
i
parent1
parent2
child
j
value
weight
i
r
mid
l
h
split
Point
new
Bit
Set
i
i
n
multiplier
weights
values
i
cap
ga
Ans
answer
i
N
DP
i
w
v
sz
matches
m
n
i
j
arr
arr
i
len
matches
size
Z
L
R
k
i
str
sa
text
i
i
p
r
inv
i
i
len
k
i
suffix
Len
suffix
f
k
j
sj
i
s
index
strings
sentinel
Indexes
t
sa
k
solver
token
t
t
i
inv
i
i
len
k
sb
i
suffix
Len
string
j
k
suffix
formatted
Str
colors
color
Index
i
suffix
Len
string
j
k
suffix
formatted
Str
cmp
suffix
Ranks
ranks
i
pos
i
suffix
Rank
new
Rank
i
last
Suffix
Rank
curr
Suffix
Rank
i
i
k
str
j
ascii
Val
sentinel
i
k
str
j
set
i
s
j
suffix
Array
tree
lo
hi
shrink
Window
window
Lcp
i
res
pattern
text
sa
text
i
i
p
r
suffix
str
lo
hi
substr
len
mid
suffix
index
suffix
len
cmp
arr
n
c
r
p
i
inv
I
arr
i
S
centers
palindromes
i
diameter
index
index
s
i
n
i
mod
str
pat
matches
PL
TL
pattern
Hash
rolling
Hash
BIG
PL
POWERS
i
i
first
Value
last
Value
j
matches
PL
TL
pattern
Hash
rolling
Hash
BIG
PL
POWERS
i
i
first
Value
last
Value
j
rolling
Hashes
k
i
str
sa
text
i
i
p
r
inv
i
i
len
k
max
len
lrss
i
i
suffix
Len
suffix
occurrences
skip
Table
n
text
Index
pattern
Index
skip
Table
i
searcher
t
p
